/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2025 RDK Management
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <stdio.h>
#include <cstring>
#include <net/if.h>
#include "em_cmd.h"
#include "dm_easy_mesh.h"

extern "C" const char* __asan_default_options() {
    return "detect_leaks=0";
}

// Helper: Print hash map contents
void PrintStaMap(const char* map_name, hash_map_t* map) {
    std::cout << map_name << " contents:\n";
    dm_sta_t* sta = static_cast<dm_sta_t*>(hash_map_get_first(map));
    while (sta != nullptr) {
        char sta_str[18], bss_str[18], radio_str[18];
        dm_easy_mesh_t::macbytes_to_string(sta->m_sta_info.id, sta_str);
        dm_easy_mesh_t::macbytes_to_string(sta->m_sta_info.bssid, bss_str);
        dm_easy_mesh_t::macbytes_to_string(sta->m_sta_info.radiomac, radio_str);
        std::cout << "  STA: " << sta_str 
                  << ", BSS: " << bss_str
                  << ", Radio: " << radio_str << "\n";
        sta = static_cast<dm_sta_t*>(hash_map_get_next(map, sta));
    }
}

// Helper: Create a test STA
em_sta_info_t CreateSta(uint8_t sta_mac_byte, uint8_t bss_mac_byte, uint8_t radio_mac_byte) {
    em_sta_info_t sta_info;
    memset(&sta_info, 0, sizeof(sta_info));
    for (int i = 0; i < 6; i++) {
        sta_info.id[i] = sta_mac_byte;
        sta_info.bssid[i] = bss_mac_byte;
        sta_info.radiomac[i] = radio_mac_byte;
    }
    return sta_info;
}

// Helper: Print all op_class info
void PrintOpClass(const dm_easy_mesh_t &mesh)
{
    for (unsigned int i = 0; i < mesh.m_num_opclass; i++) {
        char mac_str[18] = {0};
        mac_address_t mac_copy = {0};
        /* Copy const MAC into a mutable buffer */
        memcpy(mac_copy, mesh.m_op_class[i].m_op_class_info.id.ruid, sizeof(mac_address_t));
        dm_easy_mesh_t::macbytes_to_string(mac_copy, mac_str);
        std::cout << "OpClass " << i
                  << ": RUID=" << mac_str
                  << ", Type=" << mesh.m_op_class[i].m_op_class_info.id.type
                  << ", OpClass=" << mesh.m_op_class[i].m_op_class_info.id.op_class
                  << ", Channel=" << mesh.m_op_class[i].m_op_class_info.channel
                  << "\n";
    }
}

// Helper: Initialize op_class array
void InitOpClass(dm_easy_mesh_t &mesh, unsigned int num) {
    mesh.init();
    mesh.m_num_opclass = num;

    for (unsigned int i = 0; i < num; i++) {
        //mesh.m_op_class[i].m_op_class_info.id.type = (i % 2 == 0) ? em_op_class_type_capability + 1 : em_op_class_type_capability;
		mesh.m_op_class[i].m_op_class_info.id.type = em_op_class_type_capability;
        memset(mesh.m_op_class[i].m_op_class_info.id.ruid, 0, sizeof(mac_address_t));
        mesh.m_op_class[i].m_op_class_info.id.op_class = i + 1;
        mesh.m_op_class[i].m_op_class_info.channel = i + 10;
    }
}

static em_sta_info_t create_sta_info(const mac_address_t sta,
                                     const mac_address_t bssid,
                                     const mac_address_t radio)
{
    em_sta_info_t info {};
    memcpy(info.id, sta, sizeof(mac_address_t));
    memcpy(info.bssid, bssid, sizeof(mac_address_t));
    memcpy(info.radiomac, radio, sizeof(mac_address_t));
    return info;
}


static void add_sta(
    dm_easy_mesh_t &mesh,
    const unsigned char *sta_mac,
    const unsigned char *bssid,
    const unsigned char *radio_mac)
{
    em_sta_info_t info{};
    memcpy(info.id, sta_mac, sizeof(mac_address_t));
    memcpy(info.bssid, bssid, sizeof(mac_address_t));
    memcpy(info.radiomac, radio_mac, sizeof(mac_address_t));

    mesh.put_sta_info(&info, em_target_sta_map_consolidated);
}


static void print_sta(const char *tag, dm_sta_t *sta)
{
    if (sta == nullptr) {
        std::cout << tag << ": STA = NULL" << std::endl;
        return;
    }

    mac_addr_str_t mac_str;
    dm_easy_mesh_t::macbytes_to_string(sta->m_sta_info.id, mac_str);
    std::cout << tag << ": STA MAC = " << mac_str << std::endl;
}


static void print_sta_info(const char *tag, em_sta_info_t *info)
{
    if (info == nullptr) {
        std::cout << tag << ": STA INFO = NULL" << std::endl;
        return;
    }
    mac_addr_str_t sta_str, bss_str, radio_str;
    dm_easy_mesh_t::macbytes_to_string(info->id, sta_str);
    dm_easy_mesh_t::macbytes_to_string(info->bssid, bss_str);
    dm_easy_mesh_t::macbytes_to_string(info->radiomac, radio_str);
    std::cout << tag << ": STA=" << sta_str
              << " BSSID=" << bss_str
              << " RADIO=" << radio_str << std::endl;
}

// Helper to initialize BSS entries
void InitBss(dm_easy_mesh_t &mesh, unsigned int num_bss) {
    mesh.init();
    mesh.m_num_bss = num_bss;
    for (unsigned int i = 0; i < num_bss; i++) {
        mesh.m_bss[i].m_bss_info.vap_index = i;
        mesh.m_bss[i].m_bss_info.enabled = true;
        snprintf(mesh.m_bss[i].m_bss_info.ssid, sizeof(mesh.m_bss[i].m_bss_info.ssid), "SSID_%d", i);
    }
}

// Helper to print current BSS list
void PrintBss(const dm_easy_mesh_t &mesh) {
    std::cout << "Current BSS list (m_num_bss=" << mesh.m_num_bss << "):\n";
    for (unsigned int i = 0; i < mesh.m_num_bss; i++) {
        std::cout << "  Index " << i 
                  << ": vap_index=" << mesh.m_bss[i].m_bss_info.vap_index
                  << ", ssid=" << mesh.m_bss[i].m_bss_info.ssid
                  << ", enabled=" << mesh.m_bss[i].m_bss_info.enabled
                  << "\n";
    }
}

static em_subdoc_info_t *make_subdoc(const char *json)
{
    size_t len = strlen(json) + 1;
    em_subdoc_info_t *subdoc =
        reinterpret_cast<em_subdoc_info_t *>(
            malloc(sizeof(em_subdoc_info_t) + len));

    memset(subdoc, 0, sizeof(em_subdoc_info_t));
    memcpy(subdoc->buff, json, len);
    return subdoc;
}

void print_ssid_info(em_network_ssid_info_t *info)
{
    if (!info) {
        std::cout << "SSID info is NULL" << std::endl;
        return;
    }
    std::cout << "SSID ID           : " << info->id << std::endl;
    std::cout << "SSID              : " << info->ssid << std::endl;
    std::cout << "Passphrase        : " << info->pass_phrase << std::endl;
    std::cout << "Enabled           : " << info->enable << std::endl;
    std::cout << "Num bands         : " << (int)info->num_bands << std::endl;
    std::cout << "Num hauls         : " << (int)info->num_hauls << std::endl;
    for (unsigned int i = 0; i < info->num_hauls; i++) {
        std::cout << "  Haul[" << i << "] = " << info->haul_type[i] << std::endl;
    }
}		

static void print_interface(const em_interface_t& iface)
{
    std::cout << "Interface Name : " << iface.name << std::endl;

    std::cout << "Interface MAC  : ";
    for (int i = 0; i < 6; ++i) {
        std::cout << std::hex << std::setw(2) << std::setfill('0')
                  << static_cast<int>(iface.mac[i]);
        if (i < 5) std::cout << ":";
    }
    std::cout << std::dec << std::endl;

    std::cout << "Media Type     : "
              << static_cast<unsigned int>(iface.media)
              << std::endl;
}

static void print_interface(const em_interface_t* iface)
{
    ASSERT_NE(iface, nullptr);

    std::cout << "Interface Name : " << iface->name << std::endl;

    std::cout << "Interface MAC  : ";
    for (int i = 0; i < 6; ++i) {
        std::cout << std::hex << std::setw(2) << std::setfill('0')
                  << static_cast<int>(iface->mac[i]);
        if (i < 5) std::cout << ":";
    }
    std::cout << std::dec << std::endl;

    std::cout << "Media Type     : "
              << static_cast<unsigned int>(iface->media)
              << std::endl;
}

static void print_ieee_1905_security_cap(const em_ieee_1905_security_cap_t* cap)
{
    ASSERT_NE(cap, nullptr);

    std::cout << "Onboarding Protocol : "
              << static_cast<unsigned int>(cap->onboarding_proto) << std::endl;
    std::cout << "Integrity Algorithm : "
              << static_cast<unsigned int>(cap->integrity_algo) << std::endl;
    std::cout << "Encryption Algorithm: "
              << static_cast<unsigned int>(cap->encryption_algo) << std::endl;
}

static void print_ieee_1905_security_info(
        const em_ieee_1905_security_info_t* info)
{
    ASSERT_NE(info, nullptr);
    std::cout << "Security Info ID (MAC): ";
    for (int i = 0; i < 6; i++) {
        std::cout << std::hex << std::setw(2) << std::setfill('0')
                  << static_cast<int>(info->id[i]);
        if (i < 5) std::cout << ":";
    }
    std::cout << std::dec << std::endl;
    std::cout << "Onboarding Protocol : "
              << static_cast<unsigned int>(info->sec_cap.onboarding_proto)
              << std::endl;
    std::cout << "Integrity Algorithm : "
              << static_cast<unsigned int>(info->sec_cap.integrity_algo)
              << std::endl;
    std::cout << "Encryption Algorithm: "
              << static_cast<unsigned int>(info->sec_cap.encryption_algo)
              << std::endl;
}

static void populate_sta(dm_easy_mesh_t &mesh, const char *sta_mac_str, const char *bssid_str, const char *radio_mac_str)
{
    em_sta_info_t sta_info {};
    memset(&sta_info, 0, sizeof(sta_info));
    dm_easy_mesh_t::string_to_macbytes(
        const_cast<char *>(sta_mac_str),
        sta_info.id
    );
    dm_easy_mesh_t::string_to_macbytes(
        const_cast<char *>(bssid_str),
        sta_info.bssid
    );
    dm_easy_mesh_t::string_to_macbytes(
        const_cast<char *>(radio_mac_str),
        sta_info.radiomac
    );
    mesh.put_sta_info(&sta_info, em_target_sta_map_consolidated);
}


static std::string build_valid_ssid_list()
{
    std::ostringstream oss;
    oss << "[";
    for (int i = 0; i < EM_MAX_NET_SSIDS; i++) {
        oss << "{ \"SSID\": \"ssid" << i << "\", \"HaulType\": 0 }";
        if (i != EM_MAX_NET_SSIDS - 1) oss << ",";
    }
    oss << "]";
    return oss.str();
}

cJSON* create_valid_cJSON_array()
{
    cJSON *obj = new cJSON();
    // For this test, we assume type == 1 indicates a valid array.
    obj->type = 1;
    obj->child = nullptr; // Simplified valid array structure.
    return obj;
}

// Helper function to create an invalid (non-array) cJSON object.
cJSON* create_invalid_cJSON_object()
{
    cJSON *obj = new cJSON();
    // For this test, we assume type != 1 indicates non-array type.
    obj->type = 2; 
    obj->child = nullptr;
    return obj;
}

// Helper function to print MAC address.
void printMacAddress(const unsigned char* mac)
{
    if (mac)
    {
        std::cout << "MAC Address: ";
        for (int i = 0; i < 6; i++)
        {
            std::cout << std::hex << static_cast<int>(mac[i]);
            if(i < 5)
                std::cout << ":";
        }
        std::cout << std::dec << std::endl;
    }
}

void configure_device(dm_easy_mesh_t &mesh) {
    dm_device_t &device = mesh.m_device;
    em_device_info_t &info = device.m_device_info;
	strncpy(info.id.net_id, "DEV1", sizeof(info.id.net_id));
    info.profile = em_profile_type_1;
    strcpy(info.manufacturer, "TestManufacturer");
    strcpy(info.serial_number, "SN123456");
    strcpy(info.manufacturer_model, "ModelX");
    strcpy(info.software_ver, "v1.0.0");
}

void print_network_info(em_network_info_t *info)
{
    if (!info) {
        std::cout << "Network info is NULL" << std::endl;
        return;
    }
    std::cout << "Network ID           : " << info->id << std::endl;
    std::cout << "Num of devices       : " << info->num_of_devices << std::endl;
    std::cout << "Timestamp            : " << info->timestamp << std::endl;
    std::cout << "Controller IF name   : " << info->ctrl_id.name << std::endl;
    std::cout << "Controller IF media  : " << info->ctrl_id.media << std::endl;
    std::cout << "Network media        : " << info->media << std::endl;
}
	
static void print_dpp_info(const ec_data_t& info)
{
    std::cout << "DPP Version: " << info.version << std::endl;

    std::cout << "DPP Frequencies: ";
    for (int i = 0; i < DPP_MAX_EN_CHANNELS; ++i) {
        std::cout << info.ec_freqs[i] << " ";
    }
    std::cout << std::endl;

    std::cout << "DPP MAC: ";
    for (int i = 0; i < 6; ++i) {
        printf("%02X", info.mac_addr[i]);
        if (i < 5) printf(":");
    }
    std::cout << std::endl;

    std::cout << "DPP Session Type: "
              << (info.type == ec_session_type_cfg ? "CFG" : "RECFG")
              << std::endl;
}

static void print_sta_info(const dm_sta_t* sta)
{
    ASSERT_NE(sta, nullptr);

    const em_sta_info_t& info = sta->m_sta_info;

    std::cout << "STA MAC: ";
    for (int i = 0; i < 6; ++i) {
        printf("%02X", info.id[i]);
        if (i < 5) printf(":");
    }
    std::cout << std::endl;

    std::cout << "BSSID: ";
    for (int i = 0; i < 6; ++i) {
        printf("%02X", info.bssid[i]);
        if (i < 5) printf(":");
    }
    std::cout << std::endl;

    std::cout << "Radio MAC: ";
    for (int i = 0; i < 6; ++i) {
        printf("%02X", info.radiomac[i]);
        if (i < 5) printf(":");
    }
    std::cout << std::endl;
}

static void print_sta_info(const em_sta_info_t* info)
{
    ASSERT_NE(info, nullptr);

    auto print_mac = [](const char* label, const mac_address_t mac) {
        std::cout << label << ": ";
        for (int i = 0; i < 6; ++i) {
            printf("%02X", mac[i]);
            if (i < 5) printf(":");
        }
        std::cout << std::endl;
    };

    print_mac("STA MAC", info->id);
    print_mac("BSSID", info->bssid);
    print_mac("Radio MAC", info->radiomac);
}

/**
 * @brief Verify that analyze_ap_cap_query processes a valid AP capability query event correctly
 *
 * This test verifies that when a valid AP capability query event is provided to the analyze_ap_cap_query API, 
 * the API returns the expected value and successfully creates a non-null command output. This ensures that the method
 * correctly handles valid input by setting up and processing the event as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 001@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                                                                                                              | Expected Result                                                         | Notes       |
 * | :--------------: | --------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- | ----------- |
 * | 01               | Invoke analyze_ap_cap_query API with a valid AP capability query event.                       | evt.type = em_bus_event_type_ap_cap_query, evt.data_len = 128, evt.u.subdoc.name = "ValidAPCapPayload", evt.params.net_node = nullptr, pcmd[0] = nullptr | API returns 1; pcmd[0] is not nullptr after invocation                   | Should Pass |
 */
TEST(dm_easy_mesh_t, analyze_ap_cap_query_valid_ap_cap_query_event)
{
    std::cout << "Entering analyze_ap_cap_query_valid_ap_cap_query_event test" << std::endl;
    dm_easy_mesh_t mesh;
    // Prepare valid AP capability query event
    em_bus_event_t evt = {};
    evt.type = em_bus_event_type_ap_cap_query;
    evt.data_len = 128;
    strncpy(evt.u.subdoc.name, "ValidAPCapPayload", sizeof(evt.u.subdoc.name) - 1);
    // evt.params must be valid because constructor uses it
    evt.params.net_node = nullptr;
    // Command output array (must start as nullptr)
    em_cmd_t* pcmd[1] = { nullptr };
    std::cout << "Invoking analyze_ap_cap_query" << std::endl;
    int ret = mesh.analyze_ap_cap_query(&evt, pcmd);
    std::cout << "Method returned: " << ret << std::endl;
    EXPECT_EQ(ret, 1);
    ASSERT_NE(pcmd[0], nullptr);
    delete pcmd[0];
    pcmd[0] = nullptr;
    mesh.deinit();
    std::cout << "AP capability command created successfully" << std::endl;
    std::cout << "Exiting analyze_ap_cap_query_valid_ap_cap_query_event test" << std::endl;
}

/**
 * @brief Test analyze_ap_cap_query API with a null event pointer to verify error handling
 *
 * This test case verifies that the analyze_ap_cap_query API returns an error when passed a NULL event pointer while providing a valid command pointer array. It ensures that the function can gracefully handle a missing event pointer without causing undefined behavior.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 002@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize the mesh object and create pcmd array with a null pointer for command output | mesh object, pcmd = {nullptr} | Object initialized and pointer array created successfully | Should be successful |
 * | 02 | Invoke analyze_ap_cap_query with evt as NULL and the valid pcmd array | evt = NULL, pcmd = {nullptr} | API returns a value less than 0 indicating an error | Should Pass |
 * | 03 | Assert that the return value from analyze_ap_cap_query is less than 0 | ret from analyze_ap_cap_query invocation | EXPECT_LT assertion passes confirming error handling | Should Pass |
 */
TEST(dm_easy_mesh_t, analyze_ap_cap_query_null_event_pointer)
{
    std::cout << "Entering analyze_ap_cap_query_null_event_pointer test" << std::endl;    
    dm_easy_mesh_t mesh;    
    // Create a valid pointer array for command output.
    em_cmd_t* pcmd[1] = { nullptr };    
    std::cout << "Invoking analyze_ap_cap_query with evt=NULL and valid pcmd array" << std::endl;    
    int ret = mesh.analyze_ap_cap_query(NULL, pcmd);    
    std::cout << "Method returned: " << ret << std::endl;    
    EXPECT_LT(ret, 0);
    std::cout << "Exiting analyze_ap_cap_query_null_event_pointer test" << std::endl;
}

/**
 * @brief Verify that the analyze_ap_cap_query API returns an error when provided with a valid event and a NULL command pointer.
 *
 * This test verifies the robustness of the analyze_ap_cap_query function by ensuring that it correctly handles
 * the scenario where the command pointer is NULL while a valid event is provided. The function is expected to return
 * a negative error code, indicating failure in processing the AP capability query when the command pointer is missing.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 003@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                               | Test Data                                                                                          | Expected Result                                   | Notes         |
 * | :--------------: | ----------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | ------------------------------------------------- | ------------- |
 * | 01               | Prepare a valid event for AP capability query                                             | evt.type = em_bus_event_type_ap_cap_query, evt.data_len = 128, evt.u.subdoc.name = "ValidAPCapPayload" | Valid event is set up correctly for the API call  | Should be successful |
 * | 02               | Invoke analyze_ap_cap_query with the valid event and NULL command pointer                   | input: event pointer valid, command pointer = NULL                                               | API returns a negative value indicating error     | Should Pass   |
 */
TEST(dm_easy_mesh_t, analyze_ap_cap_query_null_command_pointer)
{
    std::cout << "Entering analyze_ap_cap_query_null_command_pointer test" << std::endl;    
    dm_easy_mesh_t mesh;    
    // Prepare a valid event for AP capability query.
    em_bus_event_t evt = {};
    evt.type = em_bus_event_type_ap_cap_query;
    evt.data_len = 128;
    strncpy(evt.u.subdoc.name, "ValidAPCapPayload", sizeof(evt.u.subdoc.name)-1);    
    std::cout << "Invoking analyze_ap_cap_query with valid evt and pcmd=NULL" << std::endl;    
    int ret = mesh.analyze_ap_cap_query(&evt, NULL);    
    std::cout << "Method returned: " << ret << std::endl;    
    EXPECT_LT(ret, 0);
    std::cout << "Exiting analyze_ap_cap_query_null_command_pointer test" << std::endl;
}

/**
 * @brief Test that analyze_ap_cap_query returns an error when the payload is missing a sub-document.
 *
 * This test verifies that when an event of type em_bus_event_type_ap_cap_query is passed with an invalid payload 
 * (data_len set to 0, indicating a missing sub-document), the analyze_ap_cap_query API returns a negative error code. 
 * The test confirms that the API can correctly handle this invalid input scenario.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 004@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                                         | Test Data                                                                                              | Expected Result                                                                        | Notes            |
 * | :--------------: | ------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------- | ---------------- |
 * | 01               | Prepare event structure with type 'em_bus_event_type_ap_cap_query' and set data_len=0 to simulate missing sub-document. | evt.type = em_bus_event_type_ap_cap_query, evt.data_len = 0, pcmd[0] = nullptr                           | Event is set up with an invalid payload.                                               | Should be successful |
 * | 02               | Invoke the analyze_ap_cap_query API with the prepared event and command pointer.                                        | Input: evt, pcmd; Output: ret value                                                                      | The API returns a negative error code indicating failure.                              | Should Fail      |
 * | 03               | Assert that the returned error code is negative using EXPECT_LT.                                                      | ret < 0                                                                                                | Assertion passes confirming that a negative error code was returned.                     | Should be successful |
 */
TEST(dm_easy_mesh_t, analyze_ap_cap_query_invalid_payload_missing_subdocument)
{
    std::cout << "Entering analyze_ap_cap_query_invalid_payload_missing_subdocument test" << std::endl;    
    dm_easy_mesh_t mesh;
    // Prepare an event with valid type but invalid payload: data_len 0 indicates missing sub-document.
    em_bus_event_t evt = {};
    evt.type = em_bus_event_type_ap_cap_query;
    evt.data_len = 0;  // invalid payload length
    // Intentionally do not set sub-document fields.    
    em_cmd_t* pcmd[1] = { nullptr };    
    std::cout << "Invoking analyze_ap_cap_query with evt.type=" << evt.type 
              << " and data_len=" << evt.data_len << " (missing sub-document)" << std::endl;
    int ret = mesh.analyze_ap_cap_query(&evt, pcmd);    
    std::cout << "Method returned: " << ret << std::endl;    
    EXPECT_LT(ret, 0);
    std::cout << "Exiting analyze_ap_cap_query_invalid_payload_missing_subdocument test" << std::endl;
}


/**
 * @brief Verify that analyze_ap_cap_query correctly handles a corrupted payload scenario.
 *
 * This test checks the behavior of the analyze_ap_cap_query method when it is provided with an event that has a valid event type but a corrupted payload. The event's sub-document contains a malformed string, and the test verifies that the method returns a negative value to indicate failure.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 005@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                      | Test Data                                                                                                                                                         | Expected Result                                                  | Notes         |
 * | :--------------: | ------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | ------------- |
 * | 01               | Prepare an event object with valid event type, non-zero data_len, and corrupted sub-document name| evt.type = em_bus_event_type_ap_cap_query, evt.data_len = 256, evt.u.subdoc.name = "!!!@@@###CORRUPTED_PAYLOAD$$$"                                                  | Event object is successfully prepared                            | Should be successful |
 * | 02               | Invoke analyze_ap_cap_query with the corrupted event and verify the API returns a negative value    | pcmd = {nullptr}, evt as prepared above                                                                                                                           | Return value < 0 and EXPECT_LT assertion passes (indicating failure) | Should Fail   |
 */
TEST(dm_easy_mesh_t, analyze_ap_cap_query_corrupted_payload)
{
    std::cout << "Entering analyze_ap_cap_query_corrupted_payload test" << std::endl;    
    dm_easy_mesh_t mesh;    
    // Prepare an event with valid type but with corrupted payload.
    em_bus_event_t evt = {};
    evt.type = em_bus_event_type_ap_cap_query;
    // Set data_len to a non-zero value indicating payload present.
    evt.data_len = 256;
    // Corrupt the sub-document by setting an unexpected/malformed string.
    strncpy(evt.u.subdoc.name, "!!!@@@###CORRUPTED_PAYLOAD$$$", sizeof(evt.u.subdoc.name)-1);    
    em_cmd_t* pcmd[1] = { nullptr };    
    std::cout << "Invoking analyze_ap_cap_query with evt.type=" << evt.type 
              << ", data_len=" << evt.data_len 
              << " and corrupted subdoc.name=" << evt.u.subdoc.name << std::endl;              
    int ret = mesh.analyze_ap_cap_query(&evt, pcmd);    
    std::cout << "Method returned: " << ret << std::endl;    
    EXPECT_LT(ret, 0);
    std::cout << "Exiting analyze_ap_cap_query_corrupted_payload test" << std::endl;
}

/**
 * @brief Test commit_bss_config API with valid configuration for vap_index 0
 *
 * This test validates that invoking commit_bss_config with a valid dm_easy_mesh_t structure, configured with one BSS and appropriate MAC addresses for both ruid and bssid, returns the expected value. It checks that the API correctly processes the provided configuration, ensuring the proper functionality for vap_index 0.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 006@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Setup and invoke commit_bss_config with valid configuration for vap_index 0 | m_num_bss = 1, mac1 = {0x11,0x12,0x22,0x33,0x44,0x55}, mac2 = {0x12,0x13,0x24,0x35,0x46,0x55}, vap_index = 0 | commit_bss_config returns 1 as asserted by ASSERT_EQ | Should Pass |
 */
TEST(dm_easy_mesh_t, commit_bss_config_valid_vap0)
{
    std::cout << "Entering commit_bss_config_valid_vap0 test" << std::endl;
    dm_easy_mesh_t easyMesh;    
    easyMesh.m_num_bss = 1;
    mac_address_t mac1 = {0x11, 0x12, 0x22, 0x33, 0x44, 0x55};
    mac_address_t mac2 = {0x12, 0x13, 0x24, 0x35, 0x46, 0x55};
    memcpy(easyMesh.m_bss[0].m_bss_info.ruid.mac, mac1, sizeof(mac_address_t));
    memcpy(easyMesh.m_bss[0].m_bss_info.bssid.mac, mac2, sizeof(mac_address_t));
    unsigned int vap_index = 0;
    std::cout << "Invoking commit_bss_config with vap_index = " << vap_index << " and m_num_bss = " << easyMesh.m_num_bss << std::endl;
    int ret = easyMesh.commit_bss_config(easyMesh, vap_index);
    std::cout << "commit_bss_config returned: " << ret << std::endl;
    ASSERT_EQ(ret, 1);
    std::cout << "Exiting commit_bss_config_valid_vap0 test" << std::endl;
}

/**
 * @brief Verify that commit_bss_config returns success when invoked with a valid non-zero VAP.
 *
 * This test validates the behavior of commit_bss_config when provided with a valid dm_easy_mesh_t object that has a non-zero number of BSS entries and properly initialized MAC addresses. The test ensures that the API returns the expected success code (1) when invoked with correct parameters.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 007@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                        | Test Data                                                                                                                      | Expected Result                                            | Notes           |
 * | :--------------: | ------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------- | --------------- |
 * | 01               | Initialize a dm_easy_mesh_t instance.                              | No inputs.                                                                                                                     | Instance is successfully created.                         | Should be successful |
 * | 02               | Set the number of BSS entries to 2.                                 | m_num_bss = 2                                                                                                                  | m_num_bss is set to 2.                                      | Should be successful |
 * | 03               | Copy predefined MAC addresses into the first BSS's ruid and bssid.  | mac1 = {0x11, 0x12, 0x22, 0x33, 0x44, 0x56}, mac2 = {0x12, 0x13, 0x24, 0x35, 0x46, 0x57}                                          | MAC addresses are correctly copied into the structure.    | Should be successful |
 * | 04               | Set the VAP index for configuration.                                | vap_index = 1                                                                                                                  | vap_index is set to 1.                                      | Should be successful |
 * | 05               | Invoke commit_bss_config with the configured easyMesh object.        | Input: easyMesh instance (m_num_bss = 2, initialized MAC addresses), vap_index = 1; Output: Expected return value = 1                | API returns 1 and the assertion ASSERT_EQ(ret, 1) passes.    | Should Pass     |
 */
TEST(dm_easy_mesh_t, commit_bss_config_valid_non_zero_vap)
{
    std::cout << "Entering commit_bss_config_valid_non_zero_vap test" << std::endl;
    dm_easy_mesh_t easyMesh;
    easyMesh.m_num_bss = 2;
    mac_address_t mac1 = {0x11, 0x12, 0x22, 0x33, 0x44, 0x56};
    mac_address_t mac2 = {0x12, 0x13, 0x24, 0x35, 0x46, 0x57};
    memcpy(easyMesh.m_bss[0].m_bss_info.ruid.mac, mac1, sizeof(mac_address_t));
    memcpy(easyMesh.m_bss[0].m_bss_info.bssid.mac, mac2, sizeof(mac_address_t));
    unsigned int vap_index = 1;
    std::cout << "Invoking commit_bss_config with vap_index = " << vap_index << " and m_num_bss = " << easyMesh.m_num_bss << std::endl;
    int ret = easyMesh.commit_bss_config(easyMesh, vap_index);
    std::cout << "commit_bss_config returned: " << ret << std::endl;
    ASSERT_EQ(ret, 1);
    std::cout << "Exiting commit_bss_config_valid_non_zero_vap test" << std::endl;
}

/**
 * @brief Test to verify the commit_bss_config function behavior with an out-of-range vap_index.
 *
 * This test ensures that the commit_bss_config function correctly handles the scenario where the vap_index is set to EM_MAX_BSS_PER_RADIO, which is an out-of-range value given the current BSS configuration. By setting the m_num_bss to 1, the test verifies that the function returns false to indicate failure when an invalid vap_index is provided.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 008@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                         | Test Data                                                            | Expected Result                                                 | Notes           |
 * | :--------------: | ------------------------------------------------------------------- | -------------------------------------------------------------------- | --------------------------------------------------------------- | --------------- |
 * | 01               | Set up the easyMesh object with m_num_bss set to 1                    | input: m_num_bss = 1                                                 | easyMesh object is configured with m_num_bss equal to 1            | Should be successful |
 * | 02               | Set vap_index to out-of-range value (EM_MAX_BSS_PER_RADIO)              | input: vap_index = EM_MAX_BSS_PER_RADIO                               | vap_index is set to an out-of-range value relative to m_num_bss       | Should be successful |
 * | 03               | Invoke commit_bss_config API with the configured values               | input: m_num_bss = 1, vap_index = EM_MAX_BSS_PER_RADIO, output: ret value | The API returns false indicating the configuration commit failed | Should Fail     |
 */
TEST(dm_easy_mesh_t, commit_bss_config_out_of_range)
{
    std::cout << "Entering commit_bss_config_out_of_range test" << std::endl;
    dm_easy_mesh_t easyMesh;
    easyMesh.m_num_bss = 1;
    unsigned int vap_index = EM_MAX_BSS_PER_RADIO;
    std::cout << "Invoking commit_bss_config with vap_index = " << vap_index << " and m_num_bss = " << easyMesh.m_num_bss << std::endl;
    int ret = easyMesh.commit_bss_config(easyMesh, vap_index);
    std::cout << "commit_bss_config returned: " << ret << std::endl;
    ASSERT_FALSE(ret);
    std::cout << "Exiting commit_bss_config_out_of_range test" << std::endl;
}

/**
 * @brief Test for verifying that commit_config, when committed with AL target, correctly copies network safe fields and device safe fields.
 *
 * This test verifies that the commit_config method of dm_easy_mesh_t correctly transfers only the pre-determined safe fields from the source object to the destination object when the commit target is set to AL. The test checks that network fields (such as id, number of devices, timestamp, control and colocated agent fields) and device fields (dfs_enable) are correctly copied. This is crucial to ensure that only the intended fields are updated without altering other configuration data.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 009@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize source and destination objects, and populate source with network safe fields and device field | src.m_network.m_net_info.id = "TestNetwork", src.m_network.m_net_info.num_of_devices = 3, src.m_network.m_net_info.timestamp = "2026-01-01T00:00:00Z", src.m_network.m_net_info.ctrl_id.mac = [0x00,0x11,0x22,0x33,0x44,0x55], src.m_network.m_net_info.ctrl_id.name = "ctrl0", src.m_network.m_net_info.colocated_agent_id.mac = [0xAA,0xBB,0xCC,0xDD,0xEE,0xFF], src.m_network.m_net_info.colocated_agent_id.name = "agent0", src.m_device.m_device_info.dfs_enable = 2, dst = default initialized | Source object populated with valid configuration data | Should be successful |
 * | 02 | Invoke commit_config API with commit target set to AL | target.type = em_commit_target_al | API returns 0 indicating success | Should Pass |
 * | 03 | Verify that the network safe fields and device safe fields have been correctly copied to the destination object | Compares dst fields with corresponding src fields (id, num_of_devices, timestamp, ctrl_id, colocated_agent_id, dfs_enable) | All assertions pass confirming fields in dst match those in src | Should Pass |
 */
TEST(dm_easy_mesh_t, commit_config_al_target_copies_network_and_device_safe_fields)
{
    std::cout << "Entering commit_config_al_target_copies_network_and_device_safe_fields test" << std::endl;
    dm_easy_mesh_t src;
    dm_easy_mesh_t dst;
    // Populate only fields known to be copied
    strcpy(src.m_network.m_net_info.id, "TestNetwork");
    src.m_network.m_net_info.num_of_devices = 3;
    strcpy(src.m_network.m_net_info.timestamp, "2026-01-01T00:00:00Z");
    unsigned char ctrl_mac[6] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
    memcpy(src.m_network.m_net_info.ctrl_id.mac, ctrl_mac, sizeof(ctrl_mac));
    strcpy(src.m_network.m_net_info.ctrl_id.name, "ctrl0");
    unsigned char agent_mac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    memcpy(src.m_network.m_net_info.colocated_agent_id.mac, agent_mac, sizeof(agent_mac));
    strcpy(src.m_network.m_net_info.colocated_agent_id.name, "agent0");
    // Device field that is copied by dm_device_t assignment
    src.m_device.m_device_info.dfs_enable = 2;
    em_commit_target_t target{};
    target.type = em_commit_target_al;
    int ret = dst.commit_config(src, target);
    EXPECT_EQ(ret, 0);
    // ---- Network checks (safe fields only) ----
    EXPECT_STREQ(dst.m_network.m_net_info.id, src.m_network.m_net_info.id);
    EXPECT_EQ(dst.m_network.m_net_info.num_of_devices, src.m_network.m_net_info.num_of_devices);
    EXPECT_STREQ(dst.m_network.m_net_info.timestamp, src.m_network.m_net_info.timestamp);
    EXPECT_EQ(memcmp(dst.m_network.m_net_info.ctrl_id.mac, src.m_network.m_net_info.ctrl_id.mac, sizeof(mac_address_t)), 0);
    EXPECT_STREQ(dst.m_network.m_net_info.ctrl_id.name, src.m_network.m_net_info.ctrl_id.name);
    EXPECT_EQ(memcmp(dst.m_network.m_net_info.colocated_agent_id.mac, src.m_network.m_net_info.colocated_agent_id.mac, sizeof(mac_address_t)), 0);
    EXPECT_STREQ(dst.m_network.m_net_info.colocated_agent_id.name, src.m_network.m_net_info.colocated_agent_id.name);
    // ---- Device check ----
    EXPECT_EQ(dst.m_device.m_device_info.dfs_enable, src.m_device.m_device_info.dfs_enable);
    std::cout << "Exiting commit_config_al_target_copies_network_and_device_safe_fields test" << std::endl;
}

/**
 * @brief Test to verify that committing a configuration for an existing radio updates the destination configuration.
 *
 * This test checks that when a radio entry already exists in the source configuration, invoking commit_config on the destination
 * appropriately updates the destination's radio configuration. The test ensures that the commit returns success (0) and that the
 * destination structure has the correct number of radios and that the radio's MAC address matches the source.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 010@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:** 
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize source configuration with one radio having MAC address {0xaa,0xbb,0xcc,0xdd,0xee,0xff} and destination configuration with no radios. | src: m_num_radios = 1, radio[0].m_radio_info.intf.mac = aa:bb:cc:dd:ee:ff; dst: m_num_radios = 0 | Source object is correctly initialized with one radio; destination object is default initialized. | Should be successful |
 * | 02 | Set commit target parameters for the radio using the MAC string "aa:bb:cc:dd:ee:ff". | target.type = em_commit_target_radio, target.params = "aa:bb:cc:dd:ee:ff" | Commit target object is correctly set for a radio update. | Should be successful |
 * | 03 | Invoke commit_config API to update the destination configuration with the source configuration based on the commit target. | Input: src and target; Output: ret from commit_config | commit_config returns 0, indicating success and the destination configuration is updated. | Should Pass |
 * | 04 | Verify that the destination configuration is updated: check that m_num_radios is 1 and the radio MAC address matches the source. | dst: m_num_radios, dst.radio[0].m_radio_info.intf.mac compared against expected MAC {0xaa,0xbb,0xcc,0xdd,0xee,0xff} | The destination configuration has exactly one radio with the matching MAC address; all assertions pass. | Should Pass |
 */
TEST(dm_easy_mesh_t, commit_config_radio_existing_radio_updates)
{
    std::cout << "Entering commit_config_radio_existing_radio_updates test" << std::endl;
    dm_easy_mesh_t src;
    dm_easy_mesh_t dst;
    mac_address_t mac = {0xaa,0xbb,0xcc,0xdd,0xee,0xff};
    dm_radio_t radio;
    memcpy(radio.m_radio_info.intf.mac, mac, sizeof(mac));
    src.m_radio[0] = radio;
    src.m_num_radios = 1;
    char mac_str[] = "aa:bb:cc:dd:ee:ff";
    em_commit_target_t target = {};
    target.type = em_commit_target_radio;
    strcpy(reinterpret_cast<char*>(target.params), mac_str);
    int ret = dst.commit_config(src, target);
    EXPECT_EQ(ret, 0);
    EXPECT_EQ(dst.m_num_radios, 1);
    EXPECT_EQ(memcmp(dst.m_radio[0].m_radio_info.intf.mac, mac, sizeof(mac)), 0);
    std::cout << "Exiting commit_config_radio_existing_radio_updates test" << std::endl;
}

/**
 * @brief Test commit_config_bss_adds_new_bss adds a new BSS configuration
 *
 * This test verifies that the commit_config API correctly copies the BSS configuration from the source object to the destination object when a new BSS is added. It ensures that the BSS, identified by its ruid, is successfully transferred and that the destination object's BSS count is updated. 
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 011@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                                                                                                    | Expected Result                                                                                       | Notes          |
 * | :--------------: | --------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | -------------- |
 * | 01               | Initialize source and destination objects and set up a BSS with specified MAC addresses         | src, dst objects; ruid = {0x11,0x22,0x33,0x44,0x55,0x66}, bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0xff}; src.m_bss[0] set; m_num_bss = 1   | dm_easy_mesh_t objects are initialized and src has one BSS configured                                  | Should be successful |
 * | 02               | Configure the commit target with the stringified ruid and invoke commit_config API              | target.type = em_commit_target_bss, target.params = "11:22:33:44:55:66"                                                       | API returns 0 and dst.m_num_bss is updated to 1                                                       | Should Pass    |
 * | 03               | Verify that the destination object's BSS configuration correctly reflects the source's values  | ret from commit_config; dst.m_num_bss; memcmp comparisons for ruid and bssid                                                   | ret equals 0, dst.m_num_bss equals 1, and both MAC addresses (ruid and bssid) match the expected values | Should Pass    |
 */
TEST(dm_easy_mesh_t, commit_config_bss_adds_new_bss)
{
    std::cout << "Entering commit_config_bss_adds_new_bss test" << std::endl;
    dm_easy_mesh_t src;
    dm_easy_mesh_t dst;
    mac_address_t ruid = {0x11,0x22,0x33,0x44,0x55,0x66};
    mac_address_t bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0xff};
    dm_bss_t bss;
    memcpy(bss.m_bss_info.ruid.mac, ruid, sizeof(ruid));
    memcpy(bss.m_bss_info.bssid.mac, bssid, sizeof(bssid));
    src.m_bss[0] = bss;
    src.m_num_bss = 1;
    char ruid_str[] = "11:22:33:44:55:66";
    em_commit_target_t target = {};
    target.type = em_commit_target_bss;
    strcpy(reinterpret_cast<char*>(target.params), ruid_str);
    int ret = dst.commit_config(src, target);
    EXPECT_EQ(ret, 0);
    EXPECT_EQ(dst.m_num_bss, 1);
    EXPECT_EQ(memcmp(src.m_bss[0].m_bss_info.ruid.mac, ruid, sizeof(ruid)), 0);
    EXPECT_EQ(memcmp(src.m_bss[0].m_bss_info.bssid.mac, bssid, sizeof(bssid)), 0);
    std::cout << "Exiting commit_config_bss_adds_new_bss test" << std::endl;
}

/**
 * @brief Verify that commit_config does not modify destination configuration when an unknown commit target is provided
 *
 * This test passes an unknown commit target to the commit_config() method of the destination object.
 * It verifies that the destination's number of radios and BSS values remain unchanged and that the API returns an error.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 012@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                                                                   | Expected Result                                                                                 | Notes            |
 * | :--------------: | --------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- | ---------------- |
 * | 01               | Initialize source and destination objects and preserve initial configuration | dst.m_num_radios = initial_radios, dst.m_num_bss = initial_bss                                                | Initial configuration values are stored successfully                                           | Should be successful |
 * | 02               | Create an unknown commit target and invoke commit_config on destination         | target.type = 999, target.params_size = 10, target.params = 'B' (filled with 'B')                             | commit_config returns a value <= 0 indicating failure and rejects the invalid target             | Should Fail      |
 * | 03               | Verify that the destination configuration remains unchanged after the API call   | dst.m_num_radios should equal initial_radios, dst.m_num_bss should equal initial_bss                           | Destination configuration remains unchanged                                                      | Should be successful |
 */
TEST(dm_easy_mesh_t, commit_config_unknown_target_no_effect)
{
    std::cout << "Entering commit_config_unknown_target_no_effect test" << std::endl;
    dm_easy_mesh_t src;
    dm_easy_mesh_t dst;
    unsigned int initial_radios = dst.m_num_radios;
    unsigned int initial_bss    = dst.m_num_bss;
    em_commit_target_t target = {};
    target.type = static_cast<em_commit_target_type_t>(999);
    target.params_size = 10;
    memset(target.params, 'B', sizeof(target.params));
    int ret = dst.commit_config(src, target);
    EXPECT_LE(ret, 0);
    EXPECT_EQ(dst.m_num_radios, initial_radios);
    EXPECT_EQ(dst.m_num_bss, initial_bss);
    std::cout << "Exiting commit_config_unknown_target_no_effect test" << std::endl;
}

/**
 * @brief Verifies that commit_config successfully processes a valid command configuration
 *
 * This test initializes a dm_easy_mesh_t object and an em_cmd_t structure with valid parameters, then invokes the commit_config API using the valid command pointer. It verifies that the API returns 0, indicating that the configuration commit was successful.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 013@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                          | Test Data                                                                                                                          | Expected Result                                           | Notes          |
 * | :--------------: | ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------- | -------------- |
 * | 01               | Initialize dm_easy_mesh_t and em_cmd_t objects with valid parameters                                 | mesh_object.m_num_radios = 2, valid_cmd.m_orch_op_idx = 1, valid_cmd.m_type = em_cmd_type_dev_init, valid_cmd.m_orch_desc[1].op = dm_orch_type_em_insert | Test objects are correctly initialized                  | Should be successful |
 * | 02               | Invoke commit_config API with the valid command pointer and check the return value                     | commit_config(&valid_cmd) called with valid_cmd pointer; Expected return value = 0                                                  | commit_config returns 0 indicating successful processing  | Should Pass    |
 */
TEST(dm_easy_mesh_t, commit_config_valid_cmd)
{
    std::cout << "Entering commit_config_valid_cmd test" << std::endl;
    dm_easy_mesh_t mesh_object;
    em_cmd_t valid_cmd;
    valid_cmd.m_orch_op_idx = 1;
    valid_cmd.m_type = em_cmd_type_dev_init;
    mesh_object.m_num_radios = 2;
    valid_cmd.m_orch_desc[valid_cmd.m_orch_op_idx].op = dm_orch_type_em_insert;
    //valid_cmd.m_data_model.m_radio[0] = ;
    std::cout << "Invoking commit_config with valid command pointer" << std::endl;
    int ret = mesh_object.commit_config(&valid_cmd);
    std::cout << "commit_config returned: " << ret << std::endl;
    EXPECT_EQ(ret, 0);
    std::cout << "Exiting commit_config_valid_cmd test" << std::endl;
}

/**
 * @brief Verify commit_config returns error when provided a NULL command pointer.
 *
 * Test commit_config API using a NULL command pointer to ensure that it properly detects invalid input and returns an error code. This test confirms that the function detects the null pointer scenario and handles it correctly.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 014@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create an instance of dm_easy_mesh_t and assign a NULL command pointer | input: null_cmd = NULL, instance object created via dm_easy_mesh_t mesh_object | Instance is created and null_cmd is set to NULL | Should be successful |
 * | 02 | Invoke commit_config with the NULL command pointer | input: call commit_config(NULL) | Return value is -1 and EXPECT_EQ(ret, -1) assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, commit_config_null_cmd)
{
    std::cout << "Entering commit_config_null_cmd test" << std::endl;
    dm_easy_mesh_t mesh_object;
    em_cmd_t *null_cmd = NULL;
    std::cout << "Using NULL command pointer." << std::endl;
    std::cout << "Invoking commit_config with NULL command pointer" << std::endl;
    int ret = mesh_object.commit_config(null_cmd);
    std::cout << "commit_config returned: " << ret << std::endl;
    EXPECT_EQ(ret, -1);
    std::cout << "Exiting commit_config_null_cmd test" << std::endl;
}

/**
 * @brief Tests the create_ap_cap_query_json_cmd function for correct JSON command generation
 *
 * This test verifies that the create_ap_cap_query_json_cmd function correctly creates a JSON command that includes the source MAC address, agent MAC address, and message ID when provided with valid inputs.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 015@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                          | Test Data                                                                                                   | Expected Result                                                                                              | Notes       |
 * | :--------------: | -------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ | ----------- |
 * | 01               | Invoke create_ap_cap_query_json_cmd with valid input parameters       | src_mac_addr = AA:BB:CC:DD:EE:FF, agent_al_mac = 11:22:33:44:55:66, msg_id = 100, output ap_query_json = generated string | The JSON command should include "AA:BB:CC:DD:EE:FF", "11:22:33:44:55:66", and "100", indicating successful API behavior | Should Pass |
 */
TEST(dm_easy_mesh_t, create_ap_cap_query_json_cmd_valid_input) {
    std::cout << "Entering create_ap_cap_query_json_cmd_valid_input test" << std::endl;
    char src_mac_addr[] = "AA:BB:CC:DD:EE:FF";
    char agent_al_mac[] = "11:22:33:44:55:66";
    char ap_query_json[256] = {0};
    short msg_id = 100;    
    std::cout << "Invoking create_ap_cap_query_json_cmd with:" << std::endl;
    std::cout << "src_mac_addr: " << src_mac_addr << std::endl;
    std::cout << "agent_al_mac: " << agent_al_mac << std::endl;
    std::cout << "msg_id: " << msg_id << std::endl;
    dm_easy_mesh_t instance;
    // Invocation of the method
    dm_easy_mesh_t::create_ap_cap_query_json_cmd(src_mac_addr, agent_al_mac, ap_query_json, msg_id);
    std::cout << "Returned ap_query_json: " << ap_query_json << std::endl;
    std::string jsonCmd(ap_query_json);
    // Check that the generated JSON command includes the passed MAC addresses and msg_id.
    EXPECT_NE(jsonCmd.find("AA:BB:CC:DD:EE:FF"), std::string::npos);
    EXPECT_NE(jsonCmd.find("11:22:33:44:55:66"), std::string::npos);
    EXPECT_NE(jsonCmd.find("100"), std::string::npos);
    std::cout << "Exiting create_ap_cap_query_json_cmd_valid_input test" << std::endl;
}

/**
 * @brief Tests create_ap_cap_query_json_cmd with a null source MAC address.
 *
 * This test verifies that create_ap_cap_query_json_cmd correctly handles the scenario where the source MAC address is NULL.
 * It ensures that the function either returns an empty JSON command or a JSON string containing an error message.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 016@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                                                                                  | Expected Result                                                                                           | Notes               |
 * | :--------------: | --------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | ------------------- |
 * | 01               | Initialize test inputs including a NULL src_mac_addr, valid agent_al_mac, an empty ap_query_json, and a msg_id | src_mac_addr = NULL, agent_al_mac = "11:22:33:44:55:66", msg_id = 101, ap_query_json = "zeroed buffer"    | Variables are set up correctly without any initialization errors                                         | Should be successful|
 * | 02               | Invoke create_ap_cap_query_json_cmd with the initialized inputs                                | src_mac_addr = NULL, agent_al_mac = "11:22:33:44:55:66", msg_id = 101, ap_query_json buffer is used for output | The API returns a JSON command that is either empty or contains an error message (e.g., "error")             | Should Fail         |
 * | 03               | Validate the output by checking whether the JSON command is empty or has an error indication       | output: JSON string from ap_query_json                                                                     | The EXPECT_TRUE assertion passes confirming that the result is either an empty string or contains "error"  | Should be successful|
 */
TEST(dm_easy_mesh_t, create_ap_cap_query_json_cmd_null_src_mac_addr) {
    std::cout << "Entering create_ap_cap_query_json_cmd_null_src_mac_addr test" << std::endl;
    char* src_mac_addr = NULL;
    char agent_al_mac[] = "11:22:33:44:55:66";
    char ap_query_json[256] = {0};
    short msg_id = 101;
    std::cout << "Invoking create_ap_cap_query_json_cmd with:" << std::endl;
    std::cout << "src_mac_addr: NULL" << std::endl;
    std::cout << "agent_al_mac: " << agent_al_mac << std::endl;
    std::cout << "msg_id: " << msg_id << std::endl;
    dm_easy_mesh_t instance;
    // Invocation of the method
    EXPECT_ANY_THROW(dm_easy_mesh_t::create_ap_cap_query_json_cmd(src_mac_addr, agent_al_mac, ap_query_json, msg_id));
    std::cout << "Returned ap_query_json: " << ap_query_json << std::endl;
    std::string jsonCmd(ap_query_json);
    bool isEmpty = jsonCmd.empty();
    bool hasError = (jsonCmd.find("error") != std::string::npos || jsonCmd.find("Error") != std::string::npos);
    EXPECT_TRUE(isEmpty || hasError);
    std::cout << "Exiting create_ap_cap_query_json_cmd_null_src_mac_addr test" << std::endl;
}

/**
 * @brief Test create_ap_cap_query_json_cmd behavior with null agent_al_mac
 *
 * Verifies that create_ap_cap_query_json_cmd handles scenarios when agent_al_mac is NULL by returning an error message or an empty JSON. This ensures robustness in input validation and unexpected NULL pointer handling.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 017@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize test variables such as src_mac_addr, agent_al_mac, and msg_id and print initial values | src_mac_addr = AA:BB:CC:DD:EE:FF, agent_al_mac = NULL, msg_id = 102 | Variables initialized correctly | Should be successful |
 * | 02 | Invoke create_ap_cap_query_json_cmd with the initialized parameters | input1 (src_mac_addr) = AA:BB:CC:DD:EE:FF, input2 (agent_al_mac) = NULL, input3 (ap_query_json) = empty array, input4 (msg_id) = 102 | API returns either an error message or empty JSON | Should Pass |
 * | 03 | Verify the output by checking the content of ap_query_json | ap_query_json = output from create_ap_cap_query_json_cmd | EXPECT_TRUE validates that output is empty or contains error text | Should Pass |
 */
TEST(dm_easy_mesh_t, create_ap_cap_query_json_cmd_null_agent_al_mac) {
    std::cout << "Entering create_ap_cap_query_json_cmd_null_agent_al_mac test" << std::endl;
    char src_mac_addr[] = "AA:BB:CC:DD:EE:FF";
    char* agent_al_mac = NULL;
    char ap_query_json[256] = {0};
    short msg_id = 102;    
    std::cout << "Invoking create_ap_cap_query_json_cmd with:" << std::endl;
    std::cout << "src_mac_addr: " << src_mac_addr << std::endl;
    std::cout << "agent_al_mac: NULL" << std::endl;
    std::cout << "msg_id: " << msg_id << std::endl;
    dm_easy_mesh_t instance;
    // Invocation of the method
    EXPECT_ANY_THROW(dm_easy_mesh_t::create_ap_cap_query_json_cmd(src_mac_addr, agent_al_mac, ap_query_json, msg_id));
    std::cout << "Returned ap_query_json: " << ap_query_json << std::endl;
    // Verify the outcome is either an error message or an empty string.
    std::string jsonCmd(ap_query_json);
    bool isEmpty = jsonCmd.empty();
    bool hasError = (jsonCmd.find("error") != std::string::npos || jsonCmd.find("Error") != std::string::npos);
    EXPECT_TRUE(isEmpty || hasError);
    std::cout << "Exiting create_ap_cap_query_json_cmd_null_agent_al_mac test" << std::endl;
}

/**
 * @brief Validate create_ap_cap_query_json_cmd handles null output buffer gracefully
 *
 * This test verifies that the create_ap_cap_query_json_cmd API correctly handles a scenario where the output buffer pointer is NULL. The API is expected to perform appropriate error handling without causing any crashes or undefined behavior.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 018@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                  | Test Data                                                                                                                    | Expected Result                                                                                                                            | Notes       |
 * | :--------------: | -------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | ----------- |
 * | 01               | Call create_ap_cap_query_json_cmd with valid MAC addresses, a NULL output buffer, and a msg_id  | src_mac_addr = AA:BB:CC:DD:EE:FF, agent_al_mac = 11:22:33:44:55:66, ap_query_json = NULL, msg_id = 103                   | The API should detect the NULL output buffer and handle the case gracefully, preventing any crashes and logging or returning an error appropriately  | Should Fail |
 */
TEST(dm_easy_mesh_t, create_ap_cap_query_json_cmd_null_output_buffer) {
    std::cout << "Entering create_ap_cap_query_json_cmd_null_output_buffer test" << std::endl;
    char src_mac_addr[] = "AA:BB:CC:DD:EE:FF";
    char agent_al_mac[] = "11:22:33:44:55:66";
    char* ap_query_json = NULL;
    short msg_id = 103;
    std::cout << "Invoking create_ap_cap_query_json_cmd with:" << std::endl;
    std::cout << "src_mac_addr: " << src_mac_addr << std::endl;
    std::cout << "agent_al_mac: " << agent_al_mac << std::endl;
    std::cout << "ap_query_json: NULL" << std::endl;
    std::cout << "msg_id: " << msg_id << std::endl;
    dm_easy_mesh_t instance;
    EXPECT_ANY_THROW(dm_easy_mesh_t::create_ap_cap_query_json_cmd(src_mac_addr, agent_al_mac, ap_query_json, msg_id));
    std::cout << "Exiting create_ap_cap_query_json_cmd_null_output_buffer test" << std::endl;
}

/**
 * @brief Verify that create_ap_cap_query_json_cmd correctly processes a negative message ID
 *
 * This test verifies that the function create_ap_cap_query_json_cmd correctly integrates a negative message ID (-1) into the generated JSON command. The test initializes the MAC address strings and a negative message ID, invokes the API, and confirms that the output JSON string contains "-1". This ensures that the function handles negative message IDs as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 019@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                              | Test Data                                                                                                      | Expected Result                                                               | Notes            |
 * | :--------------: | ---------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- | ---------------- |
 * | 01               | Initialize test parameters and log the test entry.                                       | src_mac_addr = AA:BB:CC:DD:EE:FF, agent_al_mac = 11:22:33:44:55:66, ap_query_json = buffer of 256 zeros, msg_id = -1 | Parameters initialized and entry log printed.                                 | Should be successful |
 * | 02               | Invoke create_ap_cap_query_json_cmd API with the initialized parameters.                 | src_mac_addr = AA:BB:CC:DD:EE:FF, agent_al_mac = 11:22:33:44:55:66, ap_query_json = buffer for output, msg_id = -1 | The function populates ap_query_json with a JSON command including the negative msg_id (-1). | Should Fail      |
 * | 03               | Verify that the generated JSON command contains the negative message ID "-1".              | jsonCmd = ap_query_json string                                                                              | jsonCmd contains "-1" and the assertion check passes.                       | Should be successful |
 * | 04               | Log the exit message for the test execution.                                             | None                                                                                                           | Exit log printed.                                                             | Should be successful |
 */
TEST(dm_easy_mesh_t, create_ap_cap_query_json_cmd_negative_msg_id) {
    std::cout << "Entering create_ap_cap_query_json_cmd_negative_msg_id test" << std::endl;
    char src_mac_addr[] = "AA:BB:CC:DD:EE:FF";
    char agent_al_mac[] = "11:22:33:44:55:66";
    char ap_query_json[256] = {0};
    short msg_id = -1;    
    std::cout << "Invoking create_ap_cap_query_json_cmd with:" << std::endl;
    std::cout << "src_mac_addr: " << src_mac_addr << std::endl;
    std::cout << "agent_al_mac: " << agent_al_mac << std::endl;
    std::cout << "msg_id: " << msg_id << std::endl;
    dm_easy_mesh_t instance;
    // Invocation of the method
    EXPECT_ANY_THROW(dm_easy_mesh_t::create_ap_cap_query_json_cmd(src_mac_addr, agent_al_mac, ap_query_json, msg_id));
    std::cout << "Returned ap_query_json: " << ap_query_json << std::endl;
    std::string jsonCmd(ap_query_json);
    // Check that the JSON command incorporates the negative msg_id (-1).
    EXPECT_NE(jsonCmd.find("-1"), std::string::npos);
    std::cout << "Exiting create_ap_cap_query_json_cmd_negative_msg_id test" << std::endl;
}

/**
 * @brief Validate that create_autoconfig_renew_json_cmd produces a valid JSON command for autoconfiguration renewal
 *
 * This test verifies that the create_autoconfig_renew_json_cmd API correctly generates a JSON configuration command
 * for various frequency bands. The test checks that the generated JSON is non-empty and includes all the required keys
 * such as "wfa-dataelements:Renew", "ControllerID", "DeviceList", "RadioList", "CurrentOperatingClasses", and the proper MAC addresses.
 * It also validates that the "Class" field in the JSON output matches the expected operating class for each frequency band.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 020@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke create_autoconfig_renew_json_cmd with frequency band 2.4 GHz and verify the JSON output contains required fields and correct operating class | src_mac = "10:11:22:33:44:55", agent_al_mac = "AA:BB:CC:DD:EE:FF", band = em_freq_band_24, expected_op_class = EM_MIN_OP_CLASS_24 | Non-empty JSON string with expected keys and JSON field "Class" equals to EM_MIN_OP_CLASS_24 | Should Pass |
 * | 02 | Invoke create_autoconfig_renew_json_cmd with frequency band 5 GHz and verify the JSON output contains required fields and correct operating class | src_mac = "10:11:22:33:44:55", agent_al_mac = "AA:BB:CC:DD:EE:FF", band = em_freq_band_5, expected_op_class = EM_MIN_OP_CLASS_5 | Non-empty JSON string with expected keys and JSON field "Class" equals to EM_MIN_OP_CLASS_5 | Should Pass |
 * | 03 | Invoke create_autoconfig_renew_json_cmd with frequency band 60 GHz and verify the JSON output contains required fields and correct operating class | src_mac = "10:11:22:33:44:55", agent_al_mac = "AA:BB:CC:DD:EE:FF", band = em_freq_band_60, expected_op_class = EM_MIN_OP_CLASS_6 | Non-empty JSON string with expected keys and JSON field "Class" equals to EM_MIN_OP_CLASS_6 | Should Pass |
 */
TEST(dm_easy_mesh_t, create_autoconfig_renew_json_cmd_valid_inputs_loop)
{
    const char* testName = "create_autoconfig_renew_json_cmd_valid_inputs_loop";
    std::cout << "Entering " << testName << " test" << std::endl;
    char src_mac[] = "10:11:22:33:44:55";
    char agent_al_mac[] = "AA:BB:CC:DD:EE:FF";
    struct {
        em_freq_band_t band;
        int expected_op_class;
    } testCases[] = {
        { em_freq_band_24, EM_MIN_OP_CLASS_24 },
        { em_freq_band_5,  EM_MIN_OP_CLASS_5  },
        { em_freq_band_60, EM_MIN_OP_CLASS_6  }
    };
    for (const auto& tc : testCases) {
        char autoconfig_renew_json[1024] = {0};
        dm_easy_mesh_t::create_autoconfig_renew_json_cmd(src_mac, agent_al_mac, tc.band, autoconfig_renew_json);
        std::string json(autoconfig_renew_json);
        std::cout << "Generated JSON for band " << tc.band << ":\n" << json << std::endl;
        EXPECT_FALSE(json.empty());
        EXPECT_NE(json.find("wfa-dataelements:Renew"), std::string::npos);
        EXPECT_NE(json.find("ControllerID"), std::string::npos);
        EXPECT_NE(json.find("DeviceList"), std::string::npos);
        EXPECT_NE(json.find("RadioList"), std::string::npos);
        EXPECT_NE(json.find("CurrentOperatingClasses"), std::string::npos);
        EXPECT_NE(json.find(src_mac), std::string::npos);
        EXPECT_NE(json.find(agent_al_mac), std::string::npos);
        // Flexible check for "Class": number
        std::string classStr = "\"Class\":";
        size_t pos = json.find(classStr);
        ASSERT_NE(pos, std::string::npos); // fail early if not found
        // Extract number after "Class":
        size_t start = pos + classStr.size();
        while (start < json.size() && isspace(json[start])) start++;
        size_t end = start;
        while (end < json.size() && isdigit(json[end])) end++;
        int classValue = std::stoi(json.substr(start, end - start));
        EXPECT_EQ(classValue, tc.expected_op_class);
    }
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that create_autoconfig_renew_json_cmd correctly handles a null source MAC address.
 *
 * This test validates the API's behavior when a NULL pointer is passed as src_mac. The function is expected
 * to gracefully handle the error scenario by not generating a valid autoconfig renewal JSON command and possibly
 * setting an error or empty output. This helps ensure robustness in input validation.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 021@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                          | Test Data                                                                                   | Expected Result                                                                                       | Notes        |
 * | :--------------: | -------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | ------------ |
 * | 01               | Invoke create_autoconfig_renew_json_cmd with a NULL src_mac parameter  | src_mac = NULL, agent_al_mac = AA:BB:CC:DD:EE:FF, freq_band = em_freq_band_24, autoconfig_renew_json = char[1024] initialized to 0 | The function should handle the null src_mac appropriately, e.g., not generate a valid JSON command | Should Fail  |
 */
TEST(dm_easy_mesh_t, create_autoconfig_renew_json_cmd_null_src_mac)
{
    const char* testName = "create_autoconfig_renew_json_cmd_null_src_mac";
    std::cout << "Entering " << testName << " test" << std::endl;
    char* src_mac = NULL;
	char agent_al_mac[] = "AA:BB:CC:DD:EE:FF";    
    char autoconfig_renew_json[1024] = {0};
    std::cout << "Invoking create_autoconfig_renew_json_cmd with:" << std::endl;
    std::cout << "  src_mac_addr: " << "NULL" << std::endl;
    std::cout << "  agent_al_mac: " << agent_al_mac << std::endl;
    std::cout << "  freq_band: " << em_freq_band_24 << std::endl;
    std::cout << "  Output buffer address: " << static_cast<void*>(autoconfig_renew_json) << std::endl;
    // Invoke the method.
    EXPECT_ANY_THROW(dm_easy_mesh_t::create_autoconfig_renew_json_cmd(src_mac, agent_al_mac, em_freq_band_24, autoconfig_renew_json));
    std::cout << "Returned autoconfig_renew_json: " << autoconfig_renew_json << std::endl;
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Unit test to validate create_autoconfig_renew_json_cmd handles NULL agent_al_mac
 *
 * This test verifies that the create_autoconfig_renew_json_cmd method of dm_easy_mesh_t correctly processes a NULL agent_al_mac parameter. It ensures that the function does not crash and properly fills the autoconfig_renew_json output buffer even when agent_al_mac is NULL.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 022@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data |Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke create_autoconfig_renew_json_cmd with src_mac set to "00:11:22:33:44:55", agent_al_mac as NULL, freq_band as em_freq_band_5, and an autoconfig_renew_json buffer initialized to zeros | src_mac = "00:11:22:33:44:55", agent_al_mac = NULL, freq_band = em_freq_band_5, autoconfig_renew_json = buffer[1024] (all zeros) | The autoconfig_renew_json buffer is correctly updated with the expected JSON command and no crash occurs | Should Pass |
 */
TEST(dm_easy_mesh_t, create_autoconfig_renew_json_cmd_null_agent_al_mac)
{
    const char* testName = "create_autoconfig_renew_json_cmd_null_agent_al_mac";
    std::cout << "Entering " << testName << " test" << std::endl;
    char src_mac[] = "00:11:22:33:44:55";
    char* agent_al_mac = NULL;
    char autoconfig_renew_json[1024] = {0};
    std::cout << "Invoking create_autoconfig_renew_json_cmd with:" << std::endl;
    std::cout << "  src_mac_addr: " << src_mac << std::endl;
    std::cout << "  agent_al_mac: " << "NULL" << std::endl;
    std::cout << "  freq_band: " << em_freq_band_5 << std::endl;
    std::cout << "  Output buffer address: " << static_cast<void*>(autoconfig_renew_json) << std::endl;
    // Invoke the method.
    EXPECT_ANY_THROW(dm_easy_mesh_t::create_autoconfig_renew_json_cmd(src_mac, agent_al_mac, em_freq_band_5, autoconfig_renew_json));
    std::cout << "Returned autoconfig_renew_json: " << autoconfig_renew_json << std::endl;
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test the create_autoconfig_renew_json_cmd function with a NULL output buffer
 *
 * This test verifies that the create_autoconfig_renew_json_cmd() API gracefully handles
 * a scenario where the output buffer provided is NULL. The function is expected not to crash
 * or produce undefined behavior when a NULL pointer is passed for the output buffer.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 023@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                     | Test Data                                                                                                  | Expected Result                                                               | Notes            |
 * | :--------------: | ----------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- | ---------------: |
 * | 01               | Initialize test variables and log the entry of the test                                         | testName = "create_autoconfig_renew_json_cmd_null_output_buffer"                                             | Variables are correctly initialized and log indicates the test start          | Should be successful |
 * | 02               | Invoke create_autoconfig_renew_json_cmd with valid src_mac, agent_al_mac, freq_band and NULL output | src_mac = "00:11:22:33:44:55", agent_al_mac = "AA:BB:CC:DD:EE:FF", freq_band = em_freq_band_60, autoconfig_renew_json = NULL | The API should handle the NULL output buffer gracefully without crashing      | Should Pass      |
 * | 03               | Log the exit of the test                                                                        | None                                                                                                         | Log indicates the test has been exited successfully                           | Should be successful |
 */
TEST(dm_easy_mesh_t, create_autoconfig_renew_json_cmd_null_output_buffer)
{
    const char* testName = "create_autoconfig_renew_json_cmd_null_output_buffer";
    std::cout << "Entering " << testName << " test" << std::endl;
    char src_mac[] = "00:11:22:33:44:55";
    char agent_al_mac[] = "AA:BB:CC:DD:EE:FF";
    char* autoconfig_renew_json = NULL;
    std::cout << "Invoking create_autoconfig_renew_json_cmd with:" << std::endl;
    std::cout << "  src_mac_addr: " << src_mac << std::endl;
    std::cout << "  agent_al_mac: " << agent_al_mac << std::endl;
    std::cout << "  freq_band: " << em_freq_band_60 << std::endl;
    std::cout << "  Output buffer: " << "NULL" << std::endl;
    // Invoke the method. Expect that it handles the NULL output buffer gracefully.
    EXPECT_ANY_THROW(dm_easy_mesh_t::create_autoconfig_renew_json_cmd(src_mac, agent_al_mac, em_freq_band_60, autoconfig_renew_json));
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Tests the creation of a client capability query JSON command
 *
 * This test verifies that the function dm_easy_mesh_t::create_client_cap_query_json_cmd 
 * correctly generates a JSON string when provided with valid input parameters. It checks for 
 * the presence of specific required substrings such as "wfa-dataelements:Clientcap", "OneWifiMesh", 
 * the input MAC addresses, and "DeviceList", and confirms that the message ID embedded in the JSON 
 * matches the provided value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 024@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize input parameters and invoke create_client_cap_query_json_cmd API. | src_mac_addr = "AA:BB:CC:DD:EE:FF", agent_al_mac = "11:22:33:44:55:66", ap_query_json = empty buffer, msg_id = 100, mac = "77:88:99:AA:BB:CC" | API generates a JSON formatted string in ap_query_json. | Should Pass |
 * | 02 | Verify that the generated JSON string contains expected keywords and MAC addresses. | JSON string containing "wfa-dataelements:Clientcap", "OneWifiMesh", "AA:BB:CC:DD:EE:FF", "11:22:33:44:55:66", "77:88:99:AA:BB:CC", and "DeviceList" | Each specified substring is found in the JSON output. | Should Pass |
 * | 03 | Extract and validate the MsgID value from the JSON string. | JSON string with key "MsgID": and value 100 | Extracted MsgID equals the input msg_id (100). | Should Pass |
 */
TEST(dm_easy_mesh_t, create_client_cap_query_json_cmd_valid_input)
{
    const char* testName = "create_client_cap_query_json_cmd_valid_input";
    std::cout << "Entering " << testName << " test" << std::endl;
    char src_mac_addr[] = "AA:BB:CC:DD:EE:FF";
    char agent_al_mac[] = "11:22:33:44:55:66";
    char ap_query_json[512] = {};
    short msg_id = 100;
    char mac[] = "77:88:99:AA:BB:CC";
    dm_easy_mesh_t obj;
    dm_easy_mesh_t::create_client_cap_query_json_cmd(src_mac_addr, agent_al_mac, ap_query_json, msg_id, mac);
    std::cout << "Generated JSON:\n" << ap_query_json << std::endl;
    std::string json(ap_query_json);
    EXPECT_NE(json.find("wfa-dataelements:Clientcap"), std::string::npos);
    EXPECT_NE(json.find("OneWifiMesh"), std::string::npos);
    EXPECT_NE(json.find(src_mac_addr), std::string::npos);
    EXPECT_NE(json.find(agent_al_mac), std::string::npos);
    EXPECT_NE(json.find(mac), std::string::npos);
    EXPECT_NE(json.find("DeviceList"), std::string::npos);
    // Flexible MsgID check
    std::string key = "\"MsgID\":";
    size_t pos = json.find(key);
    ASSERT_NE(pos, std::string::npos);
    size_t start = pos + key.size();
    while (start < json.size() && isspace(json[start])) start++;
    size_t end = start;
    while (end < json.size() && isdigit(json[end])) end++;
    int msg_id_value = std::stoi(json.substr(start, end - start));
    EXPECT_EQ(msg_id_value, msg_id);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test that create_client_cap_query_json_cmd does not modify the output JSON buffer when src_mac_addr is NULL
 *
 * This test verifies that if the source MAC address (src_mac_addr) is provided as NULL, the function create_client_cap_query_json_cmd
 * will not alter the initial contents of the ap_query_json buffer. This behavior is important to ensure that error conditions are
 * handled gracefully without unintended modifications.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 025@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Prepare test inputs: initialize variables with NULL src_mac_addr and valid other parameters | src_mac_addr = NULL, agent_al_mac = "11:22:33:44:55:66", ap_query_json = "initial", msg_id = 50, mac = "77:88:99:AA:BB:CC" | All inputs are correctly set up for testing invalid src_mac_addr | Should be successful |
 * | 02 | Invoke create_client_cap_query_json_cmd API with the prepared inputs and verify if null input is handled | src_mac_addr = NULL, agent_al_mac = "11:22:33:44:55:66", ap_query_json = "initial", msg_id = 50, mac = "77:88:99:AA:BB:CC" | The API should detect the NULL src_mac_addr and leave ap_query_json unchanged | Should Pass |
 */
TEST(dm_easy_mesh_t, create_client_cap_query_json_cmd_null_src_mac) {
    const char* testName = "create_client_cap_query_json_cmd_null_src_mac";
    std::cout << "Entering " << testName << " test" << std::endl;
    // Prepare inputs
    char* src_mac_addr = NULL;
    char agent_al_mac[] = "11:22:33:44:55:66";
    char ap_query_json[256] = "initial";
    short msg_id = 50;
    char mac[] = "77:88:99:AA:BB:CC";
    std::cout << "Invoking create_client_cap_query_json_cmd with NULL src_mac_addr" << std::endl;
    std::cout << "  agent_al_mac: " << agent_al_mac << std::endl;
    std::cout << "  msg_id: " << msg_id << std::endl;
    std::cout << "  mac: " << mac << std::endl;
    dm_easy_mesh_t obj;
    EXPECT_ANY_THROW(dm_easy_mesh_t::create_client_cap_query_json_cmd(src_mac_addr, agent_al_mac, ap_query_json, msg_id, mac));
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that create_client_cap_query_json_cmd does not modify the output JSON buffer when agent_al_mac is NULL
 *
 * This test checks that when a NULL pointer is passed as agent_al_mac to create_client_cap_query_json_cmd,
 * the function's error handling mechanisms prevent any modification to the output JSON buffer. This ensures
 * the robustness of the API in handling invalid inputs.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 026@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Prepare input values for the test including src_mac_addr, agent_al_mac as NULL, ap_query_json buffer, msg_id, and mac address | src_mac_addr = "AA:BB:CC:DD:EE:FF", agent_al_mac = NULL, ap_query_json = "initial", msg_id = 60, mac = "77:88:99:AA:BB:CC" | Inputs are correctly initialized | Should be successful |
 * | 02 | Invoke create_client_cap_query_json_cmd with the prepared inputs to test its behavior with a NULL agent_al_mac and verify if null input is handled | src_mac_addr = "AA:BB:CC:DD:EE:FF", agent_al_mac = NULL, ap_query_json = "initial", msg_id = 60, mac = "77:88:99:AA:BB:CC" | API is executed and the JSON command buffer remains unchanged ("initial") | Should Pass |
 */
TEST(dm_easy_mesh_t, create_client_cap_query_json_cmd_null_agent_al_mac) {
    const char* testName = "create_client_cap_query_json_cmd_null_agent_al_mac";
    std::cout << "Entering " << testName << " test" << std::endl;
    // Prepare inputs
    char src_mac_addr[] = "AA:BB:CC:DD:EE:FF";
    char* agent_al_mac = NULL;
    char ap_query_json[256] = "initial";
    short msg_id = 60;
    char mac[] = "77:88:99:AA:BB:CC";
    std::cout << "Invoking create_client_cap_query_json_cmd with NULL agent_al_mac" << std::endl;
    std::cout << "  src_mac_addr: " << src_mac_addr << std::endl;
    std::cout << "  msg_id: " << msg_id << std::endl;
    std::cout << "  mac: " << mac << std::endl;
    dm_easy_mesh_t obj;
    EXPECT_ANY_THROW(dm_easy_mesh_t::create_client_cap_query_json_cmd(src_mac_addr, agent_al_mac, ap_query_json, msg_id, mac));
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that the client capability query JSON command is created correctly when the device MAC is null
 *
 * This test validates that the function create_client_cap_query_json_cmd correctly constructs a JSON command string when provided with valid source MAC, agent AL MAC, message ID, and a null device MAC pointer. The test ensures that the output JSON string contains the expected client capability identification string and source values, and it omits the "ClientMac" entry.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 027@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Call create_client_cap_query_json_cmd with valid src_mac_addr ("AA:BB:CC:DD:EE:FF"), valid agent_al_mac ("11:22:33:44:55:66"), a zero-initialized JSON buffer (512 bytes), msg_id (70), and a null device MAC pointer | src_mac_addr = AA:BB:CC:DD:EE:FF, agent_al_mac = 11:22:33:44:55:66, ap_query_json = buffer[512] initialized to 0, msg_id = 70, mac = nullptr | The resulting JSON string contains "wfa-dataelements:Clientcap", includes the src_mac_addr, agent_al_mac, and the correct msg_id, and does not include "ClientMac"; assertions should pass | Should Pass |
 */
TEST(dm_easy_mesh_t, create_client_cap_query_json_cmd_null_device_mac)
{
    const char* testName = "create_client_cap_query_json_cmd_null_device_mac";
    std::cout << "Entering " << testName << " test" << std::endl;
    char src_mac_addr[] = "AA:BB:CC:DD:EE:FF";
    char agent_al_mac[] = "11:22:33:44:55:66";
    char ap_query_json[512] = {0};
    short msg_id = 70;
    char* mac = nullptr;
    EXPECT_ANY_THROW(dm_easy_mesh_t::create_client_cap_query_json_cmd(src_mac_addr, agent_al_mac, ap_query_json, msg_id, mac));
    std::string json(ap_query_json);
    EXPECT_FALSE(json.empty());
    EXPECT_NE(json.find("wfa-dataelements:Clientcap"), std::string::npos);
    EXPECT_NE(json.find(src_mac_addr), std::string::npos);
    EXPECT_NE(json.find(agent_al_mac), std::string::npos);
    EXPECT_NE(json.find("\"MsgID\":\t70"), std::string::npos);
    EXPECT_EQ(json.find("ClientMac"), std::string::npos);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that create_client_cap_query_json_cmd handles a NULL output buffer gracefully.
 *
 * This test validates that the create_client_cap_query_json_cmd API can be invoked with a NULL output buffer.
 * It ensures that the function does not crash or produce undefined behavior when provided with a NULL pointer for the output.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 028@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                          | Test Data                                                                                                                       | Expected Result                                                                                       | Notes      |
 * | :--------------: | ---------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | ---------- |
 * | 01               | Initialize test variables and invoke create_client_cap_query_json_cmd with a NULL output buffer.     | src_mac_addr = "AA:BB:CC:DD:EE:FF", agent_al_mac = "11:22:33:44:55:66", ap_query_json = NULL, msg_id = 80, mac = "77:88:99:AA:BB:CC" | The API should handle the NULL output buffer gracefully without crashing or producing errors. | Should Pass |
 */
TEST(dm_easy_mesh_t, create_client_cap_query_json_cmd_null_output_buffer) {
    const char* testName = "create_client_cap_query_json_cmd_null_output_buffer";
    std::cout << "Entering " << testName << " test" << std::endl;
    // Prepare inputs
    char src_mac_addr[] = "AA:BB:CC:DD:EE:FF";
    char agent_al_mac[] = "11:22:33:44:55:66";
    char* ap_query_json = NULL;
    short msg_id = 80;
    char mac[] = "77:88:99:AA:BB:CC";
    std::cout << "Invoking create_client_cap_query_json_cmd with NULL output buffer (ap_query_json)" << std::endl;
    std::cout << "  src_mac_addr: " << src_mac_addr << std::endl;
    std::cout << "  agent_al_mac: " << agent_al_mac << std::endl;
    std::cout << "  msg_id: " << msg_id << std::endl;
    std::cout << "  mac: " << mac << std::endl;
    // Ensure that the function handles the NULL output buffer gracefully.
    EXPECT_ANY_THROW(dm_easy_mesh_t::create_client_cap_query_json_cmd(src_mac_addr, agent_al_mac, ap_query_json, msg_id, mac));
    std::cout << "Method invoked with NULL output buffer; no output to display." << std::endl;
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that create_client_cap_query_json_cmd processes negative message IDs correctly
 *
 * This test verifies that when a negative message ID is provided, the function create_client_cap_query_json_cmd correctly constructs a JSON command that includes the negative MsgID and the correct ClientMac value. The test inspects the generated JSON to ensure that all expected fields are present and contain appropriate values.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 029@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                     | Test Data                                                                                                                          | Expected Result                                                                                | Notes         |
 * | :--------------: | ----------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ------------- |
 * | 01               | Invoke create_client_cap_query_json_cmd with a negative msg_id and verify the JSON content fields | src_mac_addr = AA:BB:CC:DD:EE:FF, agent_al_mac = 11:22:33:44:55:66, ap_query_json = [512 bytes buffer zeroed], msg_id = -1, mac = 77:88:99:AA:BB:CC | JSON contains "MsgID" with value -1 and "ClientMac" with value "77:88:99:AA:BB:CC" and all fields are valid | Should Pass   |
 */
TEST(dm_easy_mesh_t, create_client_cap_query_json_cmd_negative_msg_id)
{
    std::cout << "Entering create_client_cap_query_json_cmd_negative_msg_id test" << std::endl;
    dm_easy_mesh_t obj;
    char src_mac_addr[] = "AA:BB:CC:DD:EE:FF";
    char agent_al_mac[] = "11:22:33:44:55:66";
    char ap_query_json[512] = {};
    short msg_id = -1;
    char mac[] = "77:88:99:AA:BB:CC";
    EXPECT_ANY_THROW(dm_easy_mesh_t::create_client_cap_query_json_cmd(src_mac_addr, agent_al_mac, ap_query_json, msg_id, mac));
    cJSON* root = cJSON_Parse(ap_query_json);
    ASSERT_NE(root, nullptr);
    cJSON* cap = cJSON_GetObjectItem(root, "wfa-dataelements:Clientcap");
    ASSERT_NE(cap, nullptr);
    cJSON* msg = cJSON_GetObjectItem(cap, "MsgID");
    ASSERT_NE(msg, nullptr);
    EXPECT_EQ(msg->valueint, -1);
    cJSON* client = cJSON_GetObjectItem(cap, "ClientMac");
    ASSERT_NE(client, nullptr);
    EXPECT_STREQ(client->valuestring, mac);
    cJSON_Delete(root);
    std::cout << "Exiting create_client_cap_query_json_cmd_negative_msg_id test" << std::endl;
}

/**
 * @brief Test creation of a new scan result with a valid scan result identifier
 *
 * This test verifies that a new scan result is correctly created when provided with a valid scan result identifier.
 * The identifier includes a valid network ID, properly formatted binary MAC addresses, operation class, channel,
 * and scanner type. The test asserts that the mesh is initialized successfully and that the created scan result
 * reflects the input parameters.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 030@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                 | Test Data                                                                                                                                                                                 | Expected Result                                          | Notes          |
 * | :--------------: | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------- | -------------- |
 * | 01               | Print entering test message                                                                 | None                                                                                                                                                                                     | "Entering create_new_scan_result_valid_scan_result_id test" printed | Should be successful |
 * | 02               | Setup valid scan result identifier with required parameters                                 | valid_id.net_id = TestNetId, valid_id.dev_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF}, valid_id.scanner_mac = {0x11,0x22,0x33,0x44,0x55,0x66}, valid_id.op_class = 5, valid_id.channel = 6, valid_id.scanner_type = em_scanner_type_radio | valid_id structure correctly populated                  | Should be successful |
 * | 03               | Initialize the mesh object                                                                    | dm_easy_mesh_t mesh; mesh.init()                                                                                                                    | mesh.init() returns 0                                   | Should Pass    |
 * | 04               | Invoke create_new_scan_result API with the valid identifier                                   | input: pointer to valid_id, output: result pointer                                                                                                                                        | result is not nullptr                                   | Should Pass    |
 * | 05               | Retrieve scan result from created result via get_scan_result                                  | result->get_scan_result() returned value assigned to scan pointer                                                                                                                          | scan is not nullptr                                     | Should Pass    |
 * | 06               | Validate scan result fields against the input values                                          | scan->id.net_id = TestNetId, scan->id.op_class = 5, scan->id.channel = 6, scan->id.scanner_type = em_scanner_type_radio                                                                          | Returned scan result fields match the corresponding input values | Should Pass    |
 * | 07               | Print exiting test message                                                                    | None                                                                                                                                                                                     | "Exiting create_new_scan_result_valid_scan_result_id test" printed | Should be successful |
 */
TEST(dm_easy_mesh_t, create_new_scan_result_valid_scan_result_id)
{
    std::cout << "Entering create_new_scan_result_valid_scan_result_id test" << std::endl;
    em_scan_result_id_t valid_id = {};
    std::strcpy(valid_id.net_id, "TestNetId");
    // Proper binary MAC addresses
    uint8_t dev_mac[]     = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    uint8_t scanner_mac[] = {0x11,0x22,0x33,0x44,0x55,0x66};
    memcpy(valid_id.dev_mac, dev_mac, sizeof(dev_mac));
    memcpy(valid_id.scanner_mac, scanner_mac, sizeof(scanner_mac));
    valid_id.op_class     = 5;
    valid_id.channel      = 6;
    valid_id.scanner_type = em_scanner_type_radio;
    dm_easy_mesh_t mesh;
    ASSERT_EQ(mesh.init(), 0);
    dm_scan_result_t *result = mesh.create_new_scan_result(&valid_id);
    ASSERT_NE(result, nullptr);
    em_scan_result_t *scan = result->get_scan_result();
    ASSERT_NE(scan, nullptr);
    EXPECT_STREQ(scan->id.net_id, valid_id.net_id);
    EXPECT_EQ(scan->id.op_class, valid_id.op_class);
    EXPECT_EQ(scan->id.channel, valid_id.channel);
    EXPECT_EQ(scan->id.scanner_type, valid_id.scanner_type);
    mesh.deinit();
    std::cout << "Exiting create_new_scan_result_valid_scan_result_id test" << std::endl;
}

/**
 * @brief Validate creation of a new scan result using different scanner type enumeration values
 *
 * This test verifies that the API correctly handles the creation of a new scan result by
 * iterating through different valid scanner type enumeration values (em_scanner_type_radio and em_scanner_type_sta).
 * It checks that the created scan result is not a nullptr and that the scanner type in the scan result matches
 * the expected type. This is important to ensure that the API correctly interprets the enumeration and returns
 * a valid scan structure for further processing.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 031@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                                                                                                                                                             | Expected Result                                                                    | Notes       |
 * | :--------------: | --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- | ----------- |
 * | 01               | Initialize dm_easy_mesh_t instance, set valid id parameters, and invoke create_new_scan_result    | net_id = EnumTestNet, dev_mac = 0xAA,0xAA,0xAA,0xAA,0xAA,0xAA, scanner_mac = 0xBB,0xBB,0xBB,0xBB,0xBB,0xBB, op_class = 3, channel = 11, scanner_type = em_scanner_type_radio/em_scanner_type_sta | Returned scan result pointer is valid and its scanner_type matches input value       | Should Pass |
 */
TEST(dm_easy_mesh_t, create_new_scan_result_enum_variations)
{
    std::cout << "Entering create_new_scan_result_enum_variations test" << std::endl;
    em_scanner_type_t scanner_types[] = {
        em_scanner_type_radio,
        em_scanner_type_sta
    };
    for (auto type : scanner_types) {
        em_scan_result_id_t valid_id = {};
        std::strcpy(valid_id.net_id, "EnumTestNet");
        uint8_t dev_mac[]     = {0xAA,0xAA,0xAA,0xAA,0xAA,0xAA};
        uint8_t scanner_mac[] = {0xBB,0xBB,0xBB,0xBB,0xBB,0xBB};
        memcpy(valid_id.dev_mac, dev_mac, sizeof(dev_mac));
        memcpy(valid_id.scanner_mac, scanner_mac, sizeof(scanner_mac));
        valid_id.op_class     = 3;
        valid_id.channel      = 11;
        valid_id.scanner_type = type;
        dm_easy_mesh_t mesh;
        ASSERT_EQ(mesh.init(), 0);
        dm_scan_result_t *result = mesh.create_new_scan_result(&valid_id);
        ASSERT_NE(result, nullptr);
        em_scan_result_t *scan = result->get_scan_result();
        ASSERT_NE(scan, nullptr);
        EXPECT_EQ(scan->id.scanner_type, type);
        mesh.deinit();
    }
    std::cout << "Exiting create_new_scan_result_enum_variations test" << std::endl;
}

/**
 * @brief Verify that create_new_scan_result returns nullptr when a NULL pointer is provided
 *
 * This test verifies that invoking the create_new_scan_result API on a dm_easy_mesh_t object with a NULL pointer as argument returns a nullptr. This ensures that the function handles null inputs safely and as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 032@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                         | Test Data                                         | Expected Result                                        | Notes          |
 * | :--------------: | ------------------------------------------------------------------- | ------------------------------------------------- | ------------------------------------------------------ | -------------- |
 * | 01               | Create an instance of dm_easy_mesh_t                                | No input parameters                               | Instance is successfully created                       | Should be successful |
 * | 02               | Invoke create_new_scan_result with a NULL pointer                   | input: scan_result_id = nullptr                   | API returns a nullptr                                  | Should Pass    |
 * | 03               | Verify that the returned result is nullptr using EXPECT_EQ assertion | output: result, expected value = nullptr          | EXPECT_EQ(result, nullptr) passes the check            | Should be successful |
 */
TEST(dm_easy_mesh_t, create_new_scan_result_null_scan_result_id)
{
    std::cout << "Entering create_new_scan_result_null_scan_result_id test" << std::endl;
    dm_easy_mesh_t mesh;
    std::cout << "Invoking create_new_scan_result with NULL pointer" << std::endl;
    dm_scan_result_t *result = mesh.create_new_scan_result(nullptr);
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting create_new_scan_result_null_scan_result_id test" << std::endl;
}

/**
 * @brief Verify that after setting a database configuration parameter, the criteria returned matches the set value.
 *
 * This test initializes the dm_easy_mesh_t object, sets a configuration parameter using set_db_cfg_param, and then retrieves the criteria for that parameter using db_cfg_type_get_criteria. The test ensures that the criteria is not null and that it exactly matches the expected string "radio_update".
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 033@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize the dm_easy_mesh_t object by invoking init() | No input, output: init() return value = 0 | init() returns 0 | Should Pass |
 * | 02 | Set the database configuration parameter using set_db_cfg_param() | input: db_cfg_param = db_cfg_type_radio_list_update, value = "radio_update" | Parameter is set successfully | Should Pass |
 * | 03 | Retrieve the criteria for the configuration parameter with db_cfg_type_get_criteria() | input: db_cfg_param = db_cfg_type_radio_list_update, output: criteria expected = "radio_update" | Return value is not null and equals "radio_update" | Should Pass |
 */
TEST(dm_easy_mesh_t, db_cfg_type_get_criteria_AfterSet_ReturnsCriteria)
{
    dm_easy_mesh_t obj;
    ASSERT_EQ(obj.init(), 0);
    obj.set_db_cfg_param(db_cfg_type_radio_list_update, "radio_update");
    char* criteria = obj.db_cfg_type_get_criteria(db_cfg_type_radio_list_update);
    ASSERT_NE(criteria, nullptr);
    obj.deinit();
    EXPECT_STREQ(criteria, "radio_update");
}

/**
 * @brief Verify that db_cfg_type_get_criteria handles invalid enumeration types correctly
 *
 * This test verifies that when an invalid db_cfg_type_t value (i.e., -1) is passed to 
 * db_cfg_type_get_criteria, the function returns a nullptr. This behavior confirms that 
 * the API correctly handles erroneous input by preventing unintended operations.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 034@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                      | Test Data                                                 | Expected Result                                                                     | Notes            |
 * | :--------------: | ------------------------------------------------------------------------------------------------ | --------------------------------------------------------- | ------------------------------------------------------------------------------------ | ---------------- |
 * | 01               | Print entering test log and create dm_easy_mesh_t object                                          | None                                                      | "Entering db_cfg_type_get_criteria_InvalidEnumTypeNegativeTest test" printed; object created | Should be successful |
 * | 02               | Construct an invalid db_cfg_type_t enumeration value and print the invocation message             | invalidType = -1                                          | "Invoking db_cfg_type_get_criteria with invalid type (negative value): -1" printed       | Should be successful |
 * | 03               | Call db_cfg_type_get_criteria with the invalid enumeration value and verify the return value        | invalidType = -1, criteria = expected to be nullptr       | API returns nullptr and EXPECT_EQ verifies that criteria is nullptr                   | Should Fail      |
 * | 04               | Print exiting test log                                                                            | None                                                      | "Exiting db_cfg_type_get_criteria_InvalidEnumTypeNegativeTest test" printed             | Should be successful |
 */
TEST(dm_easy_mesh_t, db_cfg_type_get_criteria_InvalidEnumTypeNegativeTest)
{
    std::cout << "Entering db_cfg_type_get_criteria_InvalidEnumTypeNegativeTest test" << std::endl;

    dm_easy_mesh_t obj;
    db_cfg_type_t invalidType = static_cast<db_cfg_type_t>(-1);
    std::cout << "Invoking db_cfg_type_get_criteria with invalid type (negative value): " << invalidType << std::endl;
    char *criteria = obj.db_cfg_type_get_criteria(invalidType);    
    EXPECT_EQ(criteria, nullptr);
    std::cout << "Exiting db_cfg_type_get_criteria_InvalidEnumTypeNegativeTest test" << std::endl;
}

/**
 * @brief Verify that the database configuration type is correctly set when initialized with a valid value.
 *
 * This test verifies that after initializing the dm_easy_mesh_t object, setting the parameter 
 * m_db_cfg_param.db_cfg_type to a positive value (5) allows the db_cfg_type_is_set() function 
 * to return true. This confirms that the database configuration type is properly established.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 035@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                           | Test Data                                                  | Expected Result                                                | Notes         |
 * | :--------------: | ------------------------------------------------------------------------------------- | ---------------------------------------------------------- | --------------------------------------------------------------- | ------------- |
 * | 01               | Initialize the dm_easy_mesh_t object and verify initialization returns 0              | obj.init() = 0                                             | init() returns 0                                               | Should Pass   |
 * | 02               | Set the m_db_cfg_param.db_cfg_type to a valid value (5)                               | m_db_cfg_param.db_cfg_type = 5                             | Parameter value updated to 5                                   | Should be successful |
 * | 03               | Invoke the db_cfg_type_is_set() to check if the configuration type is set             | call db_cfg_type_is_set()                                  | Return value is true indicating configuration is set           | Should Pass   |
 * | 04               | Assert that the db_cfg_type_is_set() returns true                                     | db_cfg_type_is_set() = true                                | Assertion passes confirming expected behavior                  | Should Pass   |
 */
TEST(dm_easy_mesh_t, db_cfg_type_is_set_database_configuration_type_is_positive) {
    std::cout << "Entering db_cfg_type_is_set_database_configuration_type_is_positive test" << std::endl;
    dm_easy_mesh_t obj;
    ASSERT_EQ(obj.init(), 0);
    obj.m_db_cfg_param.db_cfg_type = 5;
    std::cout << "Set m_db_cfg_param.db_cfg_type to 5" << std::endl;
    std::cout << "Invoking db_cfg_type_is_set()" << std::endl;
    bool ret = obj.db_cfg_type_is_set();
    std::cout << "db_cfg_type_is_set() returned: " << ret << std::endl;
    EXPECT_TRUE(ret);
    obj.deinit();
    std::cout << "Exiting db_cfg_type_is_set_database_configuration_type_is_positive test" << std::endl;
}

/**
 * @brief Verify that db_cfg_type_is_set() returns false when database configuration type is set to zero
 *
 * This test ensures that when the m_db_cfg_param.db_cfg_type is explicitly set to 0 after a successful initialization,
 * the db_cfg_type_is_set() API correctly identifies that the database configuration type is not set (returns false).
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 036@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                             | Expected Result                                 | Notes       |
 * | :--------------: | --------------------------------------------------------------------------- | ----------------------------------------------------- | ----------------------------------------------- | ----------- |
 * | 01               | Initialize dm_easy_mesh_t, verify successful initialization, set db_cfg_type to 0, then invoke db_cfg_type_is_set() | init() returns 0, m_db_cfg_param.db_cfg_type = 0, output from db_cfg_type_is_set() = false | db_cfg_type_is_set() should return false; ASSERT and EXPECT validations pass | Should Pass |
 */
TEST(dm_easy_mesh_t, db_cfg_type_is_set_database_configuration_type_is_zero) {
    std::cout << "Entering db_cfg_type_is_set_database_configuration_type_is_zero test" << std::endl;
    dm_easy_mesh_t obj;
    ASSERT_EQ(obj.init(), 0);
    obj.m_db_cfg_param.db_cfg_type = 0;
    std::cout << "Set m_db_cfg_param.db_cfg_type to 0" << std::endl;
    std::cout << "Invoking db_cfg_type_is_set()" << std::endl;
    bool ret = obj.db_cfg_type_is_set();
    std::cout << "db_cfg_type_is_set() returned: " << ret << std::endl;
    EXPECT_FALSE(ret);
    obj.deinit();
    std::cout << "Exiting db_cfg_type_is_set_database_configuration_type_is_zero test" << std::endl;
}

/**
 * @brief Verify that db_cfg_type_is_set returns true when the specific configuration flag is set.
 *
 * This test case validates that by initializing the dm_easy_mesh_t object, setting its configuration
 * flag (db_cfg_type_network_list_update) appropriately, and then invoking the db_cfg_type_is_set method,
 * the function correctly detects that the flag is set and returns true. This test ensures that the API
 * behaves as expected in a positive scenario where the flag is present.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 037@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * |01| Initialize dm_easy_mesh_t object and validate proper initialization using init() | No input, output: init() returns 0 | init() returns 0 confirming successful initialization | Should Pass |
 * |02| Set the configuration flag to db_cfg_type_network_list_update | m_db_cfg_param.db_cfg_type = static_cast<unsigned int>(db_cfg_type_network_list_update) | Configuration flag is set to the value corresponding to db_cfg_type_network_list_update | Should be successful |
 * |03| Invoke db_cfg_type_is_set() with db_cfg_type_network_list_update as parameter | input: flag = db_cfg_type_network_list_update, output: result from db_cfg_type_is_set() | Method returns true indicating the flag is correctly set | Should Pass |
 * |04| Log test completion messages | Standard output messages indicating test entry and exit | Completion messages printed confirming the successful test execution | Should be successful |
 */
TEST(dm_easy_mesh_t, db_cfg_type_is_set_Positive_specific_flag_set)
{
    std::cout << "Entering db_cfg_type_is_set_Positive_specific_flag_set test" << std::endl;
    dm_easy_mesh_t obj;
    ASSERT_EQ(obj.init(), 0);
    // Set configuration flag using db_cfg_type_network_list_update
    obj.m_db_cfg_param.db_cfg_type = static_cast<unsigned int>(db_cfg_type_network_list_update);
    std::cout << "Set m_db_cfg_param.db_cfg_type to db_cfg_type_network_list_update ("
              << static_cast<unsigned int>(db_cfg_type_network_list_update) << ")" << std::endl;
    // Invoke the method
    bool result = obj.db_cfg_type_is_set(db_cfg_type_network_list_update);
    std::cout << "db_cfg_type_is_set() returned: " << std::boolalpha << result << std::endl;
    EXPECT_TRUE(result);
    obj.deinit();
    std::cout << "Exiting db_cfg_type_is_set_Positive_specific_flag_set test" << std::endl;
}

/**
 * @brief Test db_cfg_type_is_set() for negative scenario when a specific flag is not set
 *
 * This test verifies that when m_db_cfg_param.db_cfg_type is set to db_cfg_type_device_list_update, invoking db_cfg_type_is_set() 
 * with db_cfg_type_network_list_update returns false. It ensures that the API correctly identifies the absence of the expected flag.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 038@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                     | Test Data                                                                                                                           | Expected Result                                          | Notes             |
 * | :--------------: | -------------------------------------------------------------------------------------------------| ----------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------- | ----------------- |
 * | 01               | Initialize dm_easy_mesh_t object and verify that init() returns 0                                | No input parameters, output: init() return value = 0                                                                                 | init() returns 0                                         | Should be successful |
 * | 02               | Set m_db_cfg_param.db_cfg_type to db_cfg_type_device_list_update                                  | m_db_cfg_param.db_cfg_type = db_cfg_type_device_list_update                                                                            | Parameter is updated correctly                           | Should be successful |
 * | 03               | Invoke db_cfg_type_is_set() with db_cfg_type_network_list_update and verify the API returns false  | API input: db_cfg_type_network_list_update, output: expected return value = false                                                     | Returns false and EXPECT_FALSE assertion passes          | Should Fail         |
 */
TEST(dm_easy_mesh_t, db_cfg_type_is_set_Negative_specific_flag_not_set)
{
    std::cout << "Entering db_cfg_type_is_set_Negative_specific_flag_not_set test" << std::endl;
    dm_easy_mesh_t obj;
    ASSERT_EQ(obj.init(), 0);
    obj.m_db_cfg_param.db_cfg_type = static_cast<unsigned int>(db_cfg_type_device_list_update);
    std::cout << "Set m_db_cfg_param.db_cfg_type to db_cfg_type_device_list_update ("
              << static_cast<unsigned int>(db_cfg_type_device_list_update) << ")" << std::endl;
    bool result = obj.db_cfg_type_is_set(db_cfg_type_network_list_update);
    std::cout << "db_cfg_type_is_set() returned: " << std::boolalpha << result << std::endl;
    EXPECT_FALSE(result);
    obj.deinit();
    std::cout << "Exiting db_cfg_type_is_set_Negative_specific_flag_not_set test" << std::endl;
}

/**
 * @brief Test to verify that db_cfg_type_is_set correctly identifies combined db_cfg_type flags.
 *
 * This test verifies that when multiple db_cfg_type enumerations (device_list_update, radio_list_update, bss_list_delete, and policy_list_delete) are combined into a single flag value,
 * the db_cfg_type_is_set API returns true for these flags and false for all other enum values. This validation ensures that bitwise operations on configuration flags are handled as expected.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 039@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                                                   | Test Data                                                                                                                        | Expected Result                                                                                                       | Notes         |
 * | :--------------: | ----------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize dm_easy_mesh_t object and call init() to check successful initialization.                                          | obj.init() = 0                                                                                                                   | Returns 0 indicating successful initialization and assertion passes.                                                | Should Pass   |
 * | 02               | Set the db_cfg_param.db_cfg_type with the combined flag value of device_list_update, radio_list_update, bss_list_delete, and policy_list_delete. | db_cfg_type_device_list_update, db_cfg_type_radio_list_update, db_cfg_type_bss_list_delete, db_cfg_type_policy_list_delete = combined value | db_cfg_type is assigned the combined flag value correctly.                                                          | Should be successful |
 * | 03               | Loop through all enum values and verify that db_cfg_type_is_set returns true only for the combined flags and false for others.     | For each enum value in the list, input: enum value; output: result from db_cfg_type_is_set(enum value)                             | Returns true for device_list_update, radio_list_update, bss_list_delete, and policy_list_delete; false for others.        | Should Pass   |
 */
TEST(dm_easy_mesh_t, db_cfg_type_is_set_Loop_all_enum_values_combined_flags)
{
    std::cout << "Entering db_cfg_type_is_set_Loop_all_enum_values_combined_flags test" << std::endl;
    dm_easy_mesh_t obj;
    ASSERT_EQ(obj.init(), 0);
    unsigned int combined = static_cast<unsigned int>(db_cfg_type_device_list_update) |
                            static_cast<unsigned int>(db_cfg_type_radio_list_update) |
                            static_cast<unsigned int>(db_cfg_type_bss_list_delete)  |
                            static_cast<unsigned int>(db_cfg_type_policy_list_delete);
    obj.m_db_cfg_param.db_cfg_type = combined;
    db_cfg_type_t enumValues[] = {
        db_cfg_type_none, db_cfg_type_network_list_update, db_cfg_type_network_list_delete,
        db_cfg_type_device_list_update, db_cfg_type_device_list_delete,
        db_cfg_type_radio_list_update, db_cfg_type_radio_list_delete,
        db_cfg_type_op_class_list_update, db_cfg_type_op_class_list_delete,
        db_cfg_type_bss_list_update, db_cfg_type_bss_list_delete,
        db_cfg_type_sta_list_update, db_cfg_type_sta_list_delete,
        db_cfg_type_network_ssid_list_update, db_cfg_type_network_ssid_list_delete,
        db_cfg_type_radio_cap_list_update, db_cfg_type_radio_cap_list_delete,
        db_cfg_type_1905_security_list_update, db_cfg_type_1905_security_list_delete,
        db_cfg_type_sta_metrics_update, db_cfg_type_policy_list_update,
        db_cfg_type_policy_list_delete, db_cfg_type_scan_result_list_update,
        db_cfg_type_scan_result_list_delete
    };

    for (db_cfg_type_t type : enumValues) {
        bool result = obj.db_cfg_type_is_set(type);
        if (type == db_cfg_type_device_list_update ||
            type == db_cfg_type_radio_list_update ||
            type == db_cfg_type_bss_list_delete ||
            type == db_cfg_type_policy_list_delete)
        {
            EXPECT_TRUE(result);
        } else {
            EXPECT_FALSE(result);
        }
    }
    obj.deinit();
    std::cout << "Exiting db_cfg_type_is_set_Loop_all_enum_values_combined_flags test" << std::endl;
}

/**
 * @brief Verify that db_cfg_type_is_set returns false when the object's configuration does not match the queried type.
 *
 * This test initializes a dm_easy_mesh_t object, verifies a successful initialization by checking that init() returns 0, 
 * sets the object's m_db_cfg_param.db_cfg_type to radio_cap_list_update, and then calls db_cfg_type_is_set with db_cfg_type_none.
 * The expected behavior is that db_cfg_type_is_set returns false because the queried type does not match the set configuration.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 040@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |@n
 * | :----: | --------- | ---------- |-------------- | ----- |@n
 * | 01 | Initialize the dm_easy_mesh_t object and validate init() returns 0 | No input, output: init() returns 0 | Returns 0 from init() function | Should be successful |@n
 * | 02 | Set m_db_cfg_param.db_cfg_type with radio_cap_list_update value | Object state: m_db_cfg_param.db_cfg_type = radio_cap_list_update | Parameter successfully set | Should be successful |@n
 * | 03 | Invoke db_cfg_type_is_set with db_cfg_type_none and verify the returned value | API call: db_cfg_type_is_set(db_cfg_type = db_cfg_type_none), Expected output: false | Returns false from db_cfg_type_is_set API and passes EXPECT_FALSE assertion | Should Pass |
 */
TEST(dm_easy_mesh_t, db_cfg_type_is_set_Input_with_db_cfg_type_none)
{
    std::cout << "Entering db_cfg_type_is_set_Input_with_db_cfg_type_none test" << std::endl;
    dm_easy_mesh_t obj;
    ASSERT_EQ(obj.init(), 0);
    obj.m_db_cfg_param.db_cfg_type = static_cast<unsigned int>(db_cfg_type_radio_cap_list_update);
    bool result = obj.db_cfg_type_is_set(db_cfg_type_none);
    EXPECT_FALSE(result);
    obj.deinit();
    std::cout << "Exiting db_cfg_type_is_set_Input_with_db_cfg_type_none test" << std::endl;
}

/**
 * @brief Verify that the decode_ap_cap_config API correctly processes a valid subdocument with a valid key.
 *
 * This test checks that when a valid em_subdoc_info_t with proper JSON content is provided along with a valid key ("ap_cap"),
 * the decode_ap_cap_config API returns a success status (0). The test involves setting up the subdocument, copying the JSON data,
 * and calling the API to ensure it correctly decodes the configuration data.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 041@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | --------------- | ----- |
 * | 01 | Log the entry message to indicate the start of the test. | N/A | Console prints "Entering decode_ap_cap_config_valid_subdoc_valid_key test". | Should be successful |
 * | 02 | Initialize dm_easy_mesh_t instance and prepare key and JSON string. | dm_easy_mesh_t dm, key = "ap_cap", json = "{ \"wfa-dataelements:ap_cap\": { \"DeviceList\": [ { \"MsgID\": 10 } ] } }" | Variables are initialized with valid values. | Should be successful |
 * | 03 | Allocate memory for em_subdoc_info_t and copy JSON content into subdoc buffer. | json_len = strlen(json) + 1, total_size = sizeof(em_subdoc_info_t) + json_len, subdoc->buff contains json | Memory allocated successfully and subdoc structure populated. | Should be successful |
 * | 04 | Invoke decode_ap_cap_config API using the prepared subdoc and key. | subdoc (with valid JSON), key = "ap_cap" | API returns 0 indicating successful decoding. | Should Pass |
 * | 05 | Free the allocated memory and log the exit message of the test. | free(subdoc), Console prints exit message | Memory is freed and console prints "Exiting decode_ap_cap_config_valid_subdoc_valid_key test". | Should be successful |
 */
TEST(dm_easy_mesh_t, decode_ap_cap_config_valid_subdoc_valid_key)
{
    std::cout << "Entering decode_ap_cap_config_valid_subdoc_valid_key test" << std::endl;
    dm_easy_mesh_t dm;
    const char *key = "ap_cap";
    const char *json =
        "{"
        "  \"wfa-dataelements:ap_cap\": {"
        "    \"DeviceList\": ["
        "      { \"MsgID\": 10 }"
        "    ]"
        "  }"
        "}";
    size_t json_len = strlen(json) + 1;
    size_t total_size = sizeof(em_subdoc_info_t) + json_len;
    em_subdoc_info_t *subdoc = reinterpret_cast<em_subdoc_info_t *>(malloc(total_size));
    ASSERT_NE(subdoc, nullptr);
    memset(subdoc, 0, sizeof(em_subdoc_info_t));
    memcpy(subdoc->buff, json, json_len);
    int ret = dm.decode_ap_cap_config(subdoc, key);
    ASSERT_EQ(ret, 0);
    free(subdoc);
    std::cout << "Exiting decode_ap_cap_config_valid_subdoc_valid_key test" << std::endl;
}

/**
 * @brief Test the behavior of decode_ap_cap_config when the subdoc parameter is NULL
 *
 * This test ensures that when a NULL subdocument is provided to the decode_ap_cap_config method along with a valid key, the function returns -1 to indicate an error. This verifies that the error handling for null subdocument inputs is implemented correctly.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 042@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                   | Test Data                                  | Expected Result                                                           | Notes       |
 * | :--------------: | ------------------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------------------------- | ----------- |
 * | 01               | Invoke decode_ap_cap_config with subdoc set to NULL and key "ap_cap" and validate the return value is -1 | subdoc = NULL, key = "ap_cap"               | Return value is -1 and assertion ASSERT_EQ(ret, -1) passes                | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_ap_cap_config_null_subdoc) {
    std::cout << "Entering decode_ap_cap_config_null_subdoc test" << std::endl;
    dm_easy_mesh_t dm;
    const char *key = "ap_cap";
    std::cout << "Invoking decode_ap_cap_config with subdoc: NULL and key: " << key << std::endl;
    int ret = dm.decode_ap_cap_config(NULL, key);
    ASSERT_EQ(ret, -1);   
    std::cout << "Exiting decode_ap_cap_config_null_subdoc test" << std::endl;
}

/**
 * @brief Test to verify that decode_ap_cap_config handles a null key appropriately.
 *
 * This test case verifies that when a null key is passed to the decode_ap_cap_config API, the function returns an error value (-1). It sets up a valid JSON configuration in a dynamically allocated subdocument and passes a null key to trigger the error handling.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 043@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                              | Test Data                                                                                                                               | Expected Result                                                      | Notes       |
 * | :--------------: | ---------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- | ----------- |
 * | 01               | Initialize a subdocument with a valid JSON payload and invoke decode_ap_cap_config API with a null key | subdoc->buff = "{"wfa-dataelements:ap_cap": { "DeviceList": [ { "MsgID": 1 } ] }", key = nullptr, json_len = length(json)+1, total_size = sizeof(em_subdoc_info_t) + json_len | API returns -1 indicating failure; assertion ASSERT_EQ(ret, -1) confirms error handling  | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_ap_cap_config_null_key)
{
    std::cout << "Entering decode_ap_cap_config_null_key test" << std::endl;
    dm_easy_mesh_t dm;
    const char *key = nullptr;
    const char *json =
        "{"
        "  \"wfa-dataelements:ap_cap\": {"
        "    \"DeviceList\": [ { \"MsgID\": 1 } ]"
        "  }"
        "}";
    size_t json_len = strlen(json) + 1;
    size_t total_size = sizeof(em_subdoc_info_t) + json_len;
    em_subdoc_info_t *subdoc = reinterpret_cast<em_subdoc_info_t *>(malloc(total_size));
    ASSERT_NE(subdoc, nullptr);
    memset(subdoc, 0, sizeof(em_subdoc_info_t));
    memcpy(subdoc->buff, json, json_len);
    int ret = dm.decode_ap_cap_config(subdoc, key);
    ASSERT_EQ(ret, -1);
    free(subdoc);
    std::cout << "Exiting decode_ap_cap_config_null_key test" << std::endl;
}

/**
 * @brief Test decode_ap_cap_config API with an invalid JSON input payload
 *
 * This test verifies that the decode_ap_cap_config API correctly handles invalid JSON input.
 * It allocates a subdocument, initializes it with an invalid JSON string, and asserts that the API returns -1.
 * This negative test is crucial to ensure that the API validates input JSON strings and properly handles parsing errors@n
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 044@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:** 
 * | Variation / Step | Description                                                                 | Test Data                                                                                                    | Expected Result                             | Notes       |
 * | :--------------: | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ | ------------------------------------------- | ----------- |
 * | 01               | Prepare invalid JSON payload and invoke decode_ap_cap_config API             | subdoc->buff = { invalid json }, key = ap_cap, json_len = strlen("{ invalid json }") + 1, total_size = sizeof(em_subdoc_info_t) + json_len | API returns -1 and assertion passes         | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_ap_cap_config_invalid_json)
{
    std::cout << "Entering decode_ap_cap_config_invalid_json test" << std::endl;
    dm_easy_mesh_t dm;
    const char *key = "ap_cap";
    const char *json = "{ invalid json }";
    size_t json_len = strlen(json) + 1;
    size_t total_size = sizeof(em_subdoc_info_t) + json_len;
    em_subdoc_info_t *subdoc = reinterpret_cast<em_subdoc_info_t *>(malloc(total_size));
    ASSERT_NE(subdoc, nullptr);
    memset(subdoc, 0, sizeof(em_subdoc_info_t));
    memcpy(subdoc->buff, json, json_len);
    std::cout << "Invoking decode_ap_cap_config with invalid json" << std::endl;
    int ret = dm.decode_ap_cap_config(subdoc, key);
    ASSERT_EQ(ret, -1);
    free(subdoc);
    std::cout << "Exiting decode_ap_cap_config_invalid_json test" << std::endl;
}

/**
 * @brief Verify behavior of decode_ap_cap_config when the required "ap_cap" parent key is missing
 *
 * This test verifies that the decode_ap_cap_config function properly handles a JSON input that lacks 
 * the expected "ap_cap" parent key by returning an error code (-1). It ensures that the subdocument 
 * is correctly allocated and populated, and finally, the API call fails as expected when the key is missing.@n
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 045@n
 * **Priority:** High@n
 * @n
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * @n
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Allocate subdocument and prepare JSON input missing the "ap_cap" key | key = "ap_cap", json = "{"wfa-dataelements:wrong_key": { "DeviceList": [ { "MsgID": 1 } ]}" | Subdocument is allocated and populated with the provided JSON string | Should be successful |
 * | 02 | Invoke decode_ap_cap_config API with the prepared incorrect JSON input | subdoc pointer = valid pointer, key = "ap_cap" | Function returns -1 indicating the missing parent key | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_ap_cap_config_missing_parent_key)
{
    std::cout << "Entering decode_ap_cap_config_missing_parent_key test" << std::endl;
    dm_easy_mesh_t dm;
    const char *key = "ap_cap";
    const char *json =
        "{"
        "  \"wfa-dataelements:wrong_key\": {"
        "    \"DeviceList\": [ { \"MsgID\": 1 } ]"
        "  }"
        "}";
    size_t json_len = strlen(json) + 1;
    size_t total_size = sizeof(em_subdoc_info_t) + json_len;
    em_subdoc_info_t *subdoc = reinterpret_cast<em_subdoc_info_t *>(malloc(total_size));
    ASSERT_NE(subdoc, nullptr);
    memset(subdoc, 0, sizeof(em_subdoc_info_t));
    memcpy(subdoc->buff, json, json_len);
    std::cout << "Invoking decode_ap_cap_config with missing parent key" << std::endl;
    int ret = dm.decode_ap_cap_config(subdoc, key);
    ASSERT_EQ(ret, -1);
    free(subdoc);
    std::cout << "Exiting decode_ap_cap_config_missing_parent_key test" << std::endl;
}

/**
 * @brief Test to verify that decode_ap_cap_config returns an error when the required device list is missing.
 *
 * This test verifies that when a JSON configuration for AP capabilities is parsed without the mandatory device list, 
 * the decode_ap_cap_config API returns an error (-1). It ensures that the API correctly identifies the missing device list 
 * and does not proceed with an incorrect or incomplete configuration.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 046@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Allocate memory and initialize the subdoc structure with JSON missing the device list. | key = "ap_cap", json = "{ \"wfa-dataelements:ap_cap\": { } }", json_len = strlen(json)+1, total_size = sizeof(em_subdoc_info_t)+json_len | Memory allocated successfully and subdoc initialized with zeroed header and JSON copied into buffer. | Should be successful |
 * | 02 | Invoke the decode_ap_cap_config API with the initialized subdoc to decode the AP capability configuration. | subdoc = allocated subdoc, key = "ap_cap" | API returns -1 due to missing mandatory device list. | Should Fail |
 * | 03 | Free the allocated memory to clean up after the test. | free(subdoc) | Memory freed successfully. | Should be successful |
 */
TEST(dm_easy_mesh_t, decode_ap_cap_config_missing_device_list)
{
    std::cout << "Entering decode_ap_cap_config_missing_device_list test" << std::endl;
    dm_easy_mesh_t dm;
    const char *key = "ap_cap";
    const char *json =
        "{"
        "  \"wfa-dataelements:ap_cap\": {"
        "  }"
        "}";
    size_t json_len = strlen(json) + 1;
    size_t total_size = sizeof(em_subdoc_info_t) + json_len;
    em_subdoc_info_t *subdoc = reinterpret_cast<em_subdoc_info_t *>(malloc(total_size));
    ASSERT_NE(subdoc, nullptr);
    memset(subdoc, 0, sizeof(em_subdoc_info_t));
    memcpy(subdoc->buff, json, json_len);
    std::cout << "Invoking decode_ap_cap_config with missing device list" << std::endl;
    int ret = dm.decode_ap_cap_config(subdoc, key);
    ASSERT_EQ(ret, -1);
    free(subdoc);
    std::cout << "Exiting decode_ap_cap_config_missing_device_list test" << std::endl;
}

/**
 * @brief Verify that decode_ap_cap_config returns an error when provided an empty device list
 *
 * This test verifies that the decode_ap_cap_config API correctly handles a JSON payload where the
 * "DeviceList" is empty. The function is expected to return an error code (-1) in this scenario, ensuring
 * that configurations missing required device information are properly rejected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 047@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                         | Test Data                                                                                                                                                          | Expected Result                               | Notes         |
 * | :--------------: | --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------- | ------------- |
 * | 01               | Prepare JSON payload with an empty "DeviceList", allocate subdoc memory, and copy the JSON string  | key = "ap_cap", json = { "wfa-dataelements:ap_cap": { "DeviceList": [] } }, json_len = strlen(json)+1, total_size = sizeof(em_subdoc_info_t)+json_len          | Subdoc allocated successfully                | Should be successful |
 * | 01               | Invoke decode_ap_cap_config with the key and the prepared subdoc, then verify that API returns -1    | input: key = "ap_cap", subdoc->buff contains JSON with empty DeviceList, output: ret = decode_ap_cap_config(subdoc, key)                                           | API returns -1 indicating error due to empty device list | Should Fail   |
 */
TEST(dm_easy_mesh_t, decode_ap_cap_config_empty_device_list)
{
    std::cout << "Entering decode_ap_cap_config_empty_device_list test" << std::endl;
    dm_easy_mesh_t dm;
    const char *key = "ap_cap";
    const char *json =
        "{"
        "  \"wfa-dataelements:ap_cap\": {"
        "    \"DeviceList\": []"
        "  }"
        "}";
    size_t json_len = strlen(json) + 1;
    size_t total_size = sizeof(em_subdoc_info_t) + json_len;
    em_subdoc_info_t *subdoc = reinterpret_cast<em_subdoc_info_t *>(malloc(total_size));
    ASSERT_NE(subdoc, nullptr);
    memset(subdoc, 0, sizeof(em_subdoc_info_t));
    memcpy(subdoc->buff, json, json_len);
    std::cout << "Invoking decode_ap_cap_config with empty device list" << std::endl;
    int ret = dm.decode_ap_cap_config(subdoc, key);
    ASSERT_EQ(ret, -1);
    free(subdoc);
    std::cout << "Exiting decode_ap_cap_config_empty_device_list test" << std::endl;
}

/**
 * @brief Verifies that the decode_client_cap_config function correctly decodes a valid JSON client capability configuration.
 *
 * This test ensures that when provided with a valid JSON representing client capability information, the decode_client_cap_config function
 * properly parses the JSON, extracts the client MAC and radio MAC addresses, and returns a success code. The test validates the correctness
 * of the decoding process by comparing the output buffers against the expected MAC addresses.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 048@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                         | Test Data                                                                                                                                                          | Expected Result                                                                                                                                               | Notes           |
 * | :--------------: | --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------- |
 * | 01               | Initialize test environment by creating a valid JSON string and subdocument for client capability.  | key = "clientcap", json = "{\"wfa-dataelements:clientcap\": {\"DeviceList\": [{\"MsgID\": 5, \"ClientMac\": \"00:11:22:33:44:55\", \"RadioMac\": \"66:77:88:99:AA:BB\"}]}}" | Subdocument is created successfully and contains the valid JSON structure.                                                                                   | Should be successful |
 * | 02               | Invoke decode_client_cap_config to decode the JSON and extract client and radio MAC addresses.       | subdoc pointer, clientmac buffer initialized to zeros, radiomac buffer initialized to zeros                                                                         | Return value is 0, clientmac equals "00:11:22:33:44:55", and radiomac equals "66:77:88:99:AA:BB".                                                             | Should Pass     |
 * | 03               | Cleanup resources by freeing the allocated subdocument and confirm the test completes without error. | free(subdoc)                                                                                                                                                       | Memory is freed properly and there are no residual errors.                                                                                                   | Should be successful |
 */
TEST(dm_easy_mesh_t, decode_client_cap_config_valid_decoding)
{
    std::cout << "Entering decode_client_cap_config_valid_decoding test" << std::endl;
    dm_easy_mesh_t dm;
    const char *key = "clientcap";
    const char *json =
        "{"
        "  \"wfa-dataelements:clientcap\": {"
        "    \"DeviceList\": ["
        "      {"
        "        \"MsgID\": 5,"
        "        \"ClientMac\": \"00:11:22:33:44:55\","
        "        \"RadioMac\": \"66:77:88:99:AA:BB\""
        "      }"
        "    ]"
        "  }"
        "}";
    em_subdoc_info_t *subdoc = make_subdoc(json);
    char clientmac[18] = {0};
    char radiomac[18] = {0};
    std::cout << "Invoking decode_client_cap_config with valid decoding" << std::endl;
    int ret = dm.decode_client_cap_config(subdoc, key, clientmac, radiomac);
    ASSERT_EQ(ret, 0);
    ASSERT_STREQ(clientmac, "00:11:22:33:44:55");
    ASSERT_STREQ(radiomac, "66:77:88:99:AA:BB");
    free(subdoc);
    std::cout << "Exiting decode_client_cap_config_valid_decoding test" << std::endl;
}

/**
 * @brief Validate error handling for decode_client_cap_config with invalid JSON input
 *
 * This test case verifies that the decode_client_cap_config API correctly handles the case when provided with an invalid JSON string. The function is expected to return an error code (-1) for malformed JSON data, thus ensuring robust error handling.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 049@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                 | Test Data                                                                                                                | Expected Result                                              | Notes       |
 * | :--------------: | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------ | ----------- |
 * | 01               | Prepare the test data and invoke decode_client_cap_config with invalid JSON configuration      | subdoc = {invalid json}, key = clientcap, clientmac = char[18] initialized to 0, radiomac = char[18] initialized to 0   | API returns -1, and ASSERT_EQ(ret, -1) validates the error code | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_client_cap_config_invalid_json)
{
    std::cout << "Entering decode_client_cap_config_invalid_json test" << std::endl;
    dm_easy_mesh_t dm;
    const char *key = "clientcap";
    em_subdoc_info_t *subdoc = make_subdoc("{ invalid json }");
    char clientmac[18] = {0};
    char radiomac[18] = {0};
    std::cout << "Invoking decode_client_cap_config with invalid json" << std::endl;
    int ret = dm.decode_client_cap_config(subdoc, key, clientmac, radiomac);
    ASSERT_EQ(ret, -1);
    free(subdoc);
    std::cout << "Exiting decode_client_cap_config_invalid_json test" << std::endl;
}

/**
 * @brief Verify that decode_client_cap_config returns an error when the expected parent key is missing.
 *
 * This test verifies that the decode_client_cap_config method correctly identifies a JSON structure that does not contain
 * the required parent key "clientcap" and returns an error (-1). This negative test ensures proper error handling in the API.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 050@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Call decode_client_cap_config with a JSON string missing the required parent key "clientcap" and verify the error return code | subdoc = JSON with "wfa-dataelements:wrongkey", key = "clientcap", clientmac = char[18] (zero initialized), radiomac = char[18] (zero initialized) | decode_client_cap_config returns -1 and ASSERT_EQ(ret, -1) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_client_cap_config_missing_parent_key)
{
    std::cout << "Entering decode_client_cap_config_missing_parent_key test" << std::endl;
    dm_easy_mesh_t dm;
    const char *key = "clientcap";
    const char *json =
        "{"
        "  \"wfa-dataelements:wrongkey\": {"
        "    \"DeviceList\": [ { \"MsgID\": 1 } ]"
        "  }"
        "}";
    em_subdoc_info_t *subdoc = make_subdoc(json);
    char clientmac[18] = {0};
    char radiomac[18] = {0};
    int ret = dm.decode_client_cap_config(subdoc, key, clientmac, radiomac);
    ASSERT_EQ(ret, -1);
    free(subdoc);
    std::cout << "Exiting decode_client_cap_config_missing_parent_key test" << std::endl;
}

/**
 * @brief Validate the decode_client_cap_config API when the device list is missing
 *
 * This test verifies that the decode_client_cap_config function correctly handles a JSON input that omits the device list configuration.
 * The function is expected to return an error code (-1) in such a scenario.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 051@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | --------------- | ----- |
 * | 01 | Initialize test variables and environment setup | key = "clientcap", json = "{\"wfa-dataelements:clientcap\": { }}", clientmac = zero initialized 18 char array, radiomac = zero initialized 18 char array | Environment variables and JSON setup completed successfully | Should be successful |
 * | 02 | Invoke decode_client_cap_config API with missing device list | subdoc = pointer from make_subdoc(json), key = "clientcap", clientmac = 18 char array, radiomac = 18 char array, expected return value = -1 | API returns -1 indicating error due to missing device list in the JSON input | Should Fail
 */
TEST(dm_easy_mesh_t, decode_client_cap_config_missing_device_list)
{
    std::cout << "Entering decode_client_cap_config_missing_device_list test" << std::endl;
    dm_easy_mesh_t dm;
    const char *key = "clientcap";
    const char *json =
        "{"
        "  \"wfa-dataelements:clientcap\": { }"
        "}";
    em_subdoc_info_t *subdoc = make_subdoc(json);
    char clientmac[18] = {0};
    char radiomac[18] = {0};
    int ret = dm.decode_client_cap_config(subdoc, key, clientmac, radiomac);
    ASSERT_EQ(ret, -1);
    free(subdoc);
    std::cout << "Exiting decode_client_cap_config_missing_device_list test" << std::endl;
}

/**
 * @brief Validate that decode_client_cap_config returns -1 when provided with an empty device list
 *
 * This test verifies that the decode_client_cap_config API of dm_easy_mesh_t correctly handles a scenario
 * where the input JSON configuration contains an empty device list for the "clientcap" key. This is important to 
 * ensure the API gracefully handles missing device data by returning an error code.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 052@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke decode_client_cap_config with a JSON containing an empty DeviceList | subdoc = JSON with "wfa-dataelements:clientcap": { "DeviceList": [] }, key = "clientcap", clientmac = char[18]={0}, radiomac = char[18]={0} | Returns -1; Assertion verifies that return value equals -1 | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_client_cap_config_empty_device_list)
{
    std::cout << "Entering decode_client_cap_config_empty_device_list test" << std::endl;
    dm_easy_mesh_t dm;
    const char *key = "clientcap";
    const char *json =
        "{"
        "  \"wfa-dataelements:clientcap\": {"
        "    \"DeviceList\": []"
        "  }"
        "}";
    em_subdoc_info_t *subdoc = make_subdoc(json);
    char clientmac[18] = {0};
    char radiomac[18] = {0};
    int ret = dm.decode_client_cap_config(subdoc, key, clientmac, radiomac);
    ASSERT_EQ(ret, -1);
    free(subdoc);
    std::cout << "Exiting decode_client_cap_config_empty_device_list test" << std::endl;
}

/**
 * @brief Validate behavior of decode_client_cap_config when subdoc is NULL
 *
 * This test verifies that the decode_client_cap_config API correctly handles a NULL subdoc pointer. 
 * It ensures that the function returns an error value (-1) when the subdoc input is NULL while the key and buffer parameters are valid.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 053@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                         | Expected Result                                           | Notes         |
 * | :--------------: | --------------------------------------------------------------------------- | ----------------------------------------------------------------- | --------------------------------------------------------- | ------------- |
 * | 01               | Invoke decode_client_cap_config with a NULL subdoc, valid key, and allocated buffers | subdoc = NULL, key = "clientcap", clientmac = char[18] initialized to zero, radio_mac = char[18] initialized to zero | API returns -1 and assertion verifies the return value is -1 | Should Pass   |
 */
TEST(dm_easy_mesh_t, decode_client_cap_config_null_subdoc) {
    std::cout << "Entering decode_client_cap_config_null_subdoc test" << std::endl;
    const char *key = "clientcap";
    char clientmac[18] = {0};
    char radio_mac[18] = {0};
    std::cout << "Invoking decode_client_cap_config with:" << std::endl;
    std::cout << "  subdoc = NULL" << std::endl;
    std::cout << "  key = " << key << std::endl;
    std::cout << "  clientmac and radio_mac buffers allocated (size 18)" << std::endl;
    dm_easy_mesh_t dm;
    int ret = dm.decode_client_cap_config(NULL, key, clientmac, radio_mac);
    std::cout << "Method returned: " << ret << std::endl;
    ASSERT_EQ(-1, ret);
    std::cout << "Exiting decode_client_cap_config_null_subdoc test" << std::endl;
}

/**
 * @brief Verifies that decode_client_cap_config returns an error when a NULL key is provided.
 *
 * This test checks that when the key parameter passed to decode_client_cap_config is NULL, the function returns -1.
 * This ensures proper error handling for invalid input parameters.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 054@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                          | Test Data                                                                                 | Expected Result                                              | Notes       |
 * | :--------------: | -------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | ------------------------------------------------------------ | ----------- |
 * | 01               | Invoke decode_client_cap_config with a valid subdoc and a NULL key.    | subdoc.name = "clientcap", key = NULL, clientmac = allocated (18), radio_mac = allocated (18) | Return value equals -1 and ASSERT_EQ(-1, ret) passes           | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_client_cap_config_null_key) {
    std::cout << "Entering decode_client_cap_config_null_key test" << std::endl;
    em_subdoc_info_t subdoc;
    strncpy(subdoc.name, "clientcap", sizeof(subdoc.name) - 1);
    subdoc.name[sizeof(subdoc.name)-1] = '\0';
    const char *key = NULL;
    char clientmac[18] = {0};
    char radio_mac[18] = {0};
    std::cout << "Invoking decode_client_cap_config with:" << std::endl;
    std::cout << "  subdoc.name = " << subdoc.name << std::endl;
    std::cout << "  key = NULL" << std::endl;
    std::cout << "  clientmac and radio_mac buffers allocated (size 18)" << std::endl;
    dm_easy_mesh_t dm;
    int ret = dm.decode_client_cap_config(&subdoc, key, clientmac, radio_mac);
    std::cout << "Method returned: " << ret << std::endl;
    ASSERT_EQ(-1, ret);
    std::cout << "Exiting decode_client_cap_config_null_key test" << std::endl;
}

/**
 * @brief Tests that decode_client_cap_config correctly handles a NULL clientmac pointer.
 *
 * This test verifies that when the decode_client_cap_config API is invoked with a NULL clientmac argument,
 * it returns the expected error code (-1). The test ensures that the function performs proper validation
 * of its input parameters and handles the error condition gracefully.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 055@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                             | Test Data                                                      | Expected Result                                                               | Notes        |
 * | :--------------: | ------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------- | ----------------------------------------------------------------------------- | ------------ |
 * | 01               | Invoke decode_client_cap_config with a valid subdoc and key, a NULL clientmac pointer, and allocated radio_mac buffer of size 18. | subdoc.name = "clientcap", key = "clientcap", clientmac = NULL, radio_mac buffer size = 18 | Return value must be -1, confirmed by ASSERT_EQ(-1, ret)                      | Should Fail  |
 */
TEST(dm_easy_mesh_t, decode_client_cap_config_null_clientmac) {
    std::cout << "Entering decode_client_cap_config_null_clientmac test" << std::endl;    
    em_subdoc_info_t subdoc;
    strncpy(subdoc.name, "clientcap", sizeof(subdoc.name) - 1);
    subdoc.name[sizeof(subdoc.name)-1] = '\0';
    const char *key = "clientcap";
    char *clientmac = NULL;
    char radio_mac[18] = {0};
    std::cout << "Invoking decode_client_cap_config with:" << std::endl;
    std::cout << "  subdoc.name = " << subdoc.name << std::endl;
    std::cout << "  key = " << key << std::endl;
    std::cout << "  clientmac = NULL" << std::endl;
    std::cout << "  radio_mac buffer allocated (size 18)" << std::endl;
    dm_easy_mesh_t dm;
    int ret = dm.decode_client_cap_config(&subdoc, key, clientmac, radio_mac);
    std::cout << "Method returned: " << ret << std::endl;
    ASSERT_EQ(-1, ret);
    std::cout << "Exiting decode_client_cap_config_null_clientmac test" << std::endl;
}

/**
 * @brief Validate error handling in decode_client_cap_config when radio_mac is NULL
 *
 * This test verifies that the decode_client_cap_config API appropriately handles a NULL pointer passed for the radio_mac parameter. It ensures that the API returns an error (-1) when provided with invalid input, thereby confirming robust error checking.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 056@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke decode_client_cap_config with valid subdoc and key, an allocated clientmac buffer (size 18), and radio_mac set to NULL | subdoc.name = clientcap, key = clientcap, clientmac = allocated (buffer size 18), radio_mac = NULL | Returns -1 indicating that the invalid NULL radio_mac input is handled correctly and the assertion ASSERT_EQ(-1, ret) passes | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_client_cap_config_null_radio_mac) {
    std::cout << "Entering decode_client_cap_config_null_radio_mac test" << std::endl;
    em_subdoc_info_t subdoc;
    strncpy(subdoc.name, "clientcap", sizeof(subdoc.name) - 1);
    subdoc.name[sizeof(subdoc.name)-1] = '\0';
    const char *key = "clientcap";
    char clientmac[18] = {0};
    char *radio_mac = NULL;
    std::cout << "Invoking decode_client_cap_config with:" << std::endl;
    std::cout << "  subdoc.name = " << subdoc.name << std::endl;
    std::cout << "  key = " << key << std::endl;
    std::cout << "  clientmac buffer allocated (size 18)" << std::endl;
    std::cout << "  radio_mac = NULL" << std::endl;
    dm_easy_mesh_t dm;
    int ret = dm.decode_client_cap_config(&subdoc, key, clientmac, radio_mac);
    std::cout << "Method returned: " << ret << std::endl;
    ASSERT_EQ(-1, ret);
    std::cout << "Exiting decode_client_cap_config_null_radio_mac test" << std::endl;
}

/**
 * @brief Validate the correct parsing of JSON configuration for supported routing keys.
 *
 * This test verifies that the decode_config API correctly processes JSON configurations for various supported routing keys. It iterates over a set of pre-defined JSON templates corresponding to different routing functionalities and asserts that the API returns a successful status for each valid routing configuration.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 057@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke decode_config with JSON template for "SetAnticipatedChannelPreference" | input: subdoc->buff = "{ \"wfa-dataelements:SetAnticipatedChannelPreference\": {\"Network\": {\"ID\": \"TestNetwork\", \"AnticipatedChannelPreference\": [{ \"Class\": 1, \"ChannelList\": [1,6,11] }]}} } }", key = "SetAnticipatedChannelPreference", num pointer = valid address | API return value is 0 and ASSERT_NE(subdoc, nullptr) passes | Should Pass |
 * | 02 | Invoke decode_config with JSON template for "ChannelScanRequest" | input: subdoc->buff = "{ \"wfa-dataelements:ChannelScanRequest\": {\"Network\": {\"ID\": \"TestNetwork\", \"ChannelScanParameters\": [{ \"Class\": 1, \"ChannelList\": [1,6,11] }]}} } }", key = "ChannelScanRequest", num pointer = valid address | API return value is 0 and EXPECT_EQ(ret, 0) passes | Should Pass |
 * | 03 | Invoke decode_config with JSON template for "SetPolicy" | input: subdoc->buff = "{ \"wfa-dataelements:SetPolicy\": {\"Network\": {\"ID\": \"TestNetwork\", \"DeviceList\": [{ \"ID\": \"AA:BB:CC:DD:EE:FF\", \"Policy\": { \"AP Metrics Reporting Policy\": {} }}]}} } }", key = "SetPolicy", num pointer = valid address | API return value is 0 and EXPECT_EQ(ret, 0) passes | Should Pass |
 * | 04 | Invoke decode_config with JSON template for "RadioEnable" | input: subdoc->buff = "{ \"wfa-dataelements:RadioEnable\": {\"Network\": {\"ID\": \"TestNetwork\", \"DeviceList\": [{ \"ID\": \"AA:BB:CC:DD:EE:FF\", \"RadioList\": [{ \"ID\": \"Radio1\", \"Enable\": true }]}]}} } }", key = "RadioEnable", num pointer = valid address | API return value is 0 and EXPECT_EQ(ret, 0) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_supported_routing)
{
    std::cout << "Entering decode_config_supported_routing test\n";
    dm_easy_mesh_t obj;
    unsigned int num = 0;
    const char *supported_keys[] = {
        "SetAnticipatedChannelPreference",
        "ChannelScanRequest",
        "SetPolicy",
        "RadioEnable"
    };

    const char *json_templates[] = {

    // SetAnticipatedChannelPreference
    "{ \"wfa-dataelements:SetAnticipatedChannelPreference\": {"
    "  \"Network\": {"
    "    \"ID\": \"TestNetwork\","
    "    \"AnticipatedChannelPreference\": ["
    "      { \"Class\": 1, \"ChannelList\": [1,6,11] }"
    "    ]"
    "  }"
    "} }",

    // ChannelScanRequest
    "{ \"wfa-dataelements:ChannelScanRequest\": {"
    "  \"Network\": {"
    "    \"ID\": \"TestNetwork\","
    "    \"ChannelScanParameters\": ["
    "      { \"Class\": 1, \"ChannelList\": [1,6,11] }"
    "    ]"
    "  }"
    "} }",

    // SetPolicy
    "{ \"wfa-dataelements:SetPolicy\": {"
    "  \"Network\": {"
    "    \"ID\": \"TestNetwork\","
    "    \"DeviceList\": ["
    "      { \"ID\": \"AA:BB:CC:DD:EE:FF\","
    "        \"Policy\": { \"AP Metrics Reporting Policy\": {} }"
    "      }"
    "    ]"
    "  }"
    "} }",

    // RadioEnable
    "{ \"wfa-dataelements:RadioEnable\": {"
    "  \"Network\": {"
    "    \"ID\": \"TestNetwork\","
    "    \"DeviceList\": ["
    "      { \"ID\": \"AA:BB:CC:DD:EE:FF\","
    "        \"RadioList\": ["
    "          { \"ID\": \"Radio1\", \"Enable\": true }"
    "        ]"
    "      }"
    "    ]"
    "  }"
    "} }"
    };

    constexpr size_t key_count = sizeof(supported_keys) / sizeof(supported_keys[0]);
    for (size_t i = 0; i < key_count; ++i) {
        size_t len = strlen(json_templates[i]) + 1;
        em_subdoc_info_t *subdoc =
            static_cast<em_subdoc_info_t*>(
                calloc(1, sizeof(em_subdoc_info_t) + len)
            );
        ASSERT_NE(subdoc, nullptr);
        memcpy(subdoc->buff, json_templates[i], len);
        std::cout << "Invoking decode_config with key: " << supported_keys[i] << "\n";
        int ret = obj.decode_config(subdoc, supported_keys[i], 0, &num);
        EXPECT_EQ(ret, 0) << "Failed on key: " << supported_keys[i];
        free(subdoc);
    }
    std::cout << "Exiting decode_config_supported_routing test\n";
}

/**
 * @brief Verify that decode_config function returns an error when invoked with an unsupported key
 *
 * This test verifies that when the decode_config function is called with an unsupported configuration key ("Config"),
 * it returns an error code of -1. The test ensures that the function properly identifies unsupported keys and handles the error case.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 058@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                      | Test Data                                                    | Expected Result                                               | Notes      |
 * | :--------------: | ---------------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------- | ---------- |
 * | 01               | Invoke decode_config with unsupported key using provided pointers  | subdoc pointer = address of default subdoc, key = "Config", flag = 0, num pointer = address of num | Return value should be -1 with EXPECT_EQ(ret, -1) check          | Should Pass|
 */
TEST(dm_easy_mesh_t, decode_config_unsupported_key)
{
    std::cout << "Entering decode_config_unsupported_key test" << std::endl;
    dm_easy_mesh_t obj;
    em_subdoc_info_t subdoc{};
    unsigned int num = 0;
    std::cout << "Invoking decode_config with unsupported key"<< std::endl;
    int ret = obj.decode_config(&subdoc, "Config", 0, &num);
    EXPECT_EQ(ret, -1);
    std::cout << "Exiting decode_config_unsupported_key test" << std::endl;
}

/**
 * @brief Validate decode_config method behavior when provided a NULL subdocument.
 *
 * This test verifies that the decode_config function correctly handles a NULL subdocument by returning a negative error value and ensuring robust error handling in the system.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 059@n
 * **Priority:** High@n
 * @n
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * @n
 * **Test Procedure:**@n
 * | Variation / Step | Description                                             | Test Data                                                      | Expected Result                                           | Notes       |
 * | :--------------: | ------------------------------------------------------- | -------------------------------------------------------------- | --------------------------------------------------------- | ----------- |
 * | 01               | Calling decode_config with a NULL subdocument pointer   | input: subdoc = NULL, key = "SetSSID", index = 0, output: num pointer | Returns a negative value and assertion EXPECT_LT(ret, 0) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_null_subdoc) {
    std::cout << "Entering decode_config_null_subdoc test" << std::endl;
    std::cout << "Invoking decode_config with subdoc: NULL, key: " << "Config" << ", index: 0" << std::endl;
    dm_easy_mesh_t obj;
    unsigned int num = 0;
    int ret = obj.decode_config(NULL, "SetSSID", 0, &num);
    std::cout << "Returned value: " << ret << std::endl;
    EXPECT_LT(ret, 0);
    std::cout << "Exiting decode_config_null_subdoc test" << std::endl;
}

/**
 * @brief Validate that decode_config returns an error when provided with a null key
 *
 * This test verifies that the decode_config method of dm_easy_mesh_t correctly handles a null key input.
 * When the key is null, the method is expected to return a negative value to indicate an error condition.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 060@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                       | Test Data                                                                            | Expected Result                             | Notes         |
 * | :--------------: | ----------------------------------------------------------------- | ------------------------------------------------------------------------------------ | ------------------------------------------- | ------------- |
 * | 01               | Initialize dm_easy_mesh_t object, subdoc and num variable           | dm_easy_mesh_t obj, em_subdoc_info_t subdoc = {} , num = 0                             | Objects are initialized without error       | Should be successful |
 * | 02               | Invoke decode_config with a null key                              | input: subdoc = {}, key = NULL, size = 0, num pointer = &num                           | Function returns a value less than 0          | Should Fail   |
 * | 03               | Validate the return value using assertion EXPECT_LT(ret, 0)         | output: ret from decode_config                                                        | ret is less than 0, confirming error handling | Should be successful |
 */
TEST(dm_easy_mesh_t, decode_config_null_key) {
    std::cout << "Entering decode_config_null_key test" << std::endl;
    dm_easy_mesh_t obj;
    em_subdoc_info_t subdoc{};
    unsigned int num = 0;
    std::cout << "Invoking decode_config with null key" << std::endl;
    int ret = obj.decode_config(&subdoc, NULL, 0, &num);
    std::cout << "Returned value: " << ret << std::endl;
    EXPECT_LT(ret, 0);
    std::cout << "Exiting decode_config_null_key test" << std::endl;
}

/**
 * @brief Validate decode_config API behavior when num pointer is null.
 *
 * This test verifies that the decode_config method returns an error code (-1) when a null pointer is passed for the num parameter. It ensures that the API correctly handles a null pointer scenario as a negative case.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 061@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                             | Test Data                                                                                  | Expected Result                                      | Notes           |
 * | :--------------: | ------------------------------------------------------- | ------------------------------------------------------------------------------------------ | ---------------------------------------------------- | --------------- |
 * | 01               | Instantiate dm_easy_mesh_t object and subdoc structure  | N/A                                                                                        | Object and subdoc instance should be initialized     | Should be successful |
 * | 02               | Call decode_config with a null num pointer              | input: subdoc = valid structure, config key = "SetSSID", num = 0, num pointer = nullptr, output: ret = -1 | API returns -1 and assertion passes                  | Should Pass     |
 */
TEST(dm_easy_mesh_t, decode_config_num_pointer_null)
{
    std::cout << "Entering decode_config_num_pointer_null test" << std::endl;
    dm_easy_mesh_t obj;
    em_subdoc_info_t subdoc{};
    std::cout << "Invoking decode_config with null num pointer" << std::endl;
    int ret = obj.decode_config(&subdoc, "SetSSID", 0, nullptr);
    std::cout << "Returned value: " << ret << std::endl;
    EXPECT_EQ(ret, -1);
    std::cout << "Exiting decode_config_num_pointer_null test" << std::endl;
}

/**
 * @brief Validate the decoding of a configuration operation class array using a valid configuration and valid MAC address.
 *
 * This test verifies that the decode_config_op_class_array API correctly processes a valid JSON configuration array and a valid MAC address. The test ensures the function returns 0 indicating successful decoding, which is confirmed by the EXPECT_EQ assertion.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 062@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke decode_config_op_class_array with a valid JSON array containing an object, using em_op_class_type_current and a valid MAC address | arr: JSON array with one object, op_class_type: em_op_class_type_current, mac: {0,1,2,3,4,5} | The API returns 0 and the EXPECT_EQ assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_op_class_array_valid_configuration_op_class_array_with_valid_mac) {
    std::cout << "Entering decode_config_op_class_array_valid_configuration_op_class_array_with_valid_mac test" << std::endl;
    cJSON *arr = cJSON_CreateArray();
    cJSON_AddItemToArray(arr, cJSON_CreateObject());
    unsigned char mac[6] = {0,1,2,3,4,5};
    dm_easy_mesh_t obj;
	std::cout << "Invoking decode_config with valid arguments" << std::endl;
    EXPECT_EQ(obj.decode_config_op_class_array(arr, em_op_class_type_current, mac), 0);
    cJSON_Delete(arr);
    std::cout << "Exiting decode_config_op_class_array_valid_configuration_op_class_array_with_valid_mac test" << std::endl;
}

/**
 * @brief Validate behavior of decode_config_op_class_array with a null JSON array pointer.
 *
 * This test verifies that the decode_config_op_class_array method returns the error code -1 when invoked with a NULL pointer for the JSON array, ensuring the method handles invalid json array pointers correctly.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 063@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                          | Test Data                                                             | Expected Result                                       | Notes       |
 * | :--------------: | ------------------------------------------------------------------------------------ | --------------------------------------------------------------------- | ----------------------------------------------------- | ----------- |
 * | 01               | Invoke decode_config_op_class_array with arr_obj set to NULL for invalid JSON pointer | arr_obj = nullptr, type = em_op_class_type_current, mac = 0,1,2,3,4,5 | Expected return value is -1 with assertion EXPECT_EQ(ret, -1) | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_op_class_array_null_json_array_pointer) {
    std::cout << "Entering decode_config_op_class_array_null_json_array_pointer test" << std::endl;
    unsigned char mac[6] = {0,1,2,3,4,5};
    dm_easy_mesh_t obj;
    std::cout << "Invoking decode_config_op_class_array with arr_obj = NULL, type = em_op_class_type_current and MAC = ";
    for (int i = 0; i < 6; i++) {
        std::cout << std::hex << static_cast<int>(mac[i]) << " ";
    }
    std::cout << std::dec << std::endl;    
    int ret = obj.decode_config_op_class_array(nullptr, em_op_class_type_current, mac);
    std::cout << "Method returned: " << ret << std::endl;
    EXPECT_EQ(ret, -1);
    std::cout << "Exiting decode_config_op_class_array_null_json_array_pointer test" << std::endl;
}

/**
 * @brief Validate that decode_config_op_class_array returns error when provided with a NULL MAC pointer
 *
 * This test case verifies that the decode_config_op_class_array API of the dm_easy_mesh_t class handles a NULL MAC pointer correctly
 * by returning an error code (-1). The test prepares a valid JSON array with at least one JSON object, then invokes the API with 
 * a valid array, a capability type, and a NULL MAC pointer. The expected outcome is that the API gracefully handles the NULL pointer and
 * returns -1.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 064@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                                                     | Test Data                                                                                                  | Expected Result                                                         | Notes          |
 * | :--------------: | ------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- | -------------- |
 * |01                | Create a valid JSON array and add a JSON object item                                                                            | arr = cJSON_CreateArray, appended item = cJSON_CreateObject                                               | JSON array is created with the object item successfully                 | Should be successful |
 * |02                | Invoke decode_config_op_class_array with the given JSON array, type = em_op_class_type_capability, and MAC pointer = NULL         | arr pointer = arr, type = em_op_class_type_capability, MAC pointer = nullptr                                 | API returns -1 and assertion (EXPECT_EQ) confirms the expected error code | Should Pass    |
 */
TEST(dm_easy_mesh_t, decode_config_op_class_array_null_mac_pointer) {
    std::cout << "Entering decode_config_op_class_array_null_mac_pointer test" << std::endl;
    cJSON *arr = cJSON_CreateArray();
    cJSON_AddItemToArray(arr, cJSON_CreateObject());
    dm_easy_mesh_t obj;
    std::cout << "Invoking decode_config_op_class_array with valid arr_obj, type = em_op_class_type_capability and MAC = NULL" << std::endl;
    int ret = obj.decode_config_op_class_array(arr, em_op_class_type_capability, nullptr);
    std::cout << "Method returned: " << ret << std::endl;
    EXPECT_EQ(ret, -1);
    cJSON_Delete(arr);
    std::cout << "Exiting decode_config_op_class_array_null_mac_pointer test" << std::endl;
}

/**
 * @brief Test the decode_config_op_class_array API with an empty array to validate correct handling of no input data.
 *
 * This test verifies that when decode_config_op_class_array is provided with an empty JSON array,
 * together with a valid MAC address and operation class type, it correctly processes the input without errors
 * and returns a success status indicated by 0.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 065@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                     | Test Data                                          | Expected Result                                                       | Notes      |
 * | :--------------: | ----------------------------------------------------------------------------------------------- | -------------------------------------------------- | --------------------------------------------------------------------- | ---------- |
 * | 01               | Invoke decode_config_op_class_array with an empty cJSON array and a valid MAC address              | arr = empty JSON array, em_op_class_type_current, mac = [1,2,3,4,5,6] | Return value is 0, verifying that the API handles empty input successfully | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_op_class_array_empty_array)
{
	std::cout << "Entering decode_config_op_class_array_empty_array test" << std::endl;
    cJSON *arr = cJSON_CreateArray();
    unsigned char mac[6] = {1,2,3,4,5,6};
    dm_easy_mesh_t obj;
	std::cout << "Invoking decode_config_op_class_array with empty array" << std::endl;
    EXPECT_EQ(obj.decode_config_op_class_array(arr, em_op_class_type_current, mac), 0);
    cJSON_Delete(arr);
	std::cout << "Exiting decode_config_op_class_array_empty_array test" << std::endl;
}

/**
 * @brief Validate decode_config_op_class_array with a non-array JSON input.
 *
 * This test verifies that the decode_config_op_class_array function correctly returns 0 when provided with a non-array JSON object.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 066@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                             | Test Data                                                                                          | Expected Result                                           | Notes      |
 * | :--------------: | ----------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | --------------------------------------------------------- | ---------- |
 * | 01               | Invoke decode_config_op_class_array with a non-array JSON object          | obj_json = non-array JSON object created via cJSON_CreateObject(), em_op_class_type_current, mac = {6,5,4,3,2,1} | Function returns 0 and EXPECT_EQ assertion passes         | Should Pass|
 */
TEST(dm_easy_mesh_t, decode_config_op_class_array_non_array)
{
	std::cout << "Entering decode_config_op_class_array_non_array test" << std::endl;
    cJSON *obj_json = cJSON_CreateObject();
    unsigned char mac[6] = {6,5,4,3,2,1};
    dm_easy_mesh_t obj;
	std::cout << "Invoking decode_config_op_class_array with non-array" << std::endl;
    EXPECT_EQ(obj.decode_config_op_class_array(obj_json, em_op_class_type_current, mac), 0);
    cJSON_Delete(obj_json);
	std::cout << "Exiting decode_config_op_class_array_non_array test" << std::endl;
}

/**
 * @brief Test decoding configuration operation class array with invalid child items.
 *
 * This test constructs a JSON array containing an invalid child object and attempts
 * to decode it using the decode_config_op_class_array API. It verifies that the API
 * handles invalid child items gracefully by returning 0.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 067@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create a JSON array with one invalid child object, initialize MAC address, and call decode_config_op_class_array API | arr = JSON Array with invalid child object, invalid_child = JSON Object, mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF}, op_class_type = em_op_class_type_current | API returns 0 confirming invalid input handling; assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_op_class_array_json_array_with_invalid_child_items) {
    std::cout << "Entering decode_config_op_class_array_json_array_with_invalid_child_items test" << std::endl;
    cJSON *arr = cJSON_CreateArray();
    cJSON *invalid_child = cJSON_CreateObject();
    cJSON_AddItemToArray(arr, invalid_child);
    unsigned char mac[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    dm_easy_mesh_t obj;
    std::cout << "Invoking decode_config_op_class_array with  invalid child items" << std::endl;
    EXPECT_EQ(obj.decode_config_op_class_array(arr, em_op_class_type_current, mac), 0);
    cJSON_Delete(arr);
    std::cout << "Exiting decode_config_op_class_array_json_array_with_invalid_child_items test" << std::endl;
}

/**
 * @brief Test to validate that the decode_config_op_class_array method correctly processes a JSON array with extra entries.
 *
 * This test verifies that the decode_config_op_class_array API correctly handles a JSON array that contains valid configuration objects along with extra, irrelevant entries. The test checks that the function returns the expected success code (0) when the JSON array includes additional non-critical data.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 068@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                     | Test Data                                                                                                                             | Expected Result                   | Notes      |
 * | :--------------: | ----------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------- | ---------- |
 * | 01               | Create a JSON array with a valid object and an extra string entry, then call the API function.    | arr = JSON array containing {object, string("irrelevant")}, em_op_class_type_scan_param, mac = [0x10,0x20,0x30,0x40,0x50,0x60]         | Return value from the API = 0     | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_op_class_array_valid_json_array_extra_entries) {
    std::cout << "Entering decode_config_op_class_array_valid_json_array_extra_entries test" << std::endl;
    cJSON *arr = cJSON_CreateArray();
    cJSON_AddItemToArray(arr, cJSON_CreateObject());
    cJSON_AddItemToArray(arr, cJSON_CreateString("irrelevant"));
    unsigned char mac[6] = {0x10,0x20,0x30,0x40,0x50,0x60};
    dm_easy_mesh_t obj;
    EXPECT_EQ(obj.decode_config_op_class_array(arr, em_op_class_type_scan_param, mac), 0);
    cJSON_Delete(arr);
    std::cout << "Exiting decode_config_op_class_array_valid_json_array_extra_entries test" << std::endl;
}

/**
 * @brief Verify decode_config_reset correctly processes a valid configuration with matching top-level key.
 *
 * This test ensures that the decode_config_reset API successfully decodes a JSON configuration when provided with a matching top-level key ("reset"), including proper parsing of the interfaces and network SSID list. It confirms that the API returns 0 when invoked with valid arguments.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 069@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke decode_config_reset with valid configuration JSON having matching top-level key "reset". | subdoc.buff = "{\"reset\": {\"Interfaces\": {}, \"NetworkSSIDList\": [{ \"SSID\": \"TestSSID\" }]}}", key = "reset" | Return value 0 indicating successful decoding and assertion success | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_reset_valid_configuration_with_matching_top_level_key)
{
    std::cout << "Entering decode_config_reset_valid_configuration_with_matching_top_level_key\n";
    dm_easy_mesh_t easyMesh;
    const char jsonString[] =
        "{"
        "  \"reset\": {"
        "    \"Interfaces\": {},"
        "    \"NetworkSSIDList\": [ { \"SSID\": \"TestSSID\" } ]"
        "  }"
        "}";
    em_subdoc_info_t subdoc{};
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", jsonString);
    std::cout << "Invoking decode_config_reset with valid arguments\n";
    int ret = easyMesh.decode_config_reset(&subdoc, "reset");
    EXPECT_EQ(ret, 0);
    std::cout << "Exiting decode_config_reset_valid_configuration_with_matching_top_level_key\n";
}

/**
 * @brief Validate that decode_config_reset returns an error when provided with a JSON configuration containing a mismatching top level key.
 *
 * This test verifies that the decode_config_reset API correctly identifies a configuration error when the JSON provided does not contain the expected top level key. The test ensures that the function returns -1 in such a scenario, thereby preventing invalid configuration resets.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 070@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * |01| Initialize dm_easy_mesh_t instance and prepare JSON string with mismatching top level key | input: dm_easy_mesh_t instance initialized, jsonString = "{\"config\": {\"Interfaces\": {}, \"NetworkSSIDList\": [ { \"SSID\": \"TestSSID\" } ]}}" | Instance initialized; jsonString assigned properly | Should be successful |
 * |02| Invoke decode_config_reset with the subdoc containing JSON and the incorrect key "reset" | input1: subdoc.buff contains the JSON string, input2: key = "reset", expected return = -1 | decode_config_reset returns -1 | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_reset_valid_configuration_mismatching_top_level_key)
{
    std::cout << "Entering decode_config_reset_valid_configuration_mismatching_top_level_key\n";
    dm_easy_mesh_t easyMesh;
    const char jsonString[] =
        "{"
        "  \"config\": {"
        "    \"Interfaces\": {},"
        "    \"NetworkSSIDList\": [ { \"SSID\": \"TestSSID\" } ]"
        "  }"
        "}";
    em_subdoc_info_t subdoc{};
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", jsonString);
    std::cout << "Invoking decode_config_reset with mismatching top level key\n";
    int ret = easyMesh.decode_config_reset(&subdoc, "reset");
    EXPECT_EQ(ret, -1);
    std::cout << "Exiting decode_config_reset_valid_configuration_mismatching_top_level_key\n";
}

/**
 * @brief Test the decode_config_reset API with empty JSON content
 *
 * This test verifies that the API function decode_config_reset correctly handles 
 * an empty JSON configuration (subdoc.buff with an empty string) and returns an error code (-1). 
 * It ensures that the API behaves as expected when provided with invalid input.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 071@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                 | Test Data                                                           | Expected Result                      | Notes            |
 * | :--------------: | ----------------------------------------------------------- | ------------------------------------------------------------------- | ------------------------------------ | ---------------- |
 * | 01               | Initialize dm_easy_mesh_t instance                          | None                                                                | Instance created successfully        | Should be successful |
 * | 02               | Prepare em_subdoc_info_t with empty buffer                  | subdoc.buff[0] = '\0'                                                 | subdoc is empty                      | Should be successful |
 * | 03               | Invoke decode_config_reset API with empty JSON content      | input: subdoc pointer (empty), second argument = "reset"            | API call returns -1                  | Should Fail      |
 * | 04               | Verify that the returned error code equals -1 using EXPECT_EQ | output: ret = -1                                                    | Assertion passes if ret equals -1    | Should be successful |
 */
TEST(dm_easy_mesh_t, decode_config_reset_empty_json_content)
{
    std::cout << "Entering decode_config_reset_empty_json_content\n";
    dm_easy_mesh_t easyMesh;
    em_subdoc_info_t subdoc{};
    subdoc.buff[0] = '\0';
    std::cout << "Invoking decode_config_reset with empty subdoc.name" << std::endl;
    int ret = easyMesh.decode_config_reset(&subdoc, "reset");
    EXPECT_EQ(ret, -1);
    std::cout << "Exiting decode_config_reset_empty_json_content\n";
}

/**
 * @brief Verify that decode_config_reset returns an error code when configuration JSON content is malformed.
 *
 * This test verifies that when the decode_config_reset API is invoked with a malformed JSON string, it returns an error (-1) to indicate the failure in parsing the JSON. The test ensures proper handling of erroneous input.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 072@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                | Test Data                                                        | Expected Result               | Notes      |
 * | :--------------: | ------------------------------------------------------------------------------------------ | ---------------------------------------------------------------- | ----------------------------- | ---------- |
 * | 01               | Invoke decode_config_reset with subdoc containing malformed JSON string and key "reset".   | subdoc.buff = { "reset": { , key = "reset"                        | Return value -1 with assertion | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_config_reset_malformed_json_content)
{
    std::cout << "Entering decode_config_reset_malformed_json_content\n";
    dm_easy_mesh_t easyMesh;
    const char jsonString[] = "{ \"reset\": { ";
    em_subdoc_info_t subdoc{};
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", jsonString);
    std::cout << "Invoking decode_config_reset with malformed json content\n";
    int ret = easyMesh.decode_config_reset(&subdoc, "reset");
    EXPECT_EQ(ret, -1);
    std::cout << "Exiting decode_config_reset_malformed_json_content\n";
}

/**
 * @brief Verify that decode_config_reset returns an error when a NULL subdocument pointer is provided
 *
 * This test case ensures that the decode_config_reset method of dm_easy_mesh_t correctly handles a NULL subdocument pointer. 
 * The function is expected to return a negative value when invoked with a NULL subdoc and a valid key, indicating an error.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 073@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                         | Test Data                                    | Expected Result                                 | Notes        |
 * | :--------------: | ------------------------------------------------------------------- | -------------------------------------------- | ----------------------------------------------- | ------------ |
 * | 01               | Invoke decode_config_reset with a NULL subdocument pointer and key "reset" | subdoc = NULL, key = reset                    | Return value < 0; Assertion EXPECT_LT(ret, 0)   | Should Pass  |
 */
TEST(dm_easy_mesh_t, decode_config_reset_null_subdoc_pointer)
{
    const char* testName = "decode_config_reset_null_subdoc_pointer";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t easyMesh;
    const char* key = "reset";
    std::cout << "Invoking decode_config_reset with subdoc: NULL and key: " << key << std::endl;
    int ret = easyMesh.decode_config_reset(NULL, key);
    std::cout << "Method returned: " << ret << std::endl;
    EXPECT_LT(ret, 0);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verifies the behavior of decode_config_reset when provided a null key pointer.
 *
 * This test ensures that the decode_config_reset function returns a negative error code when invoked with a valid JSON configuration but with a null key pointer. The objective is to confirm that the API handles invalid pointer inputs gracefully, preventing further processing of incomplete configuration data.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 074@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | -------------- | ----- |
 * | 01 | Initialize a JSON string for reset configuration and call decode_config_reset with a NULL key pointer. | subdoc.buff = "{ \"reset\": { \"Interfaces\": {}, \"NetworkSSIDList\": [ { \"SSID\": \"TestSSID\" } ] } }", key pointer = nullptr | Return value should be negative (< 0) indicating an error due to the null key pointer. | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_config_reset_null_key_pointer)
{
    const char* testName = "decode_config_reset_null_key_pointer";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t easyMesh;
    const char jsonString[] =
        "{"
        "  \"reset\": {"
        "    \"Interfaces\": {},"
        "    \"NetworkSSIDList\": [ { \"SSID\": \"TestSSID\" } ]"
        "  }"
        "}";
    em_subdoc_info_t subdoc{};
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", jsonString);
    std::cout << "Invoking decode_config_reset with key: NULL" << std::endl;
    int ret = easyMesh.decode_config_reset(&subdoc, nullptr);
    std::cout << "Method returned: " << ret << std::endl;
    EXPECT_LT(ret, 0);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that decode_config_set_channel correctly decodes anticipated channel configuration with valid input.
 *
 * This test validates that the decode_config_set_channel API correctly processes a valid JSON configuration containing anticipated channel preferences.
 * It ensures that the function returns a status of 0 and that the output parameter (num) is set to 0 when provided with a valid anticipated channel configuration.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 075@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                             | Test Data                                                                                                                                                                              | Expected Result                                      | Notes          |
 * | :--------------: | ------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- | -------------- |
 * | 01               | Initialize dm_easy_mesh_t object and subdoc structure; print entering message                           | None                                                                                                                                                                                   | Objects initialized and entering message printed   | Should be successful  |
 * | 02               | Setup JSON string in subdoc.buff for anticipated channel configuration                                  | json = "{ \"wfa-dataelements:SetAnticipatedChannelPreference\": { \"Network\": { \"ID\": \"TestNet\", \"AnticipatedChannelPreference\": [{ \"Class\": 81, \"ChannelList\": [1, 6, 11] }] } } }" | subdoc.buff correctly assigned the JSON configuration | Should be successful  |
 * | 03               | Invoke decode_config_set_channel API with valid input parameters                                        | subdoc (with valid JSON), key = "wfa-dataelements:SetAnticipatedChannelPreference", offset = 0, num pointer                                                     | API returns 0 and updates num to 0                   | Should Pass    |
 * | 04               | Assert that the return value and output parameter (num) are as expected                                   | ret = 0, num = 0                                                                                                                                                                       | EXPECT_EQ(ret, 0) and EXPECT_EQ(num, 0)               | Should Pass    |
 */
TEST(dm_easy_mesh_t, decode_config_set_channel_valid_anticipated)
{
    std::cout << "Entering decode_config_set_channel_valid_anticipated\n";
    dm_easy_mesh_t obj;
    em_subdoc_info_t subdoc{};
    const char json[] =
        "{"
        " \"wfa-dataelements:SetAnticipatedChannelPreference\": {"
        "   \"Network\": {"
        "     \"ID\": \"TestNet\","
        "     \"AnticipatedChannelPreference\": ["
        "       {"
        "         \"Class\": 81,"
        "         \"ChannelList\": [1, 6, 11]"
        "       }"
        "     ]"
        "   }"
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    unsigned int num = 0;
    std::cout << "Invoking decode_config_set_channel with valid arguments\n";
    int ret = obj.decode_config_set_channel(
        &subdoc,
        "wfa-dataelements:SetAnticipatedChannelPreference",
        0,
        &num
    );
    EXPECT_EQ(ret, 0);
    EXPECT_EQ(num, 0);
    std::cout << "Exiting decode_config_set_channel_valid_anticipated\n";
}

/**
 * @brief Verify that decode_config_set_channel handles empty key input properly
 *
 * This test checks that when decode_config_set_channel is invoked with an empty key, the function returns a negative value indicating an error. This scenario is critical to ensure that invalid or missing configuration parameters are correctly detected and handled.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 076@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                     | Test Data                                                                           | Expected Result                                                   | Notes          |
 * | :--------------: | ------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- | ----------------------------------------------------------------- | -------------- |
 * | 01               | Initialize the dm_easy_mesh_t instance and prepare the subdoc with an empty JSON | json = "{}", subdoc.buff = "{}"                                                      | subdoc is correctly initialized with the empty JSON configuration | Should be successful |
 * | 02               | Invoke decode_config_set_channel with an empty key and verify the error response  | subdoc pointer = address of subdoc, key = "", channel = 0, num pointer = address of num | Return value is less than 0 indicating an error in processing the empty key | Should Fail    |
 */
TEST(dm_easy_mesh_t, decode_config_set_channel_empty_key)
{
    std::cout << "Entering decode_config_set_channel_empty_key\n";
    dm_easy_mesh_t obj;
    em_subdoc_info_t subdoc{};
    const char json[] = "{}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    unsigned int num = 0;
    std::cout << "Invoking decode_config_set_channel with empty key\n";
    int ret = obj.decode_config_set_channel(&subdoc, "", 0, &num);
    EXPECT_LT(ret, 0);
    std::cout << "Exiting decode_config_set_channel_empty_key\n";
}

/**
 * @brief Verify that decode_config_set_channel returns an error for malformed JSON input
 *
 * This test verifies that when decode_config_set_channel is invoked with a malformed JSON string,
 * the function correctly identifies the error and returns the EM_PARSE_ERR_GEN error code.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 077@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                | Test Data                                                                                                                       | Expected Result                                | Notes         |
 * | :--------------: | -------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------- | ------------- |
 * | 01               | Initialize the test object and sub-document structure                      | No specific data required                                                                                                       | Object and subdoc are successfully created     | Should be successful |
 * | 02               | Set a malformed JSON string into the sub-document buffer                   | json = "{ \"wfa-dataelements:SetAnticipatedChannelPreference\": "                                                               | Buffer contains the malformed JSON string      | Should be successful |
 * | 03               | Invoke decode_config_set_channel with the malformed JSON and verify outcome  | subdoc with malformed JSON, key = "wfa-dataelements:SetAnticipatedChannelPreference", flag = 0, num pointer               | Return value equals EM_PARSE_ERR_GEN           | Should Pass   |
 */
TEST(dm_easy_mesh_t, decode_config_set_channel_malformed_json)
{
    std::cout << "Entering decode_config_set_channel_malformed_json\n";
    dm_easy_mesh_t obj;
    em_subdoc_info_t subdoc{};
    const char json[] =
        "{ \"wfa-dataelements:SetAnticipatedChannelPreference\": ";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    unsigned int num = 0;
    std::cout << "Invoking decode_config_set_channel with malformed json\n";
    int ret = obj.decode_config_set_channel(
        &subdoc,
        "wfa-dataelements:SetAnticipatedChannelPreference",
        0,
        &num
    );
    EXPECT_EQ(ret, EM_PARSE_ERR_GEN);
    std::cout << "Exiting decode_config_set_channel_malformed_json\n";
}

/**
 * @brief Validate decode_config_set_channel behavior when the network id is missing
 *
 * This test verifies that the decode_config_set_channel API properly detects a missing network id in the input JSON configuration and returns the error code EM_PARSE_ERR_NET_ID as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 078@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                     | Test Data                                                                                                                       | Expected Result                                 | Notes       |
 * | :--------------: | ----------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------- | ----------- |
 * | 01               | Initialize dm_easy_mesh_t instance and set up JSON with missing network id field                 | input: json = "{ \"wfa-dataelements:ChannelScanRequest\": { \"Network\": { \"ChannelScanParameters\": [ { \"Class\": 81, \"ChannelList\": [36, 40] } ] } } }", subdoc.buff copied using snprintf, API parameters: "wfa-dataelements:ChannelScanRequest", network id = 0, num pointer provided | API returns error code EM_PARSE_ERR_NET_ID after invoking decode_config_set_channel | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_set_channel_missing_network_id)
{
    std::cout << "Entering decode_config_set_channel_missing_network_id\n";
    dm_easy_mesh_t obj;
    em_subdoc_info_t subdoc{};
    const char json[] =
        "{"
        " \"wfa-dataelements:ChannelScanRequest\": {"
        "   \"Network\": {"
        "     \"ChannelScanParameters\": ["
        "       { \"Class\": 81, \"ChannelList\": [36, 40] }"
        "     ]"
        "   }"
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    unsigned int num = 0;
    std::cout << "Invoking decode_config_set_channel with missing network id\n";
    int ret = obj.decode_config_set_channel(
        &subdoc,
        "wfa-dataelements:ChannelScanRequest",
        0,
        &num
    );
    EXPECT_EQ(ret, EM_PARSE_ERR_NET_ID);
    std::cout << "Exiting decode_config_set_channel_missing_network_id\n";
}

/**
 * @brief Test to verify that decode_config_set_channel returns an error when provided with a null subdocument pointer
 *
 * This test verifies that the decode_config_set_channel API method correctly handles a null subdocument pointer by returning a negative value, indicating an error in processing.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 079@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke decode_config_set_channel with a null subdocument pointer | subdoc = nullptr, key = "wfa-dataelements:SetAnticipatedChannelPreference", index = 0, &num variable | API returns a negative value indicating an error | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_config_set_channel_null_subdoc)
{
    std::cout << "Entering decode_config_set_channel_null_subdoc test" << std::endl;    
    dm_easy_mesh_t obj;
    em_subdoc_info_t *subdoc = nullptr;
    const char * key = "channel_config";
    unsigned int index = 0;
    unsigned int num = 0;    
    std::cout << "Invoking decode_config_set_channel with subdoc: NULL" << std::endl;
    int ret = obj.decode_config_set_channel(subdoc, "wfa-dataelements:SetAnticipatedChannelPreference", 0, &num);
    std::cout << "Returned value: " << ret << std::endl;
    EXPECT_LT(ret, 0);
    std::cout << "Exiting decode_config_set_channel_null_subdoc test" << std::endl;
}

/**
 * @brief Verify that the decode_config_set_channel API returns an error when provided with a null key.
 *
 * This test verifies that the decode_config_set_channel API correctly handles an input scenario where the key provided is null.
 * The function is expected to return a negative error code when the key is NULL. This is important for ensuring proper error handling
 * in configurations where the anticipated channel set key is missing.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 080@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                 | Test Data                                                                                                                          | Expected Result                                          | Notes        |
 * | :--------------: | --------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------- | ------------ |
 * | 01               | Invoke decode_config_set_channel with subdoc containing JSON data, null key, index = 1, and a pointer for numValue | input: subdoc.buff = "{ \"wfa-dataelements:SetAnticipatedChannelPreference\": { \"Network\": { \"ID\": \"TestNet\", \"AnticipatedChannelPreference\": [ { \"Class\": 81, \"ChannelList\": [1, 6, 11] } ] } } }", key = nullptr, index = 1, numValue = 0 | Return value should be less than 0, satisfying EXPECT_LT(ret, 0) | Should Fail  |
 */
TEST(dm_easy_mesh_t, decode_config_set_channel_null_key)
{
    std::cout << "Entering decode_config_set_channel_null_key test" << std::endl;    
    dm_easy_mesh_t obj;
	em_subdoc_info_t subdoc{};
    const char json[] =
        "{"
        " \"wfa-dataelements:SetAnticipatedChannelPreference\": {"
        "   \"Network\": {"
        "     \"ID\": \"TestNet\","
        "     \"AnticipatedChannelPreference\": ["
        "       {"
        "         \"Class\": 81,"
        "         \"ChannelList\": [1, 6, 11]"
        "       }"
        "     ]"
        "   }"
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    const char * key = nullptr;
    unsigned int index = 1;
    unsigned int numValue = 0;    
    std::cout << "Invoking decode_config_set_channel with key: NULL, index: " << index << std::endl;
    int ret = obj.decode_config_set_channel(&subdoc, key, index, &numValue);
    std::cout << "Returned value: " << ret << std::endl;
    EXPECT_LT(ret, 0);
    std::cout << "Exiting decode_config_set_channel_null_key test" << std::endl;
}

/**
 * @brief Verify that decode_config_set_channel returns an error when the num pointer is null
 *
 * This test verifies that the decode_config_set_channel API correctly handles a null pointer for the num parameter
 * by returning a negative error value. The test constructs a valid JSON subdocument, invokes the API with a valid key
 * and index while explicitly passing a null pointer for num, and asserts that the returned value is less than zero.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 081@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke decode_config_set_channel with a valid subdoc and a null pointer for numValue | subdoc.buff = "{ \"wfa-dataelements:SetAnticipatedChannelPreference\": { \"Network\": { \"ID\": \"TestNet\", \"AnticipatedChannelPreference\": [{ \"Class\": 81, \"ChannelList\": [1, 6, 11] }] } } }", key = "channel_config", index = 0, numValue = nullptr | Return value should be negative (ret < 0), confirming proper error handling | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_config_set_channel_null_num)
{
    std::cout << "Entering decode_config_set_channel_null_num test" << std::endl;
    dm_easy_mesh_t obj;
    em_subdoc_info_t subdoc{};
    const char json[] =
        "{"
        " \"wfa-dataelements:SetAnticipatedChannelPreference\": {"
        "   \"Network\": {"
        "     \"ID\": \"TestNet\","
        "     \"AnticipatedChannelPreference\": ["
        "       {"
        "         \"Class\": 81,"
        "         \"ChannelList\": [1, 6, 11]"
        "       }"
        "     ]"
        "   }"
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    const char * key = "channel_config";
    unsigned int index = 0;
    unsigned int * numValue = nullptr;
    std::cout << "Invoking decode_config_set_channel with valid subdoc, key: " << key << ", index: " << index << ", num: NULL" << std::endl;    
    int ret = obj.decode_config_set_channel(&subdoc, "wfa-dataelements:SetAnticipatedChannelPreference", index, numValue);    
    std::cout << "Returned value: " << ret << std::endl;    
    EXPECT_LT(ret, 0);    
    std::cout << "Exiting decode_config_set_channel_null_num test" << std::endl;
}

/**
 * @brief Test decode_config_set_policy API with valid configuration number provided
 *
 * This test verifies that the decode_config_set_policy API correctly processes a valid JSON configuration when a valid configuration number is provided. The function is expected to decode the configuration, update the provided numVal to the number of successfully processed configurations, and return 0 indicating success.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 082@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke decode_config_set_policy with a valid JSON configuration string and valid parameters | subdoc.buff = valid JSON config with key "wfa-dataelements:SetPolicy", policy details; name = "wfa-dataelements:SetPolicy", index = 0, numVal pointer | API returns 0 and numVal is set to 1, indicating one valid configuration processed | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_set_policy_valid_config_num_provided)
{
    std::cout << "Entering decode_config_set_policy_valid_config_num_provided\n";
    dm_easy_mesh_t mesh;
    em_subdoc_info_t subdoc{};
    const char json[] =
        "{"
        " \"wfa-dataelements:SetPolicy\": {"
        "   \"Network\": {"
        "     \"ID\": \"TestNet\","
        "     \"DeviceList\": ["
        "       {"
        "         \"ID\": \"AA:BB:CC:DD:EE:FF\","
        "         \"Policy\": {"
        "           \"AP Metrics Reporting Policy\": { \"Interval\": 30 }"
        "         }"
        "       }"
        "     ]"
        "   }"
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    unsigned int numVal = 0;
	std::cout << "Invoking decode_config_set_policy with valid arguments" << std::endl;
    int ret = mesh.decode_config_set_policy(
        &subdoc,
        "wfa-dataelements:SetPolicy",
        0,
        &numVal
    );
    EXPECT_EQ(ret, 0);
    EXPECT_EQ(numVal, 1u);
    std::cout << "Exiting decode_config_set_policy_valid_config_num_provided\n";
}

/**
 * @brief Verify that decode_config_set_policy returns error when provided with an empty key
 *
 * This test case verifies that when the decode_config_set_policy API is invoked with an empty key parameter,
 * it correctly returns the error code "EM_PARSE_ERR_GEN". The test ensures that the function handles invalid input gracefully.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 083@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                 | Test Data                                                           | Expected Result                                                      | Notes       |
 * | :---------------: | ----------------------------------------------------------- | ------------------------------------------------------------------- | -------------------------------------------------------------------- | ----------- |
 * | 01                | Invoke decode_config_set_policy with an empty key parameter | subdoc.buff = "{}", key = "", flag = 0, numVal pointer = valid address | Return value should be EM_PARSE_ERR_GEN and assertion ret == EM_PARSE_ERR_GEN | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_config_set_policy_error_empty_key)
{
    std::cout << "Entering decode_config_set_policy_error_empty_key\n";
    dm_easy_mesh_t mesh;
    em_subdoc_info_t subdoc{};
    snprintf(subdoc.buff, sizeof(subdoc.buff), "{}");
    unsigned int numVal = 0;
	std::cout << "Invoking decode_config_set_policy with empty key" << std::endl;
    int ret = mesh.decode_config_set_policy(&subdoc, "", 0, &numVal);
    EXPECT_EQ(ret, EM_PARSE_ERR_GEN);
    std::cout << "Exiting decode_config_set_policy_error_empty_key\n";
}

/**
 * @brief Verify that decode_config_set_policy returns an error when an invalid index is provided.
 *
 * This test validates the error handling of the decode_config_set_policy API by supplying an invalid index. The function is expected to return an error code (EM_PARSE_ERR_GEN) and update the provided output parameter (numVal) accordingly. The test ensures that the API correctly identifies improper configurations in the JSON document.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 084@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Print entry message and initialize variables | N/A | Console prints "Entering decode_config_set_policy_error_invalid_index"; dm_easy_mesh_t and em_subdoc_info_t are initialized | Should be successful |
 * | 02 | Set subdoc JSON input for API call | json = "{ \"wfa-dataelements:SetPolicy\": { \"Network\": { \"ID\": \"TestNet\", \"DeviceList\": [ { \"ID\": \"AA:BB:CC:DD:EE:FF\", \"Policy\": { \"AP Metrics Reporting Policy\": { \"Interval\": 30 } } } ] } } }" | subdoc.buff is populated with the JSON string | Should be successful |
 * | 03 | Invoke decode_config_set_policy with invalid index | subdoc.buff = json, key = "wfa-dataelements:SetPolicy", index = 1, output parameter numVal initially 0 | API returns EM_PARSE_ERR_GEN and numVal is set to 1 | Should Pass |
 * | 04 | Print exit message | N/A | Console prints "Exiting decode_config_set_policy_error_invalid_index" | Should be successful |
 */
TEST(dm_easy_mesh_t, decode_config_set_policy_error_invalid_index)
{
    std::cout << "Entering decode_config_set_policy_error_invalid_index\n";
    dm_easy_mesh_t mesh;
    em_subdoc_info_t subdoc{};
    const char json[] =
        "{"
        " \"wfa-dataelements:SetPolicy\": {"
        "   \"Network\": {"
        "     \"ID\": \"TestNet\","
        "     \"DeviceList\": ["
        "       {"
        "         \"ID\": \"AA:BB:CC:DD:EE:FF\","
        "         \"Policy\": {"
        "           \"AP Metrics Reporting Policy\": { \"Interval\": 30 }"
        "         }"
        "       }"
        "     ]"
        "   }"
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    unsigned int numVal = 0;
    std::cout << "Invoking decode_config_set_policy with invalid index" << std::endl;
    int ret = mesh.decode_config_set_policy(
        &subdoc,
        "wfa-dataelements:SetPolicy",
        1,
        &numVal
    );
    EXPECT_EQ(ret, EM_PARSE_ERR_GEN);
    EXPECT_EQ(numVal, 1u);
    std::cout << "Exiting decode_config_set_policy_error_invalid_index\n";
}

/**
 * @brief Validate that decode_config_set_policy functions correctly when config_num pointer is null
 *
 * This test evaluates decode_config_set_policy by providing a valid JSON configuration while passing a nullptr for the config_num pointer. The purpose is to ensure that the API correctly handles cases when the configuration number pointer is not provided, and returns the expected value. 
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 085@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize mesh instance and sub-document info, then invoke decode_config_set_policy with valid JSON configuration and num pointer as nullptr | subdoc.buff = "{ \"wfa-dataelements:SetPolicy\": { \"Network\": { \"ID\": \"TestNet\", \"DeviceList\": [ { \"ID\": \"AA:BB:CC:DD:EE:FF\", \"Policy\": { \"AP Metrics Reporting Policy\": { \"Interval\": 30 } } } ] } } }", configName = "wfa-dataelements:SetPolicy", configNum = 0, num = nullptr | Return value equals 0 and assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_set_policy_valid_config_num_null)
{
    std::cout << "Entering decode_config_set_policy_valid_config_num_null test" << std::endl;
    dm_easy_mesh_t mesh;
    em_subdoc_info_t subdoc{};

    const char json[] =
        "{"
        " \"wfa-dataelements:SetPolicy\": {"
        "   \"Network\": {"
        "     \"ID\": \"TestNet\","
        "     \"DeviceList\": ["
        "       {"
        "         \"ID\": \"AA:BB:CC:DD:EE:FF\","
        "         \"Policy\": {"
        "           \"AP Metrics Reporting Policy\": { \"Interval\": 30 }"
        "         }"
        "       }"
        "     ]"
        "   }"
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    std::cout << "Invoking decode_config_set_policy with num pointer as nullptr" << std::endl;
    int retval = mesh.decode_config_set_policy(&subdoc, "wfa-dataelements:SetPolicy", 0, nullptr);
    std::cout << "Returned value: " << retval << std::endl;
    EXPECT_LT(retval, 0);
    std::cout << "Exiting decode_config_set_policy_valid_config_num_null test" << std::endl;
}

/**
 * @brief Verify that decode_config_set_policy returns an error when provided with a null subdoc pointer.
 *
 * This test validates that decode_config_set_policy correctly handles a null pointer input for the subdoc parameter by returning a negative error code. The objective is to ensure that the API is robust against invalid input, maintaining proper error handling.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 086@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                     | Test Data                                                                                   | Expected Result                                                    | Notes       |
 * | :----:           | --------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ | ----------- |
 * | 01               | Invoke decode_config_set_policy with a null subdoc pointer        | subdoc = nullptr, xpath = "wfa-dataelements:SetPolicy", index = 0, numVal = address of numVal | API returns a negative value indicating an error; EXPECT_LT(retval, 0) passes | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_config_set_policy_error_null_subdoc)
{
    std::cout << "Entering decode_config_set_policy_error_null_subdoc test" << std::endl;
    dm_easy_mesh_t mesh;
    unsigned int index = 0;
    unsigned int numVal = 0;
    std::cout << "Invoking decode_config_set_policy with subdoc as nullptr" << std::endl;    
    int retval = mesh.decode_config_set_policy(nullptr, "wfa-dataelements:SetPolicy", index, &numVal);
    std::cout << "Returned value: " << retval << std::endl;    
    EXPECT_LT(retval, 0);    
    std::cout << "Exiting decode_config_set_policy_error_null_subdoc test" << std::endl;
}

/**
 * @brief Validate that decode_config_set_policy returns an error when provided with a null key pointer.
 *
 * This test verifies that the decode_config_set_policy function correctly handles the scenario when the key parameter is null.
 * The test feeds a valid JSON configuration and expects a negative return value, indicating an error due to the null key.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 087@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize JSON string and populate subdoc buffer. | json = "{" " \"wfa-dataelements:SetPolicy\": {" "   \"Network\": {" "     \"ID\": \"TestNet\", " "     \"DeviceList\": [" "       {" "         \"ID\": \"AA:BB:CC:DD:EE:FF\", " "         \"Policy\": {" "           \"AP Metrics Reporting Policy\": { \"Interval\": 30 }" "         }" "       }" "     ]" "   }" " }" "}", subdoc.buff populated via snprintf, numVal = 1 | subdoc.buff is correctly set with the JSON configuration. | Should be successful |
 * | 02 | Invoke decode_config_set_policy with a null key pointer. | input: subdoc pointer = &subdoc, key pointer = nullptr, flags = 0, numVal = 1 | API should return a negative value, and the assertion EXPECT_LT(retval, 0) passes. | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_config_set_policy_error_null_key)
{
    std::cout << "Entering decode_config_set_policy_error_null_key test" << std::endl;
    dm_easy_mesh_t mesh;
    em_subdoc_info_t subdoc{};
    const char json[] =
        "{"
        " \"wfa-dataelements:SetPolicy\": {"
        "   \"Network\": {"
        "     \"ID\": \"TestNet\","
        "     \"DeviceList\": ["
        "       {"
        "         \"ID\": \"AA:BB:CC:DD:EE:FF\","
        "         \"Policy\": {"
        "           \"AP Metrics Reporting Policy\": { \"Interval\": 30 }"
        "         }"
        "       }"
        "     ]"
        "   }"
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    unsigned int numVal = 1;
    int retval = mesh.decode_config_set_policy(&subdoc, nullptr, 0, &numVal);
    std::cout << "Returned value: " << retval << std::endl;
    EXPECT_LT(retval, 0);    
    std::cout << "Exiting decode_config_set_policy_error_null_key test" << std::endl;
}

/**
 * @brief Validate the decode_config_set_radio API for correctly decoding a JSON with one valid radio configuration
 *
 * This test verifies that the decode_config_set_radio function correctly parses a JSON input representing a network configuration with one radio entry. The test confirms the API returns success and outputs the expected number of radio elements. This ensures that the system can handle a basic valid single radio configuration.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 088@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                     | Test Data                                                                                                               | Expected Result                                             | Notes      |
 * | :----:           | ----------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- | ---------- |
 * | 01               | Prepare a JSON string containing a network configuration with one radio entry                    | json = "{ \"wfa-dataelements:SetRadio\": { \"Network\": { \"ID\": \"TestNet\", \"DeviceList\": [ { \"ID\": \"AA:BB:CC:DD:EE:FF\", \"RadioList\": [ { \"ID\": \"radio0\" } ] } ] } } }" | JSON string is formatted correctly and assigned to subdoc.buff | Should be successful |
 * | 02               | Invoke the decode_config_set_radio API with the provided JSON configuration and capture output   | subdoc, key="wfa-dataelements:SetRadio", flag=0, num (output variable)                                                   | API returns 0 and num equals 1u                             | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_set_radio_valid_one_radio)
{
    std::cout << "Entering decode_config_set_radio_valid_one_radio\n";
    dm_easy_mesh_t obj;
    em_subdoc_info_t subdoc{};
    const char json[] =
        "{"
        " \"wfa-dataelements:SetRadio\": {"
        "   \"Network\": {"
        "     \"ID\": \"TestNet\","
        "     \"DeviceList\": ["
        "       {"
        "         \"ID\": \"AA:BB:CC:DD:EE:FF\","
        "         \"RadioList\": ["
        "           { \"ID\": \"radio0\" }"
        "         ]"
        "       }"
        "     ]"
        "   }"
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    unsigned int num = 0;
	std::cout << "Invoking decode_config_set_radio with one valid radio" << std::endl;
    int ret = obj.decode_config_set_radio(
        &subdoc,
        "wfa-dataelements:SetRadio",
        0,
        &num
    );
    EXPECT_EQ(ret, 0);
    EXPECT_EQ(num, 1u);
    std::cout << "Exiting decode_config_set_radio_valid_one_radio\n";
}

/**
 * @brief Validate decoding configuration for multiple radios input
 *
 * This test verifies that the configuration decoder function correctly interprets a JSON input that contains multiple radio entries within a network device configuration. It ensures that the function returns a success code (0) and correctly sets the number of radios decoded to 1.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 089
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                               | Test Data                                                                                                                              | Expected Result                                                                                               | Notes      |
 * | :--------------: | ------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ---------- |
 * | 01               | Invoke decode_config_set_radio with JSON containing multiple radio entries| subdoc.buff = valid JSON with "Network", "DeviceList" including a device with RadioList [radio0, radio1], element = "wfa-dataelements:SetRadio", index = 0, &num | return value is 0 and num equals 1 indicating successful decoding                                              | Should Pass|
 */
TEST(dm_easy_mesh_t, decode_config_set_radio_valid_multiple_radios)
{
    std::cout << "Entering decode_config_set_radio_valid_multiple_radios\n";
    dm_easy_mesh_t obj;
    em_subdoc_info_t subdoc{};
    const char json[] =
        "{"
        " \"wfa-dataelements:SetRadio\": {"
        "   \"Network\": {"
        "     \"ID\": \"TestNet\","
        "     \"DeviceList\": ["
        "       {"
        "         \"ID\": \"AA:BB:CC:DD:EE:FF\","
        "         \"RadioList\": ["
        "           { \"ID\": \"radio0\" },"
        "           { \"ID\": \"radio1\" }"
        "         ]"
        "       }"
        "     ]"
        "   }"
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    unsigned int num = 0;
	std::cout << "Invoking decode_config_set_radio with multiple valid radios" << std::endl;
    int ret = obj.decode_config_set_radio(
        &subdoc,
        "wfa-dataelements:SetRadio",
        0,
        &num
    );
    EXPECT_EQ(ret, 0);
    EXPECT_EQ(num, 1u);
    std::cout << "Exiting decode_config_set_radio_valid_multiple_radios\n";
}

/**
 * @brief Verify that decode_config_set_radio handles an out-of-bound radio index properly.
 *
 * This test verifies that when an out-of-bound index is passed to the decode_config_set_radio API, 
 * the API returns EM_PARSE_ERR_GEN and sets the radio number to the value set before the index check.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 090@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |@n
 * | :----: | --------- | ---------- |-------------- | ----- |@n
 * | 01 | Initialize the configuration with a valid JSON containing a single radio entry. | input: json = "{ \"wfa-dataelements:SetRadio\": { \"Network\": { \"ID\": \"TestNet\", \"DeviceList\": [ { \"ID\": \"AA:BB:CC:DD:EE:FF\", \"RadioList\": [ { \"ID\": \"radio0\" } ] } ] } } }" | JSON string successfully copied into subdoc.buff | Should be successful |@n
 * | 02 | Invoke decode_config_set_radio with an out-of-bound index (5). | input: subdoc, "wfa-dataelements:SetRadio", index = 5, output: num (initialized to 0) | Returns EM_PARSE_ERR_GEN and sets num to 1 prior to the index check | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_set_radio_out_of_bound_index)
{
    std::cout << "Entering decode_config_set_radio_out_of_bound_index\n";
    dm_easy_mesh_t obj;
    em_subdoc_info_t subdoc{};
    const char json[] =
        "{"
        " \"wfa-dataelements:SetRadio\": {"
        "   \"Network\": {"
        "     \"ID\": \"TestNet\","
        "     \"DeviceList\": ["
        "       {"
        "         \"ID\": \"AA:BB:CC:DD:EE:FF\","
        "         \"RadioList\": [ { \"ID\": \"radio0\" } ]"
        "       }"
        "     ]"
        "   }"
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    unsigned int num = 0;
	std::cout << "Invoking decode_config_set_radio with invalid index" << std::endl;
    int ret = obj.decode_config_set_radio(
        &subdoc,
        "wfa-dataelements:SetRadio",
        5,
        &num
    );
    EXPECT_EQ(ret, EM_PARSE_ERR_GEN);
    EXPECT_EQ(num, 1u);   // set before index check
    std::cout << "Exiting decode_config_set_radio_out_of_bound_index\n";
}

/**
 * @brief Tests the decode_config_set_radio function with a malformed JSON subdocument.
 *
 * This test verifies that the decode_config_set_radio API properly handles a subdocument containing malformed JSON data. 
 * It ensures that the function returns the error code EM_PARSE_ERR_GEN when provided with an improperly formatted JSON string.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 091@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                              | Test Data                                                                                     | Expected Result                                                     | Notes       |
 * | :--------------: | ------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- | ----------- |
 * | 01               | Invoke decode_config_set_radio with a malformed JSON subdocument to test error handling | subdoc.buff = "{ invalid json ", config ID = "wfa-dataelements:SetRadio", index = 0, num pointer = output variable | Should return EM_PARSE_ERR_GEN and pass the EXPECT_EQ assertion check | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_set_radio_malformed_subdoc)
{
    std::cout << "Entering decode_config_set_radio_malformed_subdoc\n";
    dm_easy_mesh_t obj;
    em_subdoc_info_t subdoc{};
    const char json[] = "{ invalid json ";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    unsigned int num = 0;
	std::cout << "Invoking decode_config_set_radio with malformed subdoc" << std::endl;
    int ret = obj.decode_config_set_radio(
        &subdoc,
        "wfa-dataelements:SetRadio",
        0,
        &num
    );
    EXPECT_EQ(ret, EM_PARSE_ERR_GEN);
    std::cout << "Exiting decode_config_set_radio_malformed_subdoc\n";
}

/**
 * @brief Verify that the decode_config_set_radio API returns an error when provided with a null subdocument pointer.
 *
 * This test case verifies that calling decode_config_set_radio with a null subdocument pointer correctly results in an error. By passing a null pointer for the subdocument, the test intends to simulate an invalid input scenario, ensuring that the API can properly handle and report the error condition.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 092@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                        | Test Data                                                                                   | Expected Result                                           | Notes      |
 * | :--------------: | ------------------------------------------------------------------ | ------------------------------------------------------------------------------------------- | --------------------------------------------------------- | ---------- |
 * | 01               | Invoke decode_config_set_radio with subdoc pointer as NULL         | subdoc = nullptr, element = "wfa-dataelements:SetRadio", index = 0, output pointer = &num   | Return value less than 0 (error), assertion EXPECT_LT(ret, 0) | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_config_set_radio_null_subdoc)
{
    std::cout << "Entering decode_config_set_radio_null_subdoc test" << std::endl;        
    dm_easy_mesh_t obj;
    unsigned int num = 0;
    std::cout << "Invoking decode_config_set_radio with subdoc pointer as NULL" << std::endl; 
    int ret = obj.decode_config_set_radio(nullptr, "wfa-dataelements:SetRadio", 0, &num);     
    std::cout << "Method returned: " << ret << std::endl;    
    EXPECT_LT(ret, 0);    
    std::cout << "Exiting decode_config_set_radio_null_subdoc test" << std::endl;
}

/**
 * @brief Verify that decode_config_set_radio returns an error when provided a NULL key pointer
 *
 * This test validates that the API decode_config_set_radio correctly handles a NULL key pointer by returning an error code. 
 * The test sets up a valid JSON configuration and invokes the API with a NULL key, ensuring that the API does not process
 * an invalid input, which is critical for maintaining robustness.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 093@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- | -------------- | ----- |
 * | 01 | Initialize subdoc with valid JSON configuration | json = "{" "wfa-dataelements:SetRadio": {" "Network": {" "ID": "TestNet", "DeviceList": [{"ID": "AA:BB:CC:DD:EE:FF", "RadioList": [{"ID": "radio0"}]}]}}}" | subdoc.buff is filled with a proper JSON string | Should be successful |
 * | 02 | Invoke decode_config_set_radio API with a NULL key pointer | key = nullptr, num = 2, subdoc containing JSON data | API returns an error code (ret < 0) indicating failure to process NULL key | Should Pass |
 * | 03 | Validate the API return value using assertion | ret (return value from decode_config_set_radio) | EXPECT_LT(ret, 0) check passes confirming error handling | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_set_radio_null_key)
{
    std::cout << "Entering decode_config_set_radio_null_key test" << std::endl;    
    em_subdoc_info_t subdoc{};
    dm_easy_mesh_t obj;
    const char json[] =
        "{"
        " \"wfa-dataelements:SetRadio\": {"
        "   \"Network\": {"
        "     \"ID\": \"TestNet\","
        "     \"DeviceList\": ["
        "       {"
        "         \"ID\": \"AA:BB:CC:DD:EE:FF\","
        "         \"RadioList\": ["
        "           { \"ID\": \"radio0\" }"
        "         ]"
        "       }"
        "     ]"
        "   }"
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    unsigned int num = 1;
    std::cout << "Invoking decode_config_set_radio with key: NULL" << std::endl;    
    int ret = obj.decode_config_set_radio(&subdoc, nullptr, 2, &num);    
    std::cout << "Method returned: " << ret << std::endl;    
    EXPECT_LT(ret, 0);    
    std::cout << "Exiting decode_config_set_radio_null_key test" << std::endl;
}

/**
 * @brief Validate decode_config_set_radio API behavior when a NULL value is passed for the num pointer
 *
 * This test verifies that the decode_config_set_radio function correctly handles the scenario where the pointer to the number of radio entries is NULL. The objective is to ensure that the API returns a negative error code when provided with invalid (NULL) parameters, thus preventing potential undefined behavior during runtime.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 094@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                 | Test Data                                                                                                                                                                                                                                                                                                         | Expected Result                                                  | Notes         |
 * | :--------------: | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | ------------- |
 * | 01               | Print a message indicating the start of the decode_config_set_radio_null_num test             | No input parameters                                                                                  | "Entering decode_config_set_radio_null_num test" appears on standard output   | Should be successful |
 * | 02               | Instantiate the dm_easy_mesh_t object and em_subdoc_info_t structure                         | N/A                                                                                                                                                                                                                                                 | Objects are created successfully                                 | Should be successful |
 * | 03               | Initialize the subdoc buffer with a JSON configuration for radio settings                    | json = " { \"wfa-dataelements:SetRadio\": { \"Network\": { \"ID\": \"TestNet\", \"DeviceList\": [ { \"ID\": \"AA:BB:CC:DD:EE:FF\", \"RadioList\": [ { \"ID\": \"radio0\" } ] } ] } } }" | subdoc.buff contains the correctly formatted JSON string         | Should be successful |
 * | 04               | Print a message before invoking decode_config_set_radio with a NULL num pointer                | No input parameters                                                                              | "Invoking decode_config_set_radio with num pointer: NULL" appears on standard output | Should be successful |
 * | 05               | Call decode_config_set_radio with parameters including a NULL pointer for the num argument     | subdoc, "wfa-dataelements:SetRadio", 0, NULL                                                                                                                      | The API returns a negative error code; EXPECT_LT(ret, 0) assertion passes | Should Pass       |
 * | 06               | Print a message indicating the exit of the decode_config_set_radio_null_num test               | No input parameters                                                                              | "Exiting decode_config_set_radio_null_num test" appears on standard output  | Should be successful |
 */
TEST(dm_easy_mesh_t, decode_config_set_radio_null_num)
{
    std::cout << "Entering decode_config_set_radio_null_num test" << std::endl;    
    dm_easy_mesh_t obj;
    em_subdoc_info_t subdoc{};

    const char json[] =
        "{"
        " \"wfa-dataelements:SetRadio\": {"
        "   \"Network\": {"
        "     \"ID\": \"TestNet\","
        "     \"DeviceList\": ["
        "       {"
        "         \"ID\": \"AA:BB:CC:DD:EE:FF\","
        "         \"RadioList\": ["
        "           { \"ID\": \"radio0\" }"
        "         ]"
        "       }"
        "     ]"
        "   }"
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    unsigned int num = 0;
    std::cout << "Invoking decode_config_set_radio with num pointer: NULL" << std::endl;
    int ret = obj.decode_config_set_radio(&subdoc, "wfa-dataelements:SetRadio", 0, NULL);    
    std::cout << "Method returned: " << ret << std::endl;    
    EXPECT_LT(ret, 0);    
    std::cout << "Exiting decode_config_set_radio_null_num test" << std::endl;
}

/**
 * @brief Verify that decode_config_set_ssid correctly handles valid configuration JSON.
 *
 * This test is designed to verify that the decode_config_set_ssid API properly decodes a JSON configuration payload containing multiple network SSIDs. It confirms that the function returns success and that the number of network SSIDs is set to EM_MAX_NET_SSIDS as expected. This ensures that the parser and configuration setup function correctly under valid input conditions.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 095@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                     | Test Data                                                                                                                              | Expected Result                                                             | Notes       |
 * | :--------------: | ----------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------- | ----------- |
 * | 01               | Allocate memory, initialize JSON configuration, invoke decode_config_set_ssid, and verify output | subdoc->buff = "{ \"wfa-dataelements:SetSSID\": { \"ID\": \"TestNet\", \"NetworkSSIDList\": [{ \"SSID\": \"ssid0\", \"HaulType\": [\"Fronthaul\"] }, { \"SSID\": \"ssid1\", \"HaulType\": [\"Backhaul\"] }, { \"SSID\": \"ssid2\", \"HaulType\": [\"IoT\"] }, { \"SSID\": \"ssid3\", \"HaulType\": [\"Configurator\"] }, { \"SSID\": \"ssid4\", \"HaulType\": [\"Hotspot\"] }] } }", key = "wfa-dataelements:SetSSID", output1 = ret (0), output2 = m_num_net_ssids (EM_MAX_NET_SSIDS) | API returns 0 and network SSIDs count equals EM_MAX_NET_SSIDS            | Should Pass  |
 */
TEST(dm_easy_mesh_t, decode_config_set_ssid_valid_config)
{
    std::cout << "Entering decode_config_set_ssid_valid_config test\n";
    dm_easy_mesh_t dm;
    constexpr size_t BUFSZ = 2048;
    em_subdoc_info_t *subdoc = static_cast<em_subdoc_info_t*>(calloc(1, sizeof(em_subdoc_info_t) + BUFSZ));
    ASSERT_NE(subdoc, nullptr);
    //HaulType MUST be an array of ONE string
    const char *json =
        "{"
        " \"wfa-dataelements:SetSSID\": {"
        "   \"ID\": \"TestNet\","
        "   \"NetworkSSIDList\": ["
        "     { \"SSID\": \"ssid0\", \"HaulType\": [\"Fronthaul\"] },"
        "     { \"SSID\": \"ssid1\", \"HaulType\": [\"Backhaul\"] },"
        "     { \"SSID\": \"ssid2\", \"HaulType\": [\"IoT\"] },"
        "     { \"SSID\": \"ssid3\", \"HaulType\": [\"Configurator\"] },"
        "     { \"SSID\": \"ssid4\", \"HaulType\": [\"Hotspot\"] }"
        "   ]"
        " }"
        "}";
    strncpy(subdoc->buff, json, BUFSZ - 1);
    subdoc->buff[BUFSZ - 1] = '\0';
    int ret = dm.decode_config_set_ssid(subdoc, "wfa-dataelements:SetSSID");
    EXPECT_EQ(ret, 0);
    EXPECT_EQ(dm.m_num_net_ssids, EM_MAX_NET_SSIDS);
    free(subdoc);
    std::cout << "Exiting decode_config_set_ssid_valid_config test\n";
}

/**
 * @brief Verify that decode_config_set_ssid returns an error when the SSID list is missing.
 *
 * This test validates that the decode_config_set_ssid function correctly handles a JSON configuration that omits the required SSID list. It ensures that the function returns the expected parse error code (EM_PARSE_ERR_GEN) when the JSON structure is incomplete.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 096@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke decode_config_set_ssid with JSON missing the SSID list | subdoc.buff = "{ \"SetSSID\": { \"ID\": \"TestNet\" } }", argument = "SetSSID" | Function returns error code EM_PARSE_ERR_GEN and assertion EXPECT_EQ(ret, EM_PARSE_ERR_GEN) passes | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_config_set_ssid_missing_ssid_list)
{
    std::cout << "Entering decode_config_set_ssid_missing_ssid_list test" << std::endl;
    dm_easy_mesh_t dm;
    em_subdoc_info_t subdoc{};
    const char json[] =
        "{"
        " \"SetSSID\": {"
        "   \"ID\": \"TestNet\""
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
    int ret = dm.decode_config_set_ssid(&subdoc, "SetSSID");
    // Parsing fails before semantic validation
    EXPECT_EQ(ret, EM_PARSE_ERR_GEN);
    std::cout << "Exiting decode_config_set_ssid_missing_ssid_list test" << std::endl;
}

/**
 * @brief Test decoding configuration with a malformed JSON input
 *
 * This test verifies that decode_config_set_ssid correctly identifies and handles a malformed JSON string by returning the expected error code.
 *
 * **Test Group ID:** Basic: 01  
 * **Test Case ID:** 097@n  
 * **Priority:** High
 *
 * **Pre-Conditions:** None  
 * **Dependencies:** None  
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                             | Expected Result                                                                               | Notes            |
 * | :---------------:| --------------------------------------------------------------------------------------------- | ----------------------------------------------------- | --------------------------------------------------------------------------------------------- | ---------------- |
 * | 01               | Initialize dm_easy_mesh_t instance, subdoc structure, and assign a malformed JSON string to subdoc.buff | subdoc.buff = "{ invalid json "                         | dm_easy_mesh_t instance and subdoc are properly initialized with malformed JSON string         | Should be successful |
 * | 02               | Invoke decode_config_set_ssid with the malformed JSON and verify return value                   | input1 = subdoc (with malformed JSON), input2 = "SetSSID", output1 = ret | ret equals EM_PARSE_ERR_GEN indicating error in parsing the malformed JSON                     | Should Pass      |
 */
TEST(dm_easy_mesh_t, decode_config_set_ssid_malformed_json)
{
    std::cout << "Entering decode_config_set_ssid_malformed_json test" << std::endl;
    dm_easy_mesh_t dm;
    const char json[] = "{ invalid json ";
    size_t len = strlen(json) + 1;
    em_subdoc_info_t *subdoc = (em_subdoc_info_t *)malloc(sizeof(em_subdoc_info_t) + len);
    memcpy(subdoc->buff, json, len);
    std::cout << "Invoking decode_config_set_ssid with malformed json" << std::endl;
    int ret = dm.decode_config_set_ssid(subdoc, "SetSSID");
    EXPECT_EQ(ret, EM_PARSE_ERR_GEN);
    free(subdoc);
    std::cout << "Exiting decode_config_set_ssid_malformed_json test" << std::endl;
}

/**
 * @brief Test for decoding configuration with an empty SSID list expecting a parse error.
 *
 * This test verifies the behavior of the decode_config_set_ssid API when provided with a JSON input where the "NetworkSSIDList" is empty.
 * The expected behavior is that the function fails at the parse stage and returns an appropriate error code.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 098@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                    | Test Data                                                                                            | Expected Result                                                  | Notes       |
 * | :---------------:| ------------------------------------------------------------------------------ | -----------------------------------------------------------------------------------------------------| ----------------------------------------------------------------- | ----------- |
 * | 01               | Prepare JSON with empty "NetworkSSIDList", invoke decode_config_set_ssid API   | subdoc.buff = "{ \"SetSSID\": { \"ID\": \"TestNet\", \"NetworkSSIDList\": [] } }", parameter = "SetSSID" | Returns EM_PARSE_ERR_GEN and EXPECT_EQ assertion verifies error code | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_config_set_ssid_empty_list)
{
    std::cout << "Entering decode_config_set_ssid_empty_list test" << std::endl;
    dm_easy_mesh_t dm;
    const char json[] =
        "{"
        " \"SetSSID\": {"
        "   \"ID\": \"TestNet\","
        "   \"NetworkSSIDList\": []"
        " }"
        "}";
    // Allocate subdoc with space for flexible array
    size_t len = strlen(json) + 1;
    em_subdoc_info_t *subdoc = (em_subdoc_info_t *)malloc(sizeof(em_subdoc_info_t) + len);
    ASSERT_NE(subdoc, nullptr);
    memcpy(subdoc->buff, json, len);
    int ret = dm.decode_config_set_ssid(subdoc, "SetSSID");
    // Empty list  config error (NOT parse error)
    EXPECT_EQ(ret, EM_PARSE_ERR_CONFIG);
    free(subdoc);
    std::cout << "Exiting decode_config_set_ssid_empty_list test" << std::endl;
}


/**
 * @brief Verify that decode_config_set_ssid returns an error when provided with a JSON configuration containing an invalid SSID list size.
 *
 * This test validates the behavior of the decode_config_set_ssid API when the JSON configuration has a wrong number of SSIDs in the "NetworkSSIDList" field.
 * It ensures that the API returns the expected error code (EM_PARSE_ERR_CONFIG) when a configuration with an insufficient list size is provided.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 099@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                          | Test Data                                                                                                | Expected Result                                                        | Notes         |
 * | :--------------: | ---------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- | ------------- |
 * | 01               | Prepare the subdocument buffer with a JSON configuration containing a wrong list size for SSIDs.     | json = "{ \"SetSSID\": { \"ID\": \"TestNet\", \"NetworkSSIDList\": [ { \"SSID\": \"onlyone\", \"HaulType\": 0 } ] } }" | subdoc.buff is populated with the specified JSON string.             | Should be successful |
 * | 02               | Invoke decode_config_set_ssid with the prepared subdocument and key "SetSSID" and check the return value. | input: subdoc (with the JSON config), key = "SetSSID", output: ret expected = EM_PARSE_ERR_CONFIG       | API returns EM_PARSE_ERR_CONFIG and the assertion EXPECT_EQ(ret, EM_PARSE_ERR_CONFIG) passes. | Should Fail   |
 */
TEST(dm_easy_mesh_t, decode_config_set_ssid_wrong_list_size)
{
	std::cout << "Entering decode_config_set_ssid_wrong_list_size test" << std::endl;
    dm_easy_mesh_t dm;
    em_subdoc_info_t subdoc{};
    const char json[] =
        "{"
        " \"SetSSID\": {"
        "   \"ID\": \"TestNet\","
        "   \"NetworkSSIDList\": [ { \"SSID\": \"onlyone\", \"HaulType\": 0 } ]"
        " }"
        "}";
    snprintf(subdoc.buff, sizeof(subdoc.buff), "%s", json);
	std::cout << "Invoking decode_config_set_ssid with wrong list size" << std::endl;
    int ret = dm.decode_config_set_ssid(&subdoc, "SetSSID");
    EXPECT_EQ(ret, EM_PARSE_ERR_CONFIG);
	std::cout << "Exiting decode_config_set_ssid_wrong_list_size test" << std::endl;
}

/**
 * @brief Verify decode_config_set_ssid returns error when provided with a null subdocument.
 *
 * This test verifies that the decode_config_set_ssid function fails gracefully when invoked with a null subdocument pointer. The function is expected to return a negative value to indicate an error, ensuring robust error handling for invalid input.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 100@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                       | Test Data                                         | Expected Result | Notes       |
 * | :---------------: | ----------------------------------------------------------------- | ------------------------------------------------- | --------------- | ----------- |
 * | 01                | Invoke decode_config_set_ssid with null subdoc and valid configName | subdoc = nullptr, configName = SetSSID, output ret = <negative value> | Return value < 0 | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_config_set_ssid_NullSubdoc) {
    std::cout << "Entering decode_config_set_ssid_NullSubdoc test" << std::endl;
    dm_easy_mesh_t dm;
    std::cout << "Invoking decode_config_set_ssid with subdoc: NULL" << std::endl;
    int ret = dm.decode_config_set_ssid(nullptr, "SetSSID");
    std::cout << "Returned value: " << ret << std::endl;
    EXPECT_LT(ret, 0);
    std::cout << "Exiting decode_config_set_ssid_NullSubdoc test" << std::endl;
}

/**
 * @brief Validate behavior of decode_config_set_ssid when provided a NULL key
 *
 * This test verifies that the decode_config_set_ssid API correctly detects an invalid
 * (NULL) key while processing a valid JSON configuration. The function is expected to return a
 * negative value to indicate an error in processing due to the missing key.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 101@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                  | Test Data                                                                                   | Expected Result                                           | Notes       |
 * | :--------------: | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------- | --------------------------------------------------------- | ----------- |
 * | 01               | Invoke decode_config_set_ssid with a valid JSON configuration and a NULL key | subdoc.buff = "{ \"SetSSID\": { \"ID\": \"TestNet\", \"NetworkSSIDList\": build_valid_ssid_list() } }", key = NULL | Function returns a negative value and the assertion (EXPECT_LT(ret, 0)) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_set_ssid_NullKey)
{
    std::cout << "Entering decode_config_set_ssid_NullKey test" << std::endl;
    dm_easy_mesh_t dm;
    const char json[] =
        "{"
        " \"SetSSID\": {"
        "   \"ID\": \"TestNet\","
        "   \"NetworkSSIDList\": ["
        "     { \"SSID\": \"Test\", \"BSSID\": \"00:11:22:33:44:55\" }"
        "   ]"
        " }"
        "}";
    size_t len = strlen(json) + 1;
    em_subdoc_info_t *subdoc = (em_subdoc_info_t *)malloc(sizeof(em_subdoc_info_t) + len);
    memcpy(subdoc->buff, json, len);
    std::cout << "Invoking decode_config_set_ssid with key: NULL" << std::endl;
    int ret = dm.decode_config_set_ssid(subdoc, nullptr);
    EXPECT_LT(ret, 0);
    free(subdoc);
    std::cout << "Exiting decode_config_set_ssid_NullKey test" << std::endl;
}

/**
 * @brief Tests the decode_config_test API with a valid JSON configuration.
 *
 * Validates that the decode_config_test function correctly parses a valid JSON configuration string,
 * ensuring proper extraction of configuration parameters and initialization of internal data structures.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 102@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                | Test Data                                                                                   | Expected Result                                            | Notes           |
 * | :--------------: | ---------------------------------------------------------- | ------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | --------------- |
 * | 01               | Create dm_easy_mesh_t instance and initialize it           | instance = dm_easy_mesh_t, call init()                                                      | Instance is created and initialized successfully           | Should be successful |
 * | 02               | Define a valid JSON configuration string                  | json = "{ \"testKey\": { \"ID\": \"TestNetwork\", ... }"                                    | JSON string is defined correctly                           | Should be successful |
 * | 03               | Allocate memory for em_subdoc_info_t and copy the JSON      | json_len = strlen(json)+1, subdoc allocated, json copied into subdoc->buff                     | subdoc != nullptr and JSON content is copied correctly     | Should be successful |
 * | 04               | Invoke decode_config_test API with valid JSON configuration | subdoc pointer, key = "testKey"                                                              | Function returns 0 and assertion passes                    | Should Pass     |
 * | 05               | Free the allocated memory                                 | free(subdoc)                                                                                 | Memory is freed successfully                               | Should be successful |
 */
TEST(dm_easy_mesh_t, decode_config_test_validConfig)
{
    std::cout << "Entering decode_config_test_validConfig test" << std::endl;
    dm_easy_mesh_t instance;
    instance.init();
    const char *json =
        "{"
        "  \"testKey\": {"
        "    \"ID\": \"TestNetwork\","
        "    \"ControllerID\": {"
        "      \"Name\": \"ctrl0\","
        "      \"MAC\": \"00:11:22:33:44:55\","
        "      \"Media\": 261"
        "    },"
        "    \"ColocatedAgentID\": {"
        "      \"Name\": \"agent0\","
        "      \"MAC\": \"00:11:22:33:44:56\","
        "      \"Media\": 259"
        "    },"
        "    \"DeviceList\": ["
        "      {"
        "        \"ID\": \"Device1\","
        "        \"Interface\": {"
        "          \"MAC\": \"02:00:00:00:00:01\""
        "        },"
        "        \"RadioList\": ["
        "          {"
        "            \"Interface\": {"
        "              \"MAC\": \"02:00:00:00:00:02\""
        "            },"
        "            \"CurrentOperatingClasses\": [],"
        "            \"Capabilities\": {"
        "              \"OperatingClasses\": []"
        "            },"
        "            \"BSSList\": ["
        "              {"
        "                \"BSSID\": \"02:00:00:00:00:03\""
        "              }"
        "            ]"
        "          }"
        "        ],"
        "        \"CACStatus\": {"
        "          \"AvailableChannelList\": [],"
        "          \"NonOccupancyChannelList\": [],"
        "          \"ActiveChannelList\": []"
        "        }"
        "      }"
        "    ]"
        "  }"
        "}";
 
    // Calculate JSON length
    size_t json_len = strlen(json) + 1;
    //Allocate struct + flexible buffer
    em_subdoc_info_t *subdoc = static_cast<em_subdoc_info_t *>(calloc(1, sizeof(em_subdoc_info_t) + json_len));
    ASSERT_NE(subdoc, nullptr);
    memcpy(subdoc->buff, json, json_len);
    std::cout << "Invoking decode_config_test with valid config" << std::endl;
    int ret = instance.decode_config_test(subdoc, "testKey");
    EXPECT_EQ(ret, 0);
    free(subdoc);
    instance.deinit();
    std::cout << "Exiting decode_config_test_validConfig test" << std::endl;
}

/**
 * @brief Test decode_config_test API with an empty key to validate error handling
 *
 * This test verifies that the decode_config_test API returns a negative value when invoked with an empty key.
 * It constructs a dummy JSON configuration and passes it along with an empty key to the API, ensuring that it fails as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 103@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | --------------- | ----- |
 * | 01 | Log entering test message | N/A | "Entering decode_config_test_emptyKey test" printed to console | Should be successful |
 * | 02 | Initialize instance and prepare input JSON buffer | instance = dm_easy_mesh_t, json = "{}", buffer size = (sizeof(em_subdoc_info_t) + 128) | Buffer is initialized with the JSON string "{}" | Should be successful |
 * | 03 | Invoke decode_config_test API with an empty key | input: subdoc pointer, key = "" | Returns a negative integer as validated by EXPECT_LT(ret, 0) | Should Fail |
 * | 04 | Log exiting test message | N/A | "Exiting decode_config_test_emptyKey test" printed to console | Should be successful |
 */
TEST(dm_easy_mesh_t, decode_config_test_emptyKey)
{
	std::cout << "Entering decode_config_test_emptyKey test" << std::endl;
    dm_easy_mesh_t instance;
    const char *json = "{}";
    char buffer[sizeof(em_subdoc_info_t) + 128] = {};
    em_subdoc_info_t *subdoc = reinterpret_cast<em_subdoc_info_t*>(buffer);
    snprintf(subdoc->buff, sizeof(subdoc->buff), "%s", json);
    std::cout << "Invoking decode_config_test with empty key" << std::endl;
    int ret = instance.decode_config_test(subdoc, "");
    EXPECT_LT(ret, 0);
	std::cout << "Exiting decode_config_test_emptyKey test" << std::endl;
}

/**
 * @brief Test to verify API behavior when the configuration key is missing
 *
 * This test verifies that the decode_config_test function returns an error when the specified key ("missingKey") is not found in the JSON configuration. The function is expected to handle the missing key gracefully by returning a negative value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 104@n
 * **Priority:** (High) High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke decode_config_test API with a JSON configuration that does not contain the expected key "missingKey". | subdoc->buff = "{ \"someOtherKey\": {} }", key = "missingKey", output: ret value | Return value is less than 0; Assertion EXPECT_LT(ret, 0) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_test_keyNotFound)
{
	std::cout << "Entering decode_config_test_keyNotFound test" << std::endl;
    dm_easy_mesh_t instance;
    const char *json =
        "{"
        "  \"someOtherKey\": {}"
        "}";
    char buffer[sizeof(em_subdoc_info_t) + 128] = {};
    em_subdoc_info_t *subdoc = reinterpret_cast<em_subdoc_info_t*>(buffer);
    snprintf(subdoc->buff, sizeof(subdoc->buff), "%s", json);
    std::cout << "Invoking decode_config_test with key not found" << std::endl;
    int ret = instance.decode_config_test(subdoc, "missingKey");
    EXPECT_LT(ret, 0);
	std::cout << "Exiting decode_config_test_keyNotFound test" << std::endl;
}

/**
 * @brief Verify that the decode_config_test API function handles malformed JSON input gracefully.
 *
 * This test verifies that when provided with a malformed JSON string, the decode_config_test method returns a negative error code as expected. The objective is to ensure that the configuration decoding correctly identifies and rejects invalid JSON inputs.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 105@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:** 
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize instance, prepare malformed JSON input, populate subdoc structure, and invoke decode_config_test API with key "testKey" | json = "{ invalid json ", subdoc->buff = "{ invalid json ", key = "testKey" | API returns a negative value (ret < 0) signifying an error due to malformed JSON; Assertion EXPECT_LT(ret, 0) passes | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_config_test_malformedJSON)
{
	std::cout << "Entering decode_config_test_malformedJSON test" << std::endl;
    dm_easy_mesh_t instance;
    const char *json = "{ invalid json ";
    char buffer[sizeof(em_subdoc_info_t) + 64] = {};
    em_subdoc_info_t *subdoc = reinterpret_cast<em_subdoc_info_t*>(buffer);
    snprintf(subdoc->buff, sizeof(subdoc->buff), "%s", json);
    std::cout << "Invoking decode_config_test with malformed json" << std::endl;
    int ret = instance.decode_config_test(subdoc, "testKey");
    EXPECT_LT(ret, 0);
	std::cout << "Exiting decode_config_test_malformedJSON test" << std::endl;
}

/**
 * @brief Verify that decode_config_test returns error when required configuration fields are missing.
 *
 * This test checks whether the decode_config_test method of dm_easy_mesh_t correctly identifies and handles missing required configuration fields from the JSON input, ensuring that an error (negative value) is returned.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 106@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                          | Test Data                                                             | Expected Result                                            | Notes       |
 * | :----:           | :----------------------------------------------------------------------------------- | --------------------------------------------------------------------- | ---------------------------------------------------------- | ----------- |
 * | 01               | Call decode_config_test with a JSON configuration missing required fields.           | input: subdoc->buff = { "testKey": {} }, key = "testKey"               | API returns a negative value; assertion EXPECT_LT(ret, 0)  | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_test_missingRequiredFields)
{
	std::cout << "Entering decode_config_test_missingRequiredFields test" << std::endl;
    dm_easy_mesh_t instance;
    const char *json =
        "{"
        "  \"testKey\": {}"
        "}";
    char buffer[sizeof(em_subdoc_info_t) + 128] = {};
    em_subdoc_info_t *subdoc = reinterpret_cast<em_subdoc_info_t*>(buffer);
    snprintf(subdoc->buff, sizeof(subdoc->buff), "%s", json);
    std::cout << "Invoking decode_config_test with missing fields test" << std::endl;
    int ret = instance.decode_config_test(subdoc, "testKey");
    EXPECT_LT(ret, 0);
	std::cout << "Exiting decode_config_test_missingRequiredFields test" << std::endl;
}

/**
 * @brief Validate decode_config_test returns negative value when subdoc is NULL.
 *
 * This test verifies that calling decode_config_test with a null subdocument (NULL) and a valid key ("validKey") correctly returns a negative value. This ensures the API behaves as expected in edge cases where a required configuration subdocument is not provided.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 107@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * |01| Invoke decode_config_test with subdoc set to NULL and key "validKey" | subdoc = NULL, key = "validKey", instance of dm_easy_mesh_t created | API returns a negative integer; assertion EXPECT_LT(ret, 0) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_test_nullSubdoc)
{
    const char* testName = "decode_config_test_nullSubdoc";
    std::cout << "Entering " << testName << " test" << std::endl;
    const char* key = "validKey";
    std::cout << testName << ": Invoking decode_config_test with subdoc = NULL and key = \""  << key << "\"" << std::endl;
    dm_easy_mesh_t instance;
    int ret = instance.decode_config_test(nullptr, key);
    std::cout << "Returned value = " << ret << std::endl;
    EXPECT_LT(ret, 0);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verifies that decode_config_test returns an error when the key parameter is null.
 *
 * This test loads a valid JSON configuration into a subdocument buffer and then invokes the decode_config_test API with the key parameter set to null. The expectation is that the function returns a negative value, indicating error handling for the null key case.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 108@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                        | Expected Result                                                     | Notes       |
 * | :--------------: | --------------------------------------------------------------------------- | ---------------------------------------------------------------- | ------------------------------------------------------------------- | ----------- |
 * | 01               | Invoke decode_config_test API with a valid JSON configuration and a null key. | json = JSON config string, subdoc = valid buffer pointer, key = nullptr | Return value less than 0; assert condition EXPECT_LT(ret, 0) is met. | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_config_test_nullKey)
{
    const char* testName = "decode_config_test_nullKey";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t instance;

    const char *json =
        "{"
        "  \"testKey\": {"
        "    \"DeviceList\": ["
        "      {"
        "        \"RadioList\": ["
        "          {"
        "            \"CurrentOperatingClasses\": [],"
        "            \"Capabilities\": {"
        "              \"OperatingClasses\": []"
        "            },"
        "            \"BSSList\": ["
        "              { \"BSSID\": \"00:11:22:33:44:55\" }"
        "            ]"
        "          }"
        "        ],"
        "        \"CACStatus\": {"
        "          \"AvailableChannelList\": [],"
        "          \"NonOccupancyChannelList\": [],"
        "          \"ActiveChannelList\": []"
        "        }"
        "      }"
        "    ]"
        "  }"
        "}";

    char buffer[sizeof(em_subdoc_info_t) + 1024] = {};
    em_subdoc_info_t *subdoc = reinterpret_cast<em_subdoc_info_t*>(buffer);
    snprintf(subdoc->buff, sizeof(subdoc->buff), "%s", json);
    int ret = instance.decode_config_test(subdoc, nullptr);
    std::cout << "Returned value = " << ret << std::endl;
    EXPECT_LT(ret, 0);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test decode_num_devices with valid JSON input containing zero devices
 *
 * This test verifies that the decode_num_devices API correctly parses a JSON string
 * with an empty "DeviceList" array. It checks that the API returns a value of 0 and sets
 * the media field to em_media_type_ieee8023ab, indicating proper processing of the input.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 109@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                                                                                                                 | Expected Result                                                                                       | Notes          |
 * | :--------------: | --------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | -------------- |
 * | 01               | Allocate memory for the sub-document and copy the JSON string               | json = "{" "  \"wfa-dataelements:Network\": {" "    \"ID\": \"TestNetwork\"," "    \"ControllerID\": \"AA:BB:CC:DD:EE:FF\"," "    \"MediaType\": \"Ethernet\"," "    \"DeviceList\": []" "  }" "}", json_len = strlen(json) + 1 | subdoc is successfully allocated and the JSON string is copied into subdoc->buff                        | Should be successful |
 * | 02               | Invoke decode_num_devices API with the sub-document                         | input: subdoc (with buff containing valid JSON string)                                                                                                    | Return value is 0 and dmObj.m_network.m_net_info.media equals em_media_type_ieee8023ab                  | Should Pass    |
 * | 03               | Free the allocated memory for subdoc                                        | input: subdoc                                                                                                                                              | Memory freed without errors                                                                            | Should be successful |
 */
TEST(dm_easy_mesh_t, decode_num_devices_valid_zero_devices)
{
    std::cout << "Entering decode_num_devices_valid_zero_devices test\n";
    dm_easy_mesh_t dmObj;
    const char *json =
        "{"
        "  \"wfa-dataelements:Network\": {"
        "    \"ID\": \"TestNetwork\","
        "    \"ControllerID\": \"AA:BB:CC:DD:EE:FF\","
        "    \"MediaType\": \"Ethernet\","
        "    \"DeviceList\": []"
        "  }"
        "}";
    size_t json_len = strlen(json) + 1;
    //Allocate struct + flexible buffer
    em_subdoc_info_t *subdoc = static_cast<em_subdoc_info_t *>(calloc(1, sizeof(em_subdoc_info_t) + json_len));
    ASSERT_NE(subdoc, nullptr);
    memcpy(subdoc->buff, json, json_len);
    std::cout << "Invoking decode_num_devices with valid zero devices\n";
    int result = dmObj.decode_num_devices(subdoc);
    EXPECT_EQ(result, 0);
    EXPECT_EQ(dmObj.m_network.m_net_info.media, em_media_type_ieee8023ab);
    free(subdoc);
    std::cout << "Exiting decode_num_devices_valid_zero_devices test\n";
}

/**
 * @brief Verify that decode_num_devices accurately counts the number of devices in a valid JSON input.
 *
 * This test validates that when a valid JSON document containing five devices is provided to the decode_num_devices API,
 * it correctly returns the device count as 5 and sets the network media type to em_media_type_ieee80211b_24.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 110@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                           | Test Data                                                                                                                       | Expected Result                                                                            | Notes               |
 * | :--------------: | ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ | ------------------- |
 * |       01       | Set up JSON input with 5 device objects and allocate memory for subdocument                          | json = "{"wfa-dataelements:Network": {"ID": "TestNetwork", "ControllerID": "AA:BB:CC:DD:EE:FF", "MediaType": "Wireless", "DeviceList": [{}, {}, {}, {}, {}]}}", json_len = (strlen(json)+1), subdoc allocated via calloc | subdoc is allocated successfully and buffer contains the JSON data                         | Should be successful  |
 * |       02       | Invoke decode_num_devices with the prepared subdocument and verify the output                        | subdoc pointer with valid JSON; expected inputs: result, network media type; expected outputs: result = 5, media = em_media_type_ieee80211b_24 | Function returns 5 and dmObj.m_network.m_net_info.media is set to em_media_type_ieee80211b_24 | Should Pass         |
 * |       03       | Clean up the allocated memory by freeing the subdocument                                             | free(subdoc)                                                                                                                    | subdoc memory is freed correctly                                                           | Should be successful  |
 */
TEST(dm_easy_mesh_t, decode_num_devices_valid_positive_count)
{
    std::cout << "Entering decode_num_devices_valid_positive_count test\n";
    dm_easy_mesh_t dmObj;
    const char *json =
        "{"
        "  \"wfa-dataelements:Network\": {"
        "    \"ID\": \"TestNetwork\","
        "    \"ControllerID\": \"AA:BB:CC:DD:EE:FF\","
        "    \"MediaType\": \"Wireless\","
        "    \"DeviceList\": [{}, {}, {}, {}, {}]"
        "  }"
        "}";
    size_t json_len = strlen(json) + 1;
    em_subdoc_info_t *subdoc = static_cast<em_subdoc_info_t *>(calloc(1, sizeof(em_subdoc_info_t) + json_len));
    ASSERT_NE(subdoc, nullptr);
    memcpy(subdoc->buff, json, json_len);
    std::cout << "Invoking decode_num_devices with positive count\n";
    int result = dmObj.decode_num_devices(subdoc);
    EXPECT_EQ(result, 5);
    EXPECT_EQ(dmObj.m_network.m_net_info.media, em_media_type_ieee80211b_24);
    free(subdoc);
    std::cout << "Exiting decode_num_devices_valid_positive_count test\n";
}

/**
 * @brief Test for invalid malformed JSON input to decode_num_devices
 *
 * This test verifies that the decode_num_devices API correctly handles a malformed JSON string.
 * The test creates a subdocument containing an invalid JSON string and then calls the decode_num_devices
 * method. It checks if the method returns an error value (-1) as expected for malformed JSON input.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 111@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize subdocument with malformed JSON and invoke decode_num_devices | json = "{ invalid json ", buffer (allocated for subdoc with buff set to the JSON string), input: subdoc | API returns -1 and EXPECT_EQ(result, -1) assertion passes | Should Fail |
 */
TEST(dm_easy_mesh_t, decode_num_devices_invalid_malformed_json)
{
	std::cout << "Entering decode_num_devices_invalid_malformed_json test" << std::endl;
    dm_easy_mesh_t dmObj;
    const char *json = "{ invalid json ";
    char buffer[sizeof(em_subdoc_info_t) + 128] = {};
    em_subdoc_info_t *subdoc = reinterpret_cast<em_subdoc_info_t *>(buffer);
    snprintf(subdoc->buff, sizeof(subdoc->buff), "%s", json);
    std::cout << "Invoking decode_num_devices with malformed json" << std::endl;
    int result = dmObj.decode_num_devices(subdoc);
    EXPECT_EQ(result, -1);
	std::cout << "Exiting decode_num_devices_invalid_malformed_json test" << std::endl;
}

/**
 * @brief Verify decode_num_devices returns error when network key is missing
 *
 * This test case verifies that the dm_easy_mesh_t::decode_num_devices function returns an error (-1) when the required network key is missing in the JSON input. This ensures that the function properly handles cases of incomplete or invalid configurations.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 112@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result |Notes |
 * | :----: | ----------- | --------- | -------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object and prepare JSON with missing network key. | json = "{ \"SomeOtherKey\": { \"DeviceList\": [{}] } }", subdoc->buff contains the JSON string | API input is successfully prepared. | Should be successful |
 * | 02 | Call decode_num_devices with the constructed subdoc and verify the return value. | dmObj.decode_num_devices(subdoc) returns result | Return value is -1 indicating error due to missing network key. | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_num_devices_missing_network_key)
{
	std::cout << "Entering decode_num_devices_missing_network_key test" << std::endl;
    dm_easy_mesh_t dmObj;
    const char *json =
        "{"
        "  \"SomeOtherKey\": {"
        "    \"DeviceList\": [{}]"
        "  }"
        "}";

    char buffer[sizeof(em_subdoc_info_t) + 256] = {};
    em_subdoc_info_t *subdoc = reinterpret_cast<em_subdoc_info_t *>(buffer);
    snprintf(subdoc->buff, sizeof(subdoc->buff), "%s", json);
    std::cout << "Invoking decode_num_devices with missing network key" << std::endl;
    int result = dmObj.decode_num_devices(subdoc);
    EXPECT_EQ(result, -1);
	std::cout << "Exiting decode_num_devices_missing_network_key test" << std::endl;
}

/**
 * @brief Verify decode_num_devices handles missing device list in JSON correctly
 *
 * This test verifies that the dm_easy_mesh_t::decode_num_devices API returns an error (-1) when the input JSON is missing the device list. It ensures that the API correctly identifies and handles the absence of required data.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 113@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                        | Test Data                                                                                                             | Expected Result                           | Notes      |
 * | :----:           | ------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------- | ----------------------------------------- | ---------- |
 * | 01               | Invoke decode_num_devices with JSON missing the device list field  | json = "{ \"wfa-dataelements:Network\": {} }", subdoc->buff initialized with json                                         | API returns -1 and EXPECT_EQ confirms result equals -1 | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_num_devices_missing_device_list)
{
	std::cout << "Entering decode_num_devices_missing_device_list test" << std::endl;
    dm_easy_mesh_t dmObj;
    const char *json =
        "{"
        "  \"wfa-dataelements:Network\": {}"
        "}";
    char buffer[sizeof(em_subdoc_info_t) + 128] = {};
    em_subdoc_info_t *subdoc = reinterpret_cast<em_subdoc_info_t *>(buffer);
    snprintf(subdoc->buff, sizeof(subdoc->buff), "%s", json);
    std::cout << "Invoking decode_num_devices with missing device list" << std::endl;
    int result = dmObj.decode_num_devices(subdoc);
    EXPECT_EQ(result, -1);
	std::cout << "Exiting decode_num_devices_missing_device_list test" << std::endl;
}

/**
 * @brief Verifies that the decode_num_devices API returns an error when provided with a null pointer input.
 *
 * This test evaluates the behavior of dm_easy_mesh_t::decode_num_devices when a null pointer is passed as the subdoc argument.
 * The test ensures that the API handles null inputs gracefully by returning a predefined error value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 114@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                              | Test Data                  | Expected Result                                             | Notes      |
 * | :--------------: | -------------------------------------------------------- | -------------------------- | ----------------------------------------------------------- | ---------- |
 * | 01               | Invoke decode_num_devices with subdoc set to nullptr      | subdoc = nullptr           | Return value should be -1 using EXPECT_EQ to verify correctness | Should Pass |
 */
TEST(dm_easy_mesh_t, decode_num_devices_null_pointer_input) {
    std::cout << "Entering decode_num_devices_null_pointer_input test" << std::endl;
    dm_easy_mesh_t dmObj;
    em_subdoc_info_t* subdoc = nullptr;
    std::cout << "Invoking dm_easy_mesh_t::decode_num_devices with subdoc = nullptr" << std::endl;
    int result = dmObj.decode_num_devices(subdoc);
    std::cout << "Returned value: " << result << std::endl;
    EXPECT_EQ(result, -1);
    std::cout << "Exiting decode_num_devices_null_pointer_input test" << std::endl;
}

/**
 * @brief Verify that the default constructor of dm_easy_mesh_t initializes all members correctly.
 *
 * This test verifies that when an object of dm_easy_mesh_t is created using the default constructor, 
 * all its member variables are initialized to the expected default values. The assertions confirm that 
 * numeric members are set to 0, the enumeration is set to db_cfg_type_none, and the boolean member is false.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 115@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke the default constructor dm_easy_mesh_t() to create an object. | Constructor call: dm_easy_mesh_t() with no parameters | An object dm is created with all member variables set to their default values (m_num_preferences = 0, m_num_interfaces = 0, m_num_radios = 0, m_num_opclass = 0, m_num_policy = 0, m_num_bss = 0, m_num_ap_mld = 0, m_num_net_ssids = 0, m_db_cfg_param.db_cfg_type = db_cfg_type_none, m_colocated = false). | Should Pass |
 * | 02 | Verify that each member of the object dm has the correct default value using assertion checks. | Assertion checks: input: dm, expected outputs: m_num_preferences = 0, m_num_interfaces = 0, m_num_radios = 0, m_num_opclass = 0, m_num_policy = 0, m_num_bss = 0, m_num_ap_mld = 0, m_num_net_ssids = 0, m_db_cfg_param.db_cfg_type = db_cfg_type_none, m_colocated = false | All assertions succeed confirming correct default initialization. | Should Pass |
 */
TEST(dm_easy_mesh_t, dm_easy_mesh_t_default_construction_initializes_all_members_correctly) {
    std::cout << "Entering dm_easy_mesh_t_default_construction_initializes_all_members_correctly test" << std::endl;
    std::cout << "Invoking default constructor dm_easy_mesh_t()" << std::endl;
    dm_easy_mesh_t dm;
    EXPECT_EQ(dm.m_num_preferences, 0u);
    EXPECT_EQ(dm.m_num_interfaces, 0u);    
    EXPECT_EQ(dm.m_num_radios, 0u);
    EXPECT_EQ(dm.m_num_opclass, 0u);
    EXPECT_EQ(dm.m_num_policy, 0u);
    EXPECT_EQ(dm.m_num_bss, 0u);
    EXPECT_EQ(dm.m_num_ap_mld, 0u);
    EXPECT_EQ(dm.m_num_net_ssids, 0u);
    EXPECT_EQ(dm.m_db_cfg_param.db_cfg_type, db_cfg_type_none);
    EXPECT_EQ(dm.m_colocated, false);    
    std::cout << "Exiting dm_easy_mesh_t_default_construction_initializes_all_members_correctly test" << std::endl;
}

/**
 * @brief Verify that the dm_easy_mesh_t constructor correctly copies the control MAC address from dm_network_t.
 *
 * This test creates a dm_network_t instance, sets its control MAC address to a known value, and then
 * constructs a dm_easy_mesh_t object using that network instance. The test verifies that the constructor
 * correctly copies the control MAC address into both backhaul_alid.mac and backhaul_mac.mac fields of the device info.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 116@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                      | Test Data                                                                                                  | Expected Result                                                                                                      | Notes              |
 * | :--------------: | ------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- | ------------------ |
 * | 01               | Create a dm_network_t instance and set ctrl_id.mac with a specific control MAC address             | dm_network_t net; ctrl_mac = 0x00, 0x11, 0x22, 0x33, 0x44, 0x55                                               | The dm_network_t instance should have its ctrl_id.mac field set to the provided MAC address                             | Should be successful |
 * | 02               | Invoke the dm_easy_mesh_t constructor using the prepared network instance                          | Input: network instance (dm_network_t net with ctrl_id.mac set)                                              | dm_easy_mesh_t object is created and the control MAC is copied correctly into backhaul_alid.mac and backhaul_mac.mac | Should Pass         |
 * | 03               | Verify that the MAC addresses in the device info are identical to the control MAC from the network | Derived device info from dm_easy_mesh_t object; Output: backhaul_alid.mac, backhaul_mac.mac compared using memcmp | EXPECT_EQ(memcmp(...), 0) for both backhaul_alid.mac and backhaul_mac.mac should return 0, confirming a match         | Should be successful |
 */
TEST(dm_easy_mesh_t, ctor_valid_network_copies_ctrl_id)
{
    std::cout << "Entering ctor_valid_network_copies_ctrl_id test" << std::endl;
    dm_network_t net{};    
    unsigned char ctrl_mac[6] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
    memcpy(net.m_net_info.ctrl_id.mac, ctrl_mac, sizeof(ctrl_mac));
    std::cout << "Invoking dm_easy_mesh_t constructor" << std::endl;
    dm_easy_mesh_t mesh(net);
    const em_device_info_t& dev = mesh.m_device.m_device_info;
    EXPECT_EQ(memcmp(dev.backhaul_alid.mac, ctrl_mac, sizeof(ctrl_mac)), 0);
    EXPECT_EQ(memcmp(dev.backhaul_mac.mac, ctrl_mac, sizeof(ctrl_mac)), 0);
    std::cout << "Exiting ctor_valid_network_copies_ctrl_id test" << std::endl;
}

/**
 * @brief Validate that dm_easy_mesh_t constructor successfully resolves the backhaul MAC name when a valid MAC exists.
 *
 * This test verifies that when a dm_network_t instance is provided with a valid MAC address (all zeros in this case),
 * the dm_easy_mesh_t constructor correctly initializes the object and sets a non-empty backhaul MAC name. This is important
 * to ensure that the name resolution mechanism works as expected when working with valid MAC addresses.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 117@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                             | Expected Result                                                                                    | Notes           |
 * | :--------------: | --------------------------------------------------------------------------- | --------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | --------------- |
 * | 01               | Create a dm_network_t instance and initialize its MAC address               | net.m_net_info.ctrl_id.mac = "00,00,00,00,00,00"                      | dm_network_t instance is created with the MAC address correctly set                                | Should be successful |
 * | 02               | Invoke the dm_easy_mesh_t constructor with the initialized dm_network_t       | input: dm_network_t net with MAC="00,00,00,00,00,00", output: dm_easy_mesh_t instance  | dm_easy_mesh_t object is constructed and internal device structures are initialized properly        | Should Pass     |
 * | 03               | Verify that the backhaul MAC name is non-empty using EXPECT_STRNE             | output: dm_easy_mesh_t.m_device.m_device_info.backhaul_mac.name != ""    | The backhaul MAC name is not an empty string as expected                                           | Should Pass     |
 * | 04               | Log entering and exiting the test function                                  | Not Applicable                                                        | Console outputs indicate entry and exit of the test function                                       | Should be successful |
 */
TEST(dm_easy_mesh_t, ctor_name_resolution_success_if_mac_exists)
{
    std::cout << "Entering ctor_name_resolution_success_if_mac_exists test" << std::endl;
    dm_network_t net{};
    memcpy(net.m_net_info.ctrl_id.mac, "\x00\x00\x00\x00\x00\x00", 6);
    std::cout << "Invoking dm_easy_mesh_t constructor" << std::endl;
    dm_easy_mesh_t mesh(net);
    EXPECT_STRNE(mesh.m_device.m_device_info.backhaul_mac.name, "");
    std::cout << "Exiting ctor_name_resolution_success_if_mac_exists test" << std::endl;
}

/**
 * @brief Test constructor's handling of unknown MAC for name resolution
 *
 * This test verifies that when an unknown MAC address is set in dm_network_t, the dm_easy_mesh_t constructor does not modify the device name for the backhaul MAC, leaving it empty. It ensures that the constructor properly handles unknown MAC addresses.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 118@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Instantiate a dm_network_t object and set an unknown MAC address | net object with ctrl_id.mac set to 0xDE,0xAD,0xBE,0xEF,0x00,0x01 | dm_network_t object fields updated with unknown MAC | Should Pass |
 * | 02 | Invoke the dm_easy_mesh_t constructor with the prepared net object | net (with unknown MAC) as input to dm_easy_mesh_t constructor | dm_easy_mesh_t object is created and backhaul_mac.name remains unchanged (empty) | Should Pass |
 * | 03 | Assert that the backhaul_mac.name is empty using strlen | Call strlen on mesh.m_device.m_device_info.backhaul_mac.name | EXPECT_TRUE confirms string length equals 0 | Should Pass |
 */
TEST(dm_easy_mesh_t, ctor_name_resolution_fails_for_unknown_mac)
{
    std::cout << "Entering ctor_name_resolution_fails_for_unknown_mac test" << std::endl;
    dm_network_t net{};
    unsigned char unknown_mac[6] = {0xDE,0xAD,0xBE,0xEF,0x00,0x01};
    memcpy(net.m_net_info.ctrl_id.mac, unknown_mac, sizeof(unknown_mac));
    std::cout << "Invoking dm_easy_mesh_t constructor" << std::endl;
    dm_easy_mesh_t mesh(net);
    // name buffer remains unchanged (likely empty)
    EXPECT_TRUE(strlen(mesh.m_device.m_device_info.backhaul_mac.name) == 0);
    std::cout << "Exiting ctor_name_resolution_fails_for_unknown_mac test" << std::endl;
}

/**
 * @brief Verify that the dm_easy_mesh_t constructor properly initializes device MAC when ctrl_id is zero.
 *
 * This test validates that when dm_network_t's ctrl_id is zero-initialized, the dm_easy_mesh_t constructor sets the device's MAC address to all zeros. The test ensures that memcmp confirms the MAC address matches the expected zeroed MAC.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 119@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_network_t instance and set ctrl_id to zero using memset | net.m_net_info.ctrl_id = 0 | dm_network_t instance has ctrl_id zeroed | Should be successful |
 * | 02 | Invoke the dm_easy_mesh_t constructor with the initialized dm_network_t | input: net (ctrl_id zeroed) | dm_easy_mesh_t object is constructed successfully | Should Pass |
 * | 03 | Compare the device MAC of the dm_easy_mesh_t object with a zero MAC array using memcmp | input: mesh.m_device.m_device_info.id.dev_mac, expected: zero_mac = {0,0,0,0,0,0} | memcmp returns 0 indicating MAC addresses are identical | Should Pass |
 */
TEST(dm_easy_mesh_t, ctor_zero_initialized_ctrl_id)
{
    std::cout << "Entering ctor_zero_initialized_ctrl_id test" << std::endl;
    dm_network_t net{};
    memset(&net.m_net_info.ctrl_id, 0, sizeof(em_interface_t));
    std::cout << "Invoking dm_easy_mesh_t constructor" << std::endl;
    dm_easy_mesh_t mesh(net);
    unsigned char zero_mac[6] = {0};
    EXPECT_EQ(memcmp(mesh.m_device.m_device_info.id.dev_mac, zero_mac, 6), 0);
    std::cout << "Exiting ctor_zero_initialized_ctrl_id test" << std::endl;
}

/**
 * @brief Test dm_easy_mesh_t constructor with a nullptr network pointer to verify exception handling.
 *
 * This test verifies that when the dm_easy_mesh_t constructor is invoked with a dereferenced nullptr network pointer,
 * an exception is thrown as expected. This ensures that the API correctly handles invalid network references.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 120@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                        | Test Data                                   | Expected Result                                     | Notes          |
 * | :--------------: | ---------------------------------------------------------------------------------- | ------------------------------------------- | --------------------------------------------------- | -------------- |
 * | 01               | Initialize the network pointer to nullptr.                                         | net = nullptr                               | Pointer is set to nullptr.                          | Should be successful |
 * | 02               | Invoke dm_easy_mesh_t constructor with dereferenced nullptr and verify exception is thrown. | input: *net = nullptr, output: exception thrown | Exception thrown as expected by EXPECT_ANY_THROW.   | Should Fail    |
 */
TEST(dm_easy_mesh_t, ctor_nullptr_network_reference_bug)
{
    std::cout << "Entering ctor_nullptr_network_reference_bug test" << std::endl;
    dm_network_t* net = nullptr;
    std::cout << "Invoking dm_easy_mesh_t constructor with nullptr (expected UB)" << std::endl;
    EXPECT_ANY_THROW(dm_easy_mesh_t mesh(*net));
    std::cout << "Exiting ctor_nullptr_network_reference_bug test" << std::endl;
}

/**
 * @brief Verify that encode_config function returns success with valid configuration when provided with a valid namespace and key
 *
 * This test verifies that the encode_config method properly encodes a configuration using a valid namespace and a valid key.
 * It ensures that the method returns success (i.e., 0) when provided with correct input parameters.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 121@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                               | Test Data                                      | Expected Result                                        | Notes      |
 * | :--------------: | --------------------------------------------------------- | ---------------------------------------------- | ------------------------------------------------------ | ---------- |
 * | 01               | Call encode_config with a valid namespace and key         | subdoc.name = valid_namespace, key = Test      | Return value is 0 and assertion EXPECT_EQ(0, ret) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, encode_config_valid_configuration)
{
    std::cout << "Entering encode_config_valid_configuration test" << std::endl;
    dm_easy_mesh_t dm_easy_mesh_obj;
    em_subdoc_info_t subdoc;
    strncpy(subdoc.name, "valid_namespace", sizeof(subdoc.name));
    subdoc.name[sizeof(subdoc.name) - 1] = '\0';    
    const char * key = "Test";
    std::cout << "Invoking encode_config with subdoc name: " << subdoc.name << " and key: " << key << std::endl;
    int ret = dm_easy_mesh_obj.encode_config(&subdoc, key);
    std::cout << "Returned value: " << ret << std::endl;
    EXPECT_EQ(0, ret);
    std::cout << "Exiting encode_config_valid_configuration test" << std::endl;
}

/**
 * @brief Verify that encode_config returns an error when provided a NULL subdocument.
 *
 * This test validates the behavior of the encode_config function in the dm_easy_mesh_t class when the subdocument pointer is NULL.
 * The objective is to ensure that proper error handling is performed and a non-zero value is returned indicating the failure.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 122@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke encode_config with subdoc set to NULL and key set to "dm_cache". | subdoc = NULL, key = "dm_cache", output: ret variable | Return value is non-zero indicating an error as expected, and the assertion EXPECT_NE(0, ret) passes. | Should Fail |
 */
TEST(dm_easy_mesh_t, encode_config_null_subdoc_failure)
{
    std::cout << "Entering encode_config_null_subdoc_failure test" << std::endl;
    dm_easy_mesh_t dm_easy_mesh_obj;
    const char * key = "dm_cache";
    std::cout << "Invoking encode_config with subdoc: NULL and key: " << key << std::endl;
    int ret = dm_easy_mesh_obj.encode_config(NULL, key);
    std::cout << "Returned value: " << ret << std::endl;
    EXPECT_NE(0, ret);
    std::cout << "Exiting encode_config_null_subdoc_failure test" << std::endl;
}

/**
 * @brief Tests that encoding configuration with a null key fails.
 *
 * This test verifies that when the encode_config API is invoked with a valid sub-document name and a NULL key pointer, 
 * the function returns an error (non-zero) value, confirming proper input validation handling.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 123@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                  | Test Data                                                     | Expected Result                                 | Notes       |
 * | :--------------: | ------------------------------------------------------------ | ------------------------------------------------------------- | ----------------------------------------------- | ----------- |
 * | 01               | Invoke encode_config with a valid subdoc name and a NULL key.  | subdoc.name = valid_namespace, key = NULL, output: ret != 0     | Function returns an error (non-zero) value; assertion EXPECT_NE(0, ret) passes. | Should Fail |
 */
TEST(dm_easy_mesh_t, encode_config_null_key_failure)
{
    std::cout << "Entering encode_config_null_key_failure test" << std::endl;
    dm_easy_mesh_t dm_easy_mesh_obj;
    em_subdoc_info_t subdoc;
    strncpy(subdoc.name, "valid_namespace", sizeof(subdoc.name));
    subdoc.name[sizeof(subdoc.name) - 1] = '\0';
    std::cout << "Invoking encode_config with subdoc name: " << subdoc.name << " and key: NULL" << std::endl;
    int ret = dm_easy_mesh_obj.encode_config(&subdoc, NULL);
    std::cout << "Returned value: " << ret << std::endl;
    EXPECT_NE(0, ret);
    std::cout << "Exiting encode_config_null_key_failure test" << std::endl;
}

/**
 * @brief Verify that the encode_config() API fails when provided with an empty key.
 *
 * This test verifies that when an empty key is provided to the encode_config() method of dm_easy_mesh_t,
 * the function returns a non-zero error code. The sub-document is initialized with a valid namespace,
 * while the key is intentionally left as an empty string to simulate an invalid input scenario.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 124@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                  | Test Data                                                                                              | Expected Result                                                               | Notes         |
 * | :--------------: | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize the dm_easy_mesh_t object and sub-document info with valid data.  | dm_easy_mesh_obj (instance), subdoc.name = "valid_namespace", key (not set yet)                         | Objects are initialized successfully.                                         | Should be successful |
 * | 02               | Invoke encode_config() with subdoc (name = "valid_namespace") and an empty key. | subdoc.name = "valid_namespace", key = ""; output: ret (error code expected not to be 0)                  | Function returns a non-zero error code (as asserted by EXPECT_NE(0, ret)).      | Should Fail   |
 */
TEST(dm_easy_mesh_t, encode_config_empty_key_failure)
{
    std::cout << "Entering encode_config_empty_key_failure test" << std::endl;
    dm_easy_mesh_t dm_easy_mesh_obj;
    em_subdoc_info_t subdoc;
    strncpy(subdoc.name, "valid_namespace", sizeof(subdoc.name));
    subdoc.name[sizeof(subdoc.name) - 1] = '\0';    
    const char * key = "";
    std::cout << "Invoking encode_config with subdoc name: " << subdoc.name 
              << " and key: (empty string)" << std::endl;
    int ret = dm_easy_mesh_obj.encode_config(&subdoc, key);
    std::cout << "Returned value: " << ret << std::endl;
    EXPECT_NE(0, ret);
    std::cout << "Exiting encode_config_empty_key_failure test" << std::endl;
}

/**
 * @brief Test the encode_config_op_class_array function with all valid operation class types
 *
 * This test verifies that the encode_config_op_class_array method of the dm_easy_mesh_t object correctly processes all valid operation class types. For each valid op class type, the method is invoked with a valid cJSON array and a predefined MAC address. The test asserts that the return value is 0 for each case.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 125@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | --------------- | ----- |
 * | 01 | Invoke encode_config_op_class_array with op class type em_op_class_type_none | arr_obj = valid cJSON array, op_class_type = em_op_class_type_none, mac = 0x00,0x11,0x22,0x33,0x44,0x55 | Returns 0 as return value and assertion EXPECT_EQ passes | Should Pass |
 * | 02 | Invoke encode_config_op_class_array with op class type em_op_class_type_current | arr_obj = valid cJSON array, op_class_type = em_op_class_type_current, mac = 0x00,0x11,0x22,0x33,0x44,0x55 | Returns 0 as return value and assertion EXPECT_EQ passes | Should Pass |
 * | 03 | Invoke encode_config_op_class_array with op class type em_op_class_type_capability | arr_obj = valid cJSON array, op_class_type = em_op_class_type_capability, mac = 0x00,0x11,0x22,0x33,0x44,0x55 | Returns 0 as return value and assertion EXPECT_EQ passes | Should Pass |
 * | 04 | Invoke encode_config_op_class_array with op class type em_op_class_type_cac_available | arr_obj = valid cJSON array, op_class_type = em_op_class_type_cac_available, mac = 0x00,0x11,0x22,0x33,0x44,0x55 | Returns 0 as return value and assertion EXPECT_EQ passes | Should Pass |
 * | 05 | Invoke encode_config_op_class_array with op class type em_op_class_type_cac_non_occ | arr_obj = valid cJSON array, op_class_type = em_op_class_type_cac_non_occ, mac = 0x00,0x11,0x22,0x33,0x44,0x55 | Returns 0 as return value and assertion EXPECT_EQ passes | Should Pass |
 * | 06 | Invoke encode_config_op_class_array with op class type em_op_class_type_cac_active | arr_obj = valid cJSON array, op_class_type = em_op_class_type_cac_active, mac = 0x00,0x11,0x22,0x33,0x44,0x55 | Returns 0 as return value and assertion EXPECT_EQ passes | Should Pass |
 * | 07 | Invoke encode_config_op_class_array with op class type em_op_class_type_preference | arr_obj = valid cJSON array, op_class_type = em_op_class_type_preference, mac = 0x00,0x11,0x22,0x33,0x44,0x55 | Returns 0 as return value and assertion EXPECT_EQ passes | Should Pass |
 * | 08 | Invoke encode_config_op_class_array with op class type em_op_class_type_anticipated | arr_obj = valid cJSON array, op_class_type = em_op_class_type_anticipated, mac = 0x00,0x11,0x22,0x33,0x44,0x55 | Returns 0 as return value and assertion EXPECT_EQ passes | Should Pass |
 * | 09 | Invoke encode_config_op_class_array with op class type em_op_class_type_scan_param | arr_obj = valid cJSON array, op_class_type = em_op_class_type_scan_param, mac = 0x00,0x11,0x22,0x33,0x44,0x55 | Returns 0 as return value and assertion EXPECT_EQ passes | Should Pass |
 */
TEST(dm_easy_mesh_t, encode_config_op_class_array_all_valid_types)
{
    std::cout << "Entering encode_config_op_class_array_all_valid_types test" << std::endl;
    dm_easy_mesh_t obj;
    // All valid operation class types
    em_op_class_type_t valid_types[] = {
        em_op_class_type_none,
        em_op_class_type_current,
        em_op_class_type_capability,
        em_op_class_type_cac_available,
        em_op_class_type_cac_non_occ,
        em_op_class_type_cac_active,
        em_op_class_type_preference,
        em_op_class_type_anticipated,
        em_op_class_type_scan_param
    };
    unsigned char mac[6] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
    for (auto type : valid_types)
    {
        std::cout << "\nInvoking encode_config_op_class_array with op class type: " << static_cast<int>(type) << std::endl;
        printMacAddress(mac);
        cJSON *arr_obj = create_valid_cJSON_array();
        ASSERT_NE(arr_obj, nullptr);
        int ret = obj.encode_config_op_class_array(arr_obj, type, mac);
        std::cout << "Returned value: " << ret << std::endl;
        EXPECT_EQ(ret, 0) << "Failed for op class type: " << static_cast<int>(type);
        delete arr_obj;
    }
    std::cout << "Exiting encode_config_op_class_array_all_valid_types test" << std::endl;
}

/**
 * @brief Checks that encode_config_op_class_array fails with a null JSON object.
 *
 * This test verifies that the encode_config_op_class_array API returns an error (-1) when provided with a NULL cJSON 
 * object. The test creates an instance of dm_easy_mesh_t, assigns a NULL pointer for the JSON object, initializes a MAC 
 * address, and then calls the API with these parameters. The expected behavior is the API's graceful failure with an error 
 * code, ensuring proper handling of invalid input.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 126@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke encode_config_op_class_array with a NULL cJSON object and valid MAC address | arr_obj = NULL, op_class = em_op_class_type_current, mac = {0x00,0x11,0x22,0x33,0x44,0x55} | Returns -1; Assertion EXPECT_EQ(ret, -1) passes | Should Fail |
 */
TEST(dm_easy_mesh_t, encode_config_op_class_array_failure_null_json)
{
    std::cout << "Entering encode_config_op_class_array_failure_null_json test" << std::endl;
    dm_easy_mesh_t obj;
    cJSON *arr_obj = NULL;
    unsigned char mac[6] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
    std::cout << "Invoking encode_config_op_class_array with NULL cJSON object" << std::endl;
    printMacAddress(mac);
    int ret = obj.encode_config_op_class_array(arr_obj, em_op_class_type_current, mac);
    std::cout << "Returned value: " << ret << std::endl;
    EXPECT_EQ(ret, -1);    
    std::cout << "Exiting encode_config_op_class_array_failure_null_json test" << std::endl;
}

/**
 * @brief Verify that encode_config_op_class_array fails when provided with a NULL MAC address
 *
 * This test evaluates the encode_config_op_class_array method of the dm_easy_mesh_t class by passing
 * a valid cJSON array and a NULL MAC address. The objective is to ensure the function returns an error (-1)
 * for an invalid MAC input, validating proper error handling for negative scenarios.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 127@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                       | Test Data                                                                      | Expected Result                                          | Notes         |
 * | :--------------: | ----------------------------------------------------------------- | ------------------------------------------------------------------------------ | -------------------------------------------------------- | ------------- |
 * | 01               | Initialize test object and create a valid cJSON array             | obj: instance of dm_easy_mesh_t, arr_obj: created by create_valid_cJSON_array()  | arr_obj should be a valid cJSON array                     | Should be successful |
 * | 02               | Set MAC address to NULL and invoke encode_config_op_class_array API | arr_obj: valid cJSON array, op_class: em_op_class_type_current, mac: NULL       | API returns -1 indicating error; EXPECT_EQ(ret, -1)       | Should Fail   |
 * | 03               | Clean up allocated memory                                         | delete arr_obj                                                                 | Memory is successfully freed                           | Should be successful |
 */
TEST(dm_easy_mesh_t, encode_config_op_class_array_failure_null_mac)
{
    std::cout << "Entering encode_config_op_class_array_failure_null_mac test" << std::endl;
    dm_easy_mesh_t obj;
    cJSON *arr_obj = create_valid_cJSON_array();
    unsigned char *mac = NULL;
    std::cout << "Invoking encode_config_op_class_array with NULL MAC address" << std::endl;    
    int ret = obj.encode_config_op_class_array(arr_obj, em_op_class_type_current, mac);
    std::cout << "Returned value: " << ret << std::endl;    
    EXPECT_EQ(ret, -1);    
    delete arr_obj;
    std::cout << "Exiting encode_config_op_class_array_failure_null_mac test" << std::endl;
}

/**
 * @brief Test failure of encode_config_op_class_array when an invalid op class type is provided
 *
 * This test validates that the encode_config_op_class_array API correctly handles an invalid op class type by returning -1.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 128@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                          | Test Data                                                                                                             | Expected Result                                      | Notes           |
 * | :--------------: | ---------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- | --------------- |
 * | 01               | Setup test objects and initialize test data by creating a valid cJSON array, a valid MAC address, and setting an invalid op class type (99) | obj (instance of dm_easy_mesh_t), arr_obj (cJSON array), mac = {0x00,0x11,0x22,0x33,0x44,0x55}, invalidType = 99           | Test objects and data are successfully initialized   | Should be successful |
 * | 02               | Invoke encode_config_op_class_array with the invalid op class type and log the operation                | arr_obj, invalidType (99), mac = {0x00,0x11,0x22,0x33,0x44,0x55}                                                      | API returns an error code (-1)                       | Should Fail     |
 * | 03               | Validate the API return value by asserting that the returned value is -1                              | ret = return value from encode_config_op_class_array call (expected -1)                                                 | ret equals -1                                        | Should Pass     |
 * | 04               | Cleanup allocated resources by deleting the created cJSON array                                     | delete arr_obj                                                                                                        | Resources are successfully released                  | Should be successful |
 */
TEST(dm_easy_mesh_t, encode_config_op_class_array_failure_invalid_optype)
{
    std::cout << "Entering encode_config_op_class_array_failure_invalid_optype test" << std::endl;
    dm_easy_mesh_t obj;
    cJSON *arr_obj = create_valid_cJSON_array();
    unsigned char mac[6] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
    em_op_class_type_t invalidType = static_cast<em_op_class_type_t>(99);    
    std::cout << "Invoking encode_config_op_class_array with invalid op class type (99)" << std::endl;
    printMacAddress(mac);    
    int ret = obj.encode_config_op_class_array(arr_obj, invalidType, mac);
    std::cout << "Returned value: " << ret << std::endl;    
    EXPECT_EQ(ret, -1);    
    delete arr_obj;
    std::cout << "Exiting encode_config_op_class_array_failure_invalid_optype test" << std::endl;
}

/**
 * @brief Verify that encode_config_op_class_array returns an error when provided an invalid JSON type.
 *
 * This test validates that the function encode_config_op_class_array correctly identifies a non-array cJSON object
 * as invalid input. It is important to ensure that the API does not process inappropriate JSON types and returns the expected error value (-1) when such a scenario is encountered.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 129@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                     | Test Data                                                                                          | Expected Result                                           | Notes           |
 * | :--------------: | ----------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | --------------------------------------------------------- | --------------- |
 * | 01               | Initialize test objects: print entry log, create an invalid cJSON object, and define MAC address. | arr_obj = create_invalid_cJSON_object(), mac = {0x00,0x11,0x22,0x33,0x44,0x55}                    | Test objects are correctly initialized                  | Should be successful |
 * | 02               | Invoke encode_config_op_class_array with the invalid non-array cJSON object and log its output.    | input: arr_obj, em_op_class_type_current, mac; output: ret                                         | ret equals -1 and EXPECT_EQ check passes                  | Should Pass     |
 * | 03               | Clean up by deleting the allocated cJSON object and log exit of the test.                        | delete arr_obj                                                                                    | Allocated memory is successfully freed and test concludes | Should be successful |
 */
TEST(dm_easy_mesh_t, encode_config_op_class_array_failure_invalid_json_type)
{
    std::cout << "Entering encode_config_op_class_array_failure_invalid_json_type test" << std::endl;
    dm_easy_mesh_t obj;
    cJSON *arr_obj = create_invalid_cJSON_object();
    unsigned char mac[6] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};    
    std::cout << "Invoking encode_config_op_class_array with non-array cJSON object" << std::endl;
    printMacAddress(mac);    
    int ret = obj.encode_config_op_class_array(arr_obj, em_op_class_type_current, mac);
    std::cout << "Returned value: " << ret << std::endl;    
    EXPECT_EQ(ret, -1);    
    delete arr_obj;
    std::cout << "Exiting encode_config_op_class_array_failure_invalid_json_type test" << std::endl;
}

/**
 * @brief Validate the encode_config_reset function with valid subdocument and key.
 *
 * This test verifies that the encode_config_reset API successfully processes a valid subdocument with the name "config" and a valid key "wfa-dataelements:Reset". It ensures that the method returns 0, indicating successful execution.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 130@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Print test entrance message | None | Logs message indicating test entry | Should be successful |
 * | 02 | Create dm_easy_mesh_t instance and initialize subdoc.name with "config" | subdoc.name = "config" | subdoc.name is correctly set to "config" | Should be successful |
 * | 03 | Set key to "wfa-dataelements:Reset" | key = "wfa-dataelements:Reset" | key variable holds the correct string value | Should be successful |
 * | 04 | Invoke encode_config_reset API with subdoc and key | input: subdoc.name = "config", key = "wfa-dataelements:Reset"; output: ret value expected | Returns ret = 0 from encode_config_reset API | Should Pass |
 * | 05 | Validate API return value equals 0 using EXPECT_EQ | ret = 0 | EXPECT_EQ assertion passes confirming return value is 0 | Should Pass |
 * | 06 | Print test exit message | None | Logs message indicating test exit | Should be successful |
 */
TEST(dm_easy_mesh_t, encode_config_reset_validSubdoc_validKey) {
    std::cout << "Entering encode_config_reset_validSubdoc_validKey test" << std::endl;
    dm_easy_mesh_t dm;
    em_subdoc_info_t subdoc;    
    strncpy(subdoc.name, "config", sizeof(subdoc.name)-1);
    subdoc.name[sizeof(subdoc.name)-1] = '\0';    
    const char* key = "wfa-dataelements:Reset";    
    std::cout << "Invoking encode_config_reset with subdoc.name: " << subdoc.name << " and key: " << key << std::endl;              
    int ret = dm.encode_config_reset(&subdoc, key);    
    std::cout << "Method returned: " << ret << std::endl;    
    EXPECT_EQ(ret, 0);
    std::cout << "Exiting encode_config_reset_validSubdoc_validKey test" << std::endl;
}

/**
 * @brief Validate that encode_config_reset returns an error when passed a NULL subdoc with a valid key.
 *
 * This test verifies that the encode_config_reset method correctly handles a NULL sub-document pointer by returning an error code (-1) when a valid key ("wfa-dataelements:Reset") is provided. This ensures that the API properly validates the null pointer input and prevents processing, which is critical for robust error handling.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 131@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                     | Test Data                                                                                          | Expected Result                                                    | Notes              |
 * | :--------------: | ----------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ | ------------------ |
 * | 01               | Initialize the dm_easy_mesh_t instance, set subdoc to NULL, and assign the valid key.           | dm_easy_mesh_t instance, subdoc = nullptr, key = "wfa-dataelements:Reset"                          | Variables initialized without error.                               | Should be successful |
 * | 02               | Invoke encode_config_reset with the NULL subdoc and valid key.                                  | input: subdoc = nullptr, key = "wfa-dataelements:Reset"                                            | API returns -1 indicating invalid subdoc input.                    | Should Fail         |
 * | 03               | Verify via assertion that the return value is -1.                                             | output: ret = -1                                                                                   | EXPECT_EQ returns true confirming failure as expected.             | Should be successful |
 */
TEST(dm_easy_mesh_t, encode_config_reset_nullSubdoc_validKey) {
    std::cout << "Entering encode_config_reset_nullSubdoc_validKey test" << std::endl;
    dm_easy_mesh_t dm;
    em_subdoc_info_t* subdoc = nullptr;
    const char* key = "wfa-dataelements:Reset";
    std::cout << "Invoking encode_config_reset with subdoc: " << "NULL" << " and key: " << key << std::endl;
    int ret = dm.encode_config_reset(subdoc, key);
    std::cout << "Method returned: " << ret << std::endl;
    EXPECT_EQ(ret, -1);
    std::cout << "Exiting encode_config_reset_nullSubdoc_validKey test" << std::endl;
}

/**
 * @brief Verify that encode_config_reset returns error when provided a null key with a valid subdocument.
 *
 * This test validates that passing a null key to the encode_config_reset API, while using a properly initialized subdocument,
 * results in an error response (-1). The test ensures that the API correctly handles and rejects null key inputs.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 132@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                   | Test Data                                         | Expected Result                                        | Notes       |
 * | :---------------:| -------------------------------------------------------------- | ------------------------------------------------- | -------------------------------------------------------| ----------- |
 * | 01               | Call encode_config_reset with a valid subdoc and null key input  | subdoc.name = "config", key = nullptr, output: ret expected = -1 | API returns -1 and the assertion EXPECT_EQ(ret, -1) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, encode_config_reset_validSubdoc_nullKey) {
    std::cout << "Entering encode_config_reset_validSubdoc_nullKey test" << std::endl;
    dm_easy_mesh_t dm;    
    em_subdoc_info_t subdoc;
    strncpy(subdoc.name, "config", sizeof(subdoc.name)-1);
    subdoc.name[sizeof(subdoc.name)-1] = '\0';    
    const char* key = nullptr;    
    std::cout << "Invoking encode_config_reset with subdoc.name: " << subdoc.name << " and key: " << "NULL" << std::endl;              
    int ret = dm.encode_config_reset(&subdoc, key);    
    std::cout << "Method returned: " << ret << std::endl;    
    EXPECT_EQ(ret, -1);    
    std::cout << "Exiting encode_config_reset_validSubdoc_nullKey test" << std::endl;
}

/**
 * @brief Validate that encode_config_reset returns an error when provided with a valid subdocument and an empty key.
 *
 * This test verifies that the API function encode_config_reset correctly handles the scenario where a valid subdocument (with subdoc.name set to "config") is provided along with an empty key. The expected behavior is for the function to return an error (-1) since an empty key is not acceptable.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 133@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                                 | Test Data                                                            | Expected Result                                             | Notes           |
 * | :--------------: | ----------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- | ---------------------------------------------------------- | --------------- |
 * | 01               | Initialize the dm_easy_mesh_t instance and set subdoc.name to "config" with key as an empty string          | dm_easy_mesh_t instance, subdoc.name = "config", key = ""             | Objects are successfully initialized                      | Should be successful |
 * | 02               | Invoke encode_config_reset with the valid subdoc and an empty key, then check that the return value is -1      | subdoc: { name = "config" }, key: (empty string), ret = -1 expected     | API returns -1 indicating failure due to empty key         | Should Fail     |
 */
TEST(dm_easy_mesh_t, encode_config_reset_validSubdoc_emptyKey) {
    std::cout << "Entering encode_config_reset_validSubdoc_emptyKey test" << std::endl;
    dm_easy_mesh_t dm;    
    em_subdoc_info_t subdoc{};
    strncpy(subdoc.name, "config", sizeof(subdoc.name)-1);
    subdoc.name[sizeof(subdoc.name)-1] = '\0';    
    const char* key = "";
    std::cout << "Invoking encode_config_reset with subdoc.name: " << subdoc.name << " and key: " << "(empty string)" << std::endl;             
    int ret = dm.encode_config_reset(&subdoc, key);    
    std::cout << "Method returned: " << ret << std::endl;    
    EXPECT_EQ(ret, -1);    
    std::cout << "Exiting encode_config_reset_validSubdoc_emptyKey test" << std::endl;
}

/**
 * @brief This test verifies that the encode_config_test API correctly encodes the configuration information using a valid subdocument and a valid key.
 *
 * This test ensures that when a valid subdocument (with a valid name) and a valid key are provided as inputs to the encode_config_test API, the configuration encoding operation executes successfully and returns the expected value. This validation helps confirm that the API handles valid configurations correctly.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 134@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize subdocument with valid name and key, then invoke the encode_config_test API | subdoc.name = valid_name, key = test_key, output: result = 0 | API returns 0 and assertion EXPECT_EQ(result, 0) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, encode_config_test_valid_subdoc_and_valid_key)
{
    std::cout << "Entering encode_config_test_valid_subdoc_and_valid_key test" << std::endl;
    em_subdoc_info_t subdoc{};
    strncpy(subdoc.name, "valid_name", sizeof(subdoc.name));   
    const char* key = "test_key";
    std::cout << "Invoking encode_config_test with subdoc->name: " << subdoc.name << " and key: " << key << std::endl;    
    dm_easy_mesh_t dm;
    int result = dm.encode_config_test(&subdoc, key);
    std::cout << "Returned value: " << result << std::endl;    
    EXPECT_EQ(result, 0);
    std::cout << "Exiting encode_config_test_valid_subdoc_and_valid_key test" << std::endl;
}

/**
 * @brief Validate that the encode_config_test API returns an error when provided with a valid subdoc name but an empty key.
 *
 * This test verifies that the encode_config_test function correctly handles the scenario where a valid subdocument name is supplied along with an empty key. It checks that the API returns -1, indicating the handling of invalid input.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 135@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                  | Test Data                                     | Expected Result                | Notes       |
 * | :----:           | ------------------------------------------------------------ | --------------------------------------------- | ------------------------------ | ----------- |
 * | 01               | Call encode_config_test with a valid subdoc name ("valid_name") and an empty key ("") | subdoc.name = valid_name, key = ""   | Expected method return value: -1 | Should Pass |
 */
TEST(dm_easy_mesh_t, encode_config_test_valid_subdoc_and_empty_key)
{
    std::cout << "Entering encode_config_test_valid_subdoc_and_empty_key test" << std::endl;
    em_subdoc_info_t subdoc;
    strncpy(subdoc.name, "valid_name", sizeof(subdoc.name));    
    const char* key = "";
    std::cout << "Invoking encode_config_test with subdoc->name: " << subdoc.name << " and empty key" << std::endl;    
    dm_easy_mesh_t dm;
    int result = dm.encode_config_test(&subdoc, key);
    std::cout << "Returned value: " << result << std::endl;    
    EXPECT_EQ(result, -1);
    std::cout << "Exiting encode_config_test_valid_subdoc_and_empty_key test" << std::endl;
}

/**
 * @brief Test the encode_config_test API using a NULL subdocument pointer with a valid key
 *
 * This test verifies that when a NULL pointer is passed as the subdocument and a valid key is provided,
 * the encode_config_test API returns -1 as expected. This behavior is critical to ensure that the API
 * correctly handles invalid input parameters.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 136@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                            | Test Data                                      | Expected Result                                       | Notes         |
 * | :--------------: | ---------------------------------------------------------------------- | ---------------------------------------------- | ----------------------------------------------------- | ------------- |
 * | 01               | Prepare test inputs with a valid key and NULL subdocument pointer        | subdoc = NULL, key = test_key                  | Test inputs are correctly initialized                | Should be successful |
 * | 02               | Invoke encode_config_test API and verify it returns -1                   | input: subdoc = NULL, key = test_key, expected output = -1 | API returns -1 and assertion (EXPECT_EQ) passes | Should Pass   |
 */
TEST(dm_easy_mesh_t, encode_config_test_null_subdoc_and_valid_key)
{
    std::cout << "Entering encode_config_test_null_subdoc_and_valid_key test" << std::endl;
    const char* key = "test_key";
    std::cout << "Invoking encode_config_test with subdoc pointer as NULL and key: " << key << std::endl;    
    dm_easy_mesh_t dm;
    int result = dm.encode_config_test(NULL, key);
    std::cout << "Returned value: " << result << std::endl;    
    EXPECT_EQ(result, -1);
    std::cout << "Exiting encode_config_test_null_subdoc_and_valid_key test" << std::endl;
}

/**
 * @brief Verify that encode_config_test correctly handles a valid subdocument and a NULL key
 *
 * This test verifies that the encode_config_test method returns -1 when provided with a valid subdocument having a proper name and a NULL key pointer. It is important to ensure that the method gracefully handles a NULL key without causing a crash or undefined behavior.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 137@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                     | Test Data                                               | Expected Result                                          | Notes        |
 * | :--------------: | ----------------------------------------------------------------------------------------------- | ------------------------------------------------------- | -------------------------------------------------------- | ------------ |
 * | 01               | Initialize a valid subdocument with name "valid_name", set key as NULL, and invoke the API call | subdoc.name = valid_name, key = NULL, output: result = ?  | Returned value equals -1 with EXPECT_EQ assertion check  | Should Pass  |
 */
TEST(dm_easy_mesh_t, encode_config_test_valid_subdoc_and_null_key)
{
    std::cout << "Entering encode_config_test_valid_subdoc_and_null_key test" << std::endl;
    em_subdoc_info_t subdoc;
    strncpy(subdoc.name, "valid_name", sizeof(subdoc.name));    
    const char* key = NULL;
    std::cout << "Invoking encode_config_test with subdoc->name: " << subdoc.name << " and key pointer as NULL" << std::endl;    
    dm_easy_mesh_t dm;
    int result = dm.encode_config_test(&subdoc, key);
    std::cout << "Returned value: " << result << std::endl;
    EXPECT_EQ(result, -1);
    std::cout << "Exiting encode_config_test_valid_subdoc_and_null_key test" << std::endl;
}

/**
 * @brief Verify that encode_config_test returns error when subdocument name is empty and key is valid
 *
 * This test ensures that when an empty subdocument name is provided along with a valid key, the encode_config_test API
 * correctly returns an error code (-1). This helps validate the API's input verification and error handling mechanisms.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 138@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                       | Test Data                                                                  | Expected Result                                                        |Notes        |
 * | :--------------: | --------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | ---------------------------------------------------------------------- | ----------- |
 * | 01               | Initialize subdoc with an empty name, set valid key, and invoke encode_config_test  | subdoc.name = "", key = "test_key", output = -1                            | API returns -1 and EXPECT_EQ(result, -1) assertion passes                | Should Pass |
 */
TEST(dm_easy_mesh_t, encode_config_test_empty_name_and_valid_key)
{
    std::cout << "Entering encode_config_test_empty_name_and_valid_key test" << std::endl;
    em_subdoc_info_t subdoc;
    strncpy(subdoc.name, "", sizeof(subdoc.name));    
    const char* key = "test_key";
    std::cout << "Invoking encode_config_test with empty subdoc->name and key: " << key << std::endl;    
    dm_easy_mesh_t dm;
    int result = dm.encode_config_test(&subdoc, key);
    std::cout << "Returned value: " << result << std::endl;    
    EXPECT_EQ(result, -1);
    std::cout << "Exiting encode_config_test_empty_name_and_valid_key test" << std::endl;
}

/**
 * @brief Test the functionality of find_matching_bss for a valid matching BSS
 *
 * This test verifies that the find_matching_bss function correctly identifies and returns a valid BSS when provided with a BSS identifier (id) that matches a pre-injected BSS in the mesh. Each haul type is iterated over, the mesh is appropriately initialized with valid network identifiers and MAC addresses, and then the matching BSS is retrieved and validated.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 139@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize test environment including test name, haul types array, and mesh object with a BSS count of 1. | testName = "find_matching_bss_valid_matching_bss", haulTypes = [em_haul_type_fronthaul, em_haul_type_backhaul, em_haul_type_iot, em_haul_type_configurator, em_haul_type_hotspot], mesh.m_num_bss = 1 | Test environment is successfully initialized. | Should be successful |
 * | 02 | Set up a valid BSS identifier with net_id "valid_net" and a predefined MAC address for dev_mac, ruid, and bssid for each haul type. | id.net_id = "valid_net", id.dev_mac = {0x10,0x11,0x22,0x33,0x44,0x55}, id.ruid = {0x10,0x11,0x22,0x33,0x44,0x55}, id.bssid = {0x10,0x11,0x22,0x33,0x44,0x55}, id.haul_type = current haulTypes[i] | BSS structure is populated with matching identifier values. | Should be successful |
 * | 03 | Inject the matching BSS into the mesh object by copying the identifier fields from the created id into mesh.m_bss[0]. | mesh.m_bss[0].m_bss_info.id.net_id = "valid_net", mesh.m_bss[0].m_bss_info.id fields copied with MAC address values, haul_type = current haulTypes[i] | Mesh object has a correctly injected matching BSS. | Should be successful |
 * | 04 | Invoke find_matching_bss with the constructed id and validate that the returned pointer is not null as well as the net_id and haul_type match the expected values. | Input id as constructed, output from find_matching_bss, EXPECT_NE(result, nullptr), EXPECT_STREQ(net_id), EXPECT_EQ(haul_type) | find_matching_bss returns a valid pointer with matching net_id and haul_type for each iteration. | Should Pass |
 */
TEST(dm_easy_mesh_t, find_matching_bss_valid_matching_bss)
{
    const char* testName = "find_matching_bss_valid_matching_bss";
    std::cout << "Entering " << testName << " test" << std::endl;
    em_haul_type_t haulTypes[] = {
        em_haul_type_fronthaul,
        em_haul_type_backhaul,
        em_haul_type_iot,
        em_haul_type_configurator,
        em_haul_type_hotspot
    };
    const int numTypes = sizeof(haulTypes) / sizeof(haulTypes[0]);
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 1;
    unsigned char mac_val[6] = { 0x10, 0x11, 0x22, 0x33, 0x44, 0x55 };
    for (int i = 0; i < numTypes; i++)
    {
        em_bss_id_t id{};
        strcpy(id.net_id, "valid_net");
        memcpy(id.dev_mac, mac_val, sizeof(mac_address_t));
        memcpy(id.ruid, mac_val, sizeof(mac_address_t));
        memcpy(id.bssid, mac_val, sizeof(mac_address_t));
        id.haul_type = haulTypes[i];
        // inject matching BSS into mesh
        strcpy(mesh.m_bss[0].m_bss_info.id.net_id, "valid_net");
        memcpy(mesh.m_bss[0].m_bss_info.id.dev_mac, mac_val, sizeof(mac_address_t));
        memcpy(mesh.m_bss[0].m_bss_info.id.ruid, mac_val, sizeof(mac_address_t));
        memcpy(mesh.m_bss[0].m_bss_info.id.bssid, mac_val, sizeof(mac_address_t));
        mesh.m_bss[0].m_bss_info.id.haul_type = haulTypes[i];
        std::cout << "Invoking find_matching_bss with id: { net_id: " << id.net_id
                  << ", haul_type: " << static_cast<int>(id.haul_type) << " }" << std::endl;
        dm_bss_t* result = mesh.find_matching_bss(&id);
        EXPECT_NE(result, nullptr);
        if (result != nullptr) {
            EXPECT_STREQ(result->m_bss_info.id.net_id, id.net_id);
            EXPECT_EQ(result->m_bss_info.id.haul_type, id.haul_type);
        }
    }
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify find_matching_bss returns a null pointer when no matching BSS is found
 *
 * This test verifies that the find_matching_bss API correctly returns a null pointer
 * when no BSS matches the given criteria. The BSS identifier is initialized with a 
 * net_id that does not exist and with MAC addresses set to a distinct value, ensuring
 * that no valid BSS is found in the dm_easy_mesh_t instance.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 140@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                  | Test Data                                                                                                                                                           | Expected Result                                                                               | Notes       |
 * | :--------------: | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ----------- |
 * | 01               | Initialize BSS ID with non-existent values, invoke find_matching_bss         | net_id = "nonexistent_net", dev_mac = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF}, ruid = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF}, bssid = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF}, haul_type = em_haul_type_fronthaul | Return value should be nullptr; EXPECT_EQ(result, nullptr) assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, find_matching_bss_no_matching_bss)
{
    const char* testName = "find_matching_bss_no_matching_bss";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    em_bss_id_t id;
    memset(&id, 0, sizeof(em_bss_id_t));
    std::strcpy(id.net_id, "nonexistent_net");
    unsigned char mac_val_diff[6] = { 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF };
    memcpy(&id.dev_mac, mac_val_diff, sizeof(mac_val_diff));
    memcpy(&id.ruid, mac_val_diff, sizeof(mac_val_diff));
    memcpy(&id.bssid, mac_val_diff, sizeof(mac_val_diff));
    id.haul_type = em_haul_type_fronthaul;
    std::cout << "Invoking find_matching_bss with id: { net_id: " << id.net_id << ", haul_type: " << static_cast<int>(id.haul_type) << " }" << std::endl;
    dm_bss_t* result = mesh.find_matching_bss(&id);
    EXPECT_EQ(result, nullptr);
    if(result == nullptr)
    {
        std::cout << "Method returned NULL pointer as expected for no matching BSS." << std::endl;
    }
    else
    {
        em_bss_info_t* ret_info = &result->m_bss_info;
        std::cout << "Method unexpectedly returned non-NULL pointer. BSS info: { net_id: " 
                  << ret_info->id.net_id << ", haul_type: " << static_cast<int>(ret_info->id.haul_type)
                  << " }" << std::endl;
    }
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test to verify the behavior of find_matching_bss when provided with a NULL input.
 *
 * This test case validates that the find_matching_bss function correctly handles a NULL pointer input by returning a NULL pointer. This ensures that the API gracefully handles invalid inputs.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 141@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                  | Test Data                                                                | Expected Result                                            | Notes       |
 * | :--------------: | -------------------------------------------- | ------------------------------------------------------------------------ | ---------------------------------------------------------- | ----------- |
 * | 01               | Invoke find_matching_bss with a NULL pointer | input: pointer = nullptr, output: result should be nullptr               | The API should return a NULL pointer                       | Should Pass |
 */
TEST(dm_easy_mesh_t, find_matching_bss_null_input)
{
    const char* testName = "find_matching_bss_null_input";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    std::cout << "Invoking find_matching_bss with NULL as input" << std::endl;
    dm_bss_t* result = mesh.find_matching_bss(nullptr);
	EXPECT_EQ(result, nullptr);
    if(result == nullptr)
    {
        std::cout << "Method returned NULL pointer as expected when provided NULL input." << std::endl;
    }
    else
    {
        em_bss_info_t* ret_info = &result->m_bss_info;
        std::cout << "Method unexpectedly returned non-NULL pointer. BSS info: { net_id: " 
                  << ret_info->id.net_id << ", haul_type: " << static_cast<int>(ret_info->id.haul_type)
                  << " }" << std::endl;
    }    
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that find_matching_device returns the matching device when provided with a device having a matching MAC address
 *
 * This test sets up a dm_easy_mesh_t instance with an internal device whose MAC address is initialized with specific values.
 * It then creates a dm_device_t instance with the same MAC address and invokes find_matching_device, expecting a non-null pointer
 * to be returned indicating a successful match.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 142@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                               | Test Data                                                              | Expected Result                                                                          | Notes        |
 * | :--------------: | ----------------------------------------------------------------------------------------- | ---------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- | ------------ |
 * | 01               | Initialize dm_easy_mesh_t instance and set its internal device MAC address                  | internal_mac = 0x01,0x02,0x03,0x04,0x05,0x06; mesh.m_device.m_device_info.intf.mac set accordingly | Device initialized with correct MAC address                                               | Should be successful |
 * | 02               | Initialize dm_device_t instance and set its device MAC address with the same values           | internal_mac = 0x01,0x02,0x03,0x04,0x05,0x06; dev.m_device_info.intf.mac set accordingly  | Device initialized with correct MAC address                                               | Should be successful |
 * | 03               | Invoke find_matching_device with the device having matching MAC address                       | input: pointer to dev (with matching MAC)                             | Returned pointer is non-null; assertion EXPECT_NE(result, nullptr) holds true                | Should Pass  |
 * | 04               | Retrieve and display the device interface name from the returned device (if non-null)          | output: result->get_dev_interface_name()                                | Successfully retrieve and display the device interface name (logged output)                  | Should be successful |
 */
TEST(dm_easy_mesh_t, find_matching_device_matching_device)
{
    std::cout << "Entering find_matching_device_matching_device test" << std::endl;
    dm_easy_mesh_t mesh;
    unsigned char internal_mac[6] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06 };
    memcpy(mesh.m_device.m_device_info.intf.mac, internal_mac, sizeof(internal_mac));    
    std::cout << "Internal device set with MAC = ";
    for (int i = 0; i < 6; i++) { std::cout << std::hex << static_cast<int>(internal_mac[i]) << " "; }
    dm_device_t dev;
    memcpy(dev.m_device_info.intf.mac, internal_mac, sizeof(internal_mac));
    std::cout << "Invoking find_matching_device with matching device" << std::endl;
    dm_device_t* result = mesh.find_matching_device(&dev);
    EXPECT_NE(result, nullptr);
    if (result)
    {
        char* res_intf = result->get_dev_interface_name();
        std::cout << "Returned device Interface Name = " << res_intf << std::endl;
    }
    else
    {
        std::cout << "Returned device is NULL" << std::endl;
    }       
    std::cout << "Exiting find_matching_device_matching_device test" << std::endl;
}

/**
 * @brief Test for verifying that find_matching_device returns nullptr for a non-matching device
 *
 * This test verifies that when an external device with a non-matching MAC address is provided,
 * the function find_matching_device correctly fails to find a matching device and returns nullptr.
 * The test sets up an internal device with a specific MAC address and an external device with a different MAC,
 * ensuring that the function distinguishes between matching and non-matching devices.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 143@n
 * **Priority:** High
 * 
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                         | Test Data                                                                                              | Expected Result                          | Notes           |
 * | :--------------: | ------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ | ---------------------------------------- | --------------- |
 * | 01               | Set the internal device MAC address                                 | internal_mac = {0x01,0x02,0x03,0x04,0x05,0x06}                                                          | Internal device MAC is set correctly     | Should be successful |
 * | 02               | Set the external device MAC with a non-matching value                 | nonmatch_mac = {0xFF,0xEE,0xDD,0xCC,0xBB,0xAA}                                                          | External device MAC is set correctly     | Should be successful |
 * | 03               | Invoke find_matching_device with the external device                  | input: mesh instance, dev pointer with nonmatch_mac                                                      | API returns nullptr as no matching device is found | Should Pass     |
 * | 04               | Validate the result and log the output                                | output: result pointer = nullptr                                                                       | Logging confirms that the returned device pointer is NULL | Should be successful |
 */
TEST(dm_easy_mesh_t, find_matching_device_non_matching_device)
{
    std::cout << "Entering find_matching_device_non_matching_device test" << std::endl;
    dm_easy_mesh_t mesh;
    unsigned char internal_mac[6] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06 };
    memcpy(mesh.m_device.m_device_info.intf.mac, internal_mac, sizeof(internal_mac));    
    std::cout << "Internal device set with MAC = ";
    for (int i = 0; i < 6; i++) { std::cout << std::hex << static_cast<int>(internal_mac[i]) << " "; }
    // Create an external dm_device_t instance with different MAC address (non-matching)
    dm_device_t dev;    
    unsigned char nonmatch_mac[6] = { 0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA };
    memcpy(dev.m_device_info.intf.mac, nonmatch_mac, sizeof(nonmatch_mac));    
    std::cout << "External device created with MAC = ";
    for (int i = 0; i < 6; i++) { std::cout << std::hex << static_cast<int>(nonmatch_mac[i]) << " "; }
    // Invoke find_matching_device
    std::cout << "Invoking find_matching_device with non-matching device" << std::endl;
    dm_device_t* result = mesh.find_matching_device(&dev);
    EXPECT_EQ(result, nullptr);
    if (result)
    {
        char* res_intf = result->get_dev_interface_name();
        std::cout << "Returned device Interface Name = " << res_intf << std::endl;
    }
    else
    {
        std::cout << "Returned device is NULL" << std::endl;
    }    
    std::cout << "Exiting find_matching_device_non_matching_device test" << std::endl;
}

/**
 * @brief This test verifies that the find_matching_device function returns a nullptr when a NULL device pointer is provided.
 *
 * This test sets up an internal device with a predefined MAC address and then invokes the find_matching_device function with a NULL pointer.
 * The objective is to ensure the function safely handles a NULL input and returns a nullptr, with the EXPECT_EQ assertion verifying the result.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 144@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                             | Test Data                                                     | Expected Result                                                          | Notes      |
 * | :--------------: | ----------------------------------------------------------------------- | ------------------------------------------------------------- | ------------------------------------------------------------------------ | ---------- |
 * | 01               | Invoke find_matching_device with a NULL device pointer after setup      | input: device pointer = NULL, internal MAC = 0x01,0x02,0x03,0x04,0x05,0x06 | Returns nullptr; EXPECT_EQ(result, nullptr) assertion passes             | Should Pass |
 */
TEST(dm_easy_mesh_t, find_matching_device_null_device)
{
    std::cout << "Entering find_matching_device_null_device test" << std::endl;
    dm_easy_mesh_t mesh;
    // Setup the internal device with some values
    unsigned char internal_mac[6] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06 };
    memcpy(mesh.m_device.m_device_info.intf.mac, internal_mac, sizeof(internal_mac));    
    std::cout << "Internal device set with MAC = ";
    for (int i = 0; i < 6; i++) { std::cout << std::hex << static_cast<int>(internal_mac[i]) << " "; }
    // Invoke find_matching_device with NULL pointer
    std::cout << "Invoking find_matching_device with NULL device pointer" << std::endl;
    dm_device_t* result = mesh.find_matching_device(NULL);
    EXPECT_EQ(result, nullptr);
    if(result == nullptr)
    {
        std::cout << "Returned device is NULL as expected for NULL input." << std::endl;
    }
    else
    {
        std::cout << "Returned device Interface Name = " << result->get_dev_interface_name() << std::endl;
    }
    std::cout << "Exiting find_matching_device_null_device test" << std::endl;
}

/**
 * @brief Validate that find_matching_radio returns the matching radio when an exact MAC address is provided
 *
 * This test verifies that when the mesh is initialized with one radio having a specific MAC address and an input radio
 * with an identical MAC address is provided, the function find_matching_radio correctly returns the pointer to the matching radio.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 145@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                               | Test Data                                                                                   | Expected Result                                              | Notes           |
 * | :--------------: | ------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------ | --------------- |
 * | 01               | Initialize mesh and assign stored radio MAC address                       | mesh.m_num_radios = 1, stored_mac = 0xAA,0xBB,0xCC,0xDD,0xEE,0xFF                             | Mesh successfully initialized with stored radio MAC set      | Should be successful |
 * | 02               | Configure input radio with MAC matching the stored radio                  | inputRadio.m_radio_info.intf.mac = 0xAA,0xBB,0xCC,0xDD,0xEE,0xFF                           | Input radio correctly set with matching MAC                  | Should be successful |
 * | 03               | Invoke find_matching_radio API with the pointer to the input radio          | input pointer = &inputRadio                                                                  | Returns a non-null pointer indicating a matching radio found   | Should Pass     |
 * | 04               | Validate that the returned radio's MAC exactly matches the stored radio MAC | returned radio MAC compared to stored_mac (0xAA,0xBB,0xCC,0xDD,0xEE,0xFF)                     | memcmp returns 0, confirming the MAC addresses are an exact match | Should Pass     |
 */
TEST(dm_easy_mesh_t, find_matching_radio_ExactMatch)
{
    std::cout << "Entering find_matching_radio_ExactMatch test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mesh.m_num_radios = 1;
    unsigned char stored_mac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    // Set stored radio MAC
    memcpy(mesh.m_radio[0].m_radio_info.intf.mac, stored_mac, sizeof(mac_address_t));
    std::cout << "Stored radio MAC set to: ";
    for (auto b : stored_mac) std::cout << std::hex << (int)b << " ";
    std::cout << std::dec << std::endl;
    // Create input radio
    dm_radio_t inputRadio{};
    memcpy(inputRadio.m_radio_info.intf.mac, stored_mac, sizeof(mac_address_t));
    std::cout << "Input radio MAC set to: ";
    for (auto b : stored_mac) std::cout << std::hex << (int)b << " ";
    std::cout << std::dec << std::endl;
    std::cout << "Invoking find_matching_radio with input radio pointer" << std::endl;
    dm_radio_t* result = mesh.find_matching_radio(&inputRadio);
    EXPECT_NE(result, nullptr);
    if (result)
    {
        std::cout << "Returned radio found. MAC: ";
        for (auto b : result->m_radio_info.intf.mac)
            std::cout << std::hex << (int)b << " ";
        std::cout << std::dec << std::endl;
        EXPECT_EQ(memcmp(result->m_radio_info.intf.mac, stored_mac, sizeof(mac_address_t)), 0);
    }
    mesh.deinit();
    std::cout << "Exiting find_matching_radio_ExactMatch test" << std::endl;
}

/**
 * @brief Test to verify that find_matching_radio returns nullptr when the input radio MAC does not match any stored radio MAC.
 *
 * This test sets a known stored MAC address in the mesh object's radio and then creates an input radio with a different MAC address.
 * It then calls find_matching_radio to ensure that no matching radio is found, and the function returns a nullptr as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 146@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                          | Test Data                                                                                      | Expected Result                                                       | Notes         |
 * | :--------------: | -------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- | ------------- |
 * | 01               | Set stored radio MAC address in mesh object's m_radio at index 1.     | mesh.m_radio[1].m_radio_info.intf.mac = 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF                    | MAC address correctly stored and printed                              | Should be successful |
 * | 02               | Set input radio MAC address with a different value.                  | inputRadio.m_radio_info.intf.mac = 0x11, 0x22, 0x33, 0x44, 0x55, 0x66                           | MAC address correctly set and printed                                 | Should be successful |
 * | 03               | Invoke find_matching_radio with the input radio pointer.             | API call: result = mesh.find_matching_radio(&inputRadio)                                        | Returns nullptr indicating no matching radio was found; assertion passes | Should Pass   |
 */
TEST(dm_easy_mesh_t, find_matching_radio_NoMatch)
{
    std::cout << "Entering find_matching_radio_NoMatch test" << std::endl;
    dm_easy_mesh_t mesh;
    // Set stored radio's MAC address to a known value in mesh.m_radio
    unsigned char stored_mac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
	memcpy(mesh.m_radio[1].m_radio_info.intf.mac, stored_mac, sizeof(stored_mac));
    std::cout << "Stored radio MAC set to: ";
    for (size_t i = 0; i < sizeof(stored_mac); ++i)
    {
        std::cout << std::hex << static_cast<int>(mesh.m_radio[1].m_radio_info.intf.mac[i]) << " ";
    }
    std::cout << std::dec << std::endl;
    // Create an input radio with a different MAC address
    dm_radio_t inputRadio;
    unsigned char input_mac[6] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
    memcpy(inputRadio.m_radio_info.intf.mac, input_mac, sizeof(input_mac));
    std::cout << "Input radio MAC set to: ";
    for (size_t i = 0; i < sizeof(input_mac); ++i)
    {
        std::cout << std::hex << static_cast<int>(inputRadio.m_radio_info.intf.mac[i]) << " ";
    }
    std::cout << std::dec << std::endl;
    std::cout << "Invoking find_matching_radio with input radio pointer" << std::endl;
    dm_radio_t* result = mesh.find_matching_radio(&inputRadio);
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting find_matching_radio_NoMatch test" << std::endl;
}

/**
 * @brief Verify that the find_matching_radio API returns nullptr when provided with a partially matching radio MAC address.
 *
 * This test verifies that if a radio with a partially matching MAC address (only the first 3 bytes match)
 * is provided, the find_matching_radio API does not consider it a match and returns a nullptr.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 147@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                 | Test Data                                                                                     | Expected Result                                               | Notes           |
 * | :--------------: | --------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- | ------------------------------------------------------------- | --------------- |
 * | 01               | Set the stored radio's MAC address to a known full MAC value in the mesh.   | mesh.m_radio[0].m_radio_info.intf.mac = 0xAA,0xBB,0xCC,0xDD,0xEE,0xFF                           | The stored MAC in mesh is set correctly.                      | Should be successful |
 * | 02               | Set the input radio's MAC address with only a partial match (first 3 bytes).  | inputRadio.m_radio_info.intf.mac = 0xAA,0xBB,0xCC,0x00,0x00,0x00                               | The input radio MAC is set correctly.                         | Should be successful |
 * | 03               | Invoke find_matching_radio with the partially matching input radio pointer.   | input = pointer to inputRadio                                                                  | API returns nullptr as no full match is found.                | Should Fail    |
 * | 04               | Validate that the returned pointer from the API is nullptr.                 | result = nullptr                                                                               | The output from find_matching_radio is nullptr.               | Should be successful |
 */

TEST(dm_easy_mesh_t, find_matching_radio_PartialMatch)
{
    std::cout << "Entering find_matching_radio_PartialMatch test" << std::endl;
    dm_easy_mesh_t mesh;
    // Set stored radio's MAC address to a known value in mesh.m_radio
    unsigned char stored_mac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    memcpy(mesh.m_radio[0].m_radio_info.intf.mac, stored_mac, sizeof(stored_mac));
    std::cout << "Stored radio MAC set to: ";
    for (size_t i = 0; i < sizeof(stored_mac); ++i)
    {
        std::cout << std::hex << static_cast<int>(mesh.m_radio[0].m_radio_info.intf.mac[i]) << " ";
    }
    std::cout << std::dec << std::endl;
    // Create an input radio with partially matching MAC address (first 3 bytes same, rest different)
    dm_radio_t inputRadio;
    unsigned char partial_mac[6] = {0xAA, 0xBB, 0xCC, 0x00, 0x00, 0x00};
    memcpy(inputRadio.m_radio_info.intf.mac, partial_mac, sizeof(partial_mac));
    std::cout << "Input radio MAC set to: ";
    for (size_t i = 0; i < sizeof(partial_mac); ++i)
    {
        std::cout << std::hex << static_cast<int>(inputRadio.m_radio_info.intf.mac[i]) << " ";
    }
    std::cout << std::dec << std::endl;
    std::cout << "Invoking find_matching_radio with partially matching input radio pointer" << std::endl;
    dm_radio_t* result = mesh.find_matching_radio(&inputRadio);
    std::cout << "Returned pointer: " << result << std::endl;
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting find_matching_radio_PartialMatch test" << std::endl;
}

/**
 * @brief Validate that find_matching_radio returns nullptr when a null radio pointer is provided.
 *
 * This test verifies that the API find_matching_radio correctly handles a null radio input by
 * returning a nullptr. Ensuring proper null-checking in the API improves reliability and helps prevent
 * potential runtime errors.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 148@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                             | Test Data                           | Expected Result                                     | Notes              |
 * | :--------------: | ------------------------------------------------------- | ----------------------------------- | --------------------------------------------------- | ------------------ |
 * | 01               | Log the entry of the test                               | None                                | Console outputs entry message                       | Should be successful |
 * | 02               | Instantiate the dm_easy_mesh_t object                   | None                                | Object is constructed successfully                | Should be successful |
 * | 03               | Invoke find_matching_radio with radio = nullptr         | radio = nullptr                     | Returns a nullptr                                   | Should Pass        |
 * | 04               | Validate the returned result using EXPECT_EQ            | output: result = nullptr            | EXPECT_EQ confirms result equals nullptr            | Should Pass        |
 * | 05               | Log the exit of the test                                | None                                | Console outputs exit message                        | Should be successful |
 */
TEST(dm_easy_mesh_t, find_matching_radio_NullInput)
{
    std::cout << "Entering find_matching_radio_NullInput test" << std::endl;
    dm_easy_mesh_t mesh;
    std::cout << "Invoking find_matching_radio with radio = NULL" << std::endl;
    dm_radio_t* result = mesh.find_matching_radio(nullptr);    
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting find_matching_radio_NullInput test" << std::endl;
}

/**
 * @brief Verify that find_matching_scan_result returns the correct scan result when provided with a valid scan result ID.
 *
 * This test case validates that when a valid scan result ID is provided to the API find_matching_scan_result, it returns a matching scan result with all fields correctly set. The test first creates a scan result entry, then retrieves it using the API, and finally verifies that every attribute in the returned scan result matches the expected values.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 149@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Print entering test start message. | None | "Entering find_matching_scan_result_valid_match test" printed to console. | Should be successful |
 * | 02 | Initialize dm_easy_mesh_t instance and configure scan result ID with appropriate values. | id.net_id = "test_net", dev_mac = {0x10,0x11,0x12,0x13,0x14,0x15}, scanner_mac = {0x20,0x21,0x22,0x23,0x24,0x25}, op_class = 81, channel = 6, scanner_type = em_scanner_type_radio | Mesh instance is initialized and scan result ID is set correctly. | Should be successful |
 * | 03 | Invoke create_new_scan_result with the valid scan result ID. | input: pointer to id | Scan result entry is created within the mesh. | Should Pass |
 * | 04 | Invoke find_matching_scan_result with the valid scan result ID. | input: pointer to id, output: pointer to dm_scan_result_t | A non-null pointer is returned indicating a matching scan result was found. | Should Pass |
 * | 05 | Assert that the returned scan result fields match the expected values. | Comparisons: net_id, dev_mac, scanner_mac, op_class, channel, scanner_type | All assertions pass confirming that the returned scan result fields match the input. | Should Pass |
 * | 06 | Print exiting test message. | None | "Exiting find_matching_scan_result_valid_match test" printed to console. | Should be successful |
 */
TEST(dm_easy_mesh_t, find_matching_scan_result_valid_match)
{
    std::cout << "Entering find_matching_scan_result_valid_match test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    em_scan_result_id_t id{};
    strcpy(id.net_id, "test_net");
    unsigned char dev_mac[6]     = {0x10,0x11,0x12,0x13,0x14,0x15};
    unsigned char scanner_mac[6] = {0x20,0x21,0x22,0x23,0x24,0x25};
    memcpy(id.dev_mac, dev_mac, sizeof(dev_mac));
    memcpy(id.scanner_mac, scanner_mac, sizeof(scanner_mac));
    id.op_class     = 81;
    id.channel      = 6;
    id.scanner_type = em_scanner_type_radio;
    std::cout << "Creating scan result entry" << std::endl;
    mesh.create_new_scan_result(&id);
    std::cout << "Invoking find_matching_scan_result with valid ID" << std::endl;
    dm_scan_result_t* result = mesh.find_matching_scan_result(&id);
    EXPECT_NE(result, nullptr);
    if (result) {
        EXPECT_STREQ(result->m_scan_result.id.net_id, id.net_id);
        EXPECT_EQ(memcmp(result->m_scan_result.id.dev_mac, id.dev_mac, sizeof(dev_mac)), 0);
        EXPECT_EQ(memcmp(result->m_scan_result.id.scanner_mac, id.scanner_mac, sizeof(scanner_mac)), 0);
        EXPECT_EQ(result->m_scan_result.id.op_class, id.op_class);
        EXPECT_EQ(result->m_scan_result.id.channel, id.channel);
        EXPECT_EQ(result->m_scan_result.id.scanner_type, id.scanner_type);
    }
    mesh.deinit();
    std::cout << "Exiting find_matching_scan_result_valid_match test" << std::endl;
}

/**
 * @brief Test to ensure find_matching_scan_result returns nullptr when no matching scan entry exists
 *
 * This test verifies that the find_matching_scan_result API correctly returns a null pointer when there are no matching scan entries present in the mesh instance. It initializes the mesh, sets up a scan result identifier with non-existent network parameters, and asserts that the returned pointer is null.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 150@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Instantiate and initialize the mesh instance | Instance: dm_easy_mesh_t mesh (initialized via mesh.init()) | Mesh instance is created and initialized without errors | Should be successful |
 * | 02 | Prepare a scan result ID with non-existent network details and invoke find_matching_scan_result | id.net_id = "unknown_net", dev_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF}, scanner_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF}, op_class = 115, channel = 11, scanner_type = em_scanner_type_sta | The API returns a nullptr indicating no matching scan result found | Should Pass |
 * | 03 | Verify the returned result using ASSERT/EXPECT check | result = nullptr | EXPECT_EQ(result, nullptr) passes confirming the absence of a match | Should Pass |
 */
TEST(dm_easy_mesh_t, find_matching_scan_result_no_match)
{
    std::cout << "Entering find_matching_scan_result_no_match test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    em_scan_result_id_t id{};
    strcpy(id.net_id, "unknown_net");
    unsigned char mac[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    memcpy(id.dev_mac, mac, sizeof(mac));
    memcpy(id.scanner_mac, mac, sizeof(mac));
    id.op_class     = 115;
    id.channel      = 11;
    id.scanner_type = em_scanner_type_sta;
    std::cout << "Invoking find_matching_scan_result with no entries present" << std::endl;
    dm_scan_result_t* result = mesh.find_matching_scan_result(&id);
    EXPECT_EQ(result, nullptr);
    mesh.deinit();
    std::cout << "Exiting find_matching_scan_result_no_match test" << std::endl;
}

/**
 * @brief Test that find_matching_scan_result returns nullptr when a partial mismatch is detected
 *
 * This test verifies that when a scan result is looked up with a channel value that mismatches the
 * stored scan result, the find_matching_scan_result function correctly returns a null pointer. This ensures
 * that partial mismatches do not produce a false positive match.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 151@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                             | Test Data                                                                                                                    | Expected Result                                                  | Notes           |
 * | :--------------: | ----------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------- | --------------- |
 * | 01               | Initialize mesh module and test scan result structure                   | No input parameters                                                                                    | dm_easy_mesh_t instance is correctly initialized               | Should be successful |
 * | 02               | Add new scan result to mesh using valid scan parameters                  | stored.net_id = "test_net", stored.dev_mac = 01,02,03,04,05,06, stored.scanner_mac = 01,02,03,04,05,06, op_class = 81, channel = 1, scanner_type = em_scanner_type_radio | Scan result is successfully added to mesh                      | Should be successful |
 * | 03               | Create lookup scan result with mismatched channel field                  | lookup.channel = 6, other fields same as stored                                                       | Lookup scan result differs in channel field                      | Should be successful |
 * | 04               | Invoke find_matching_scan_result and verify nullptr is returned for mismatch | lookup with mismatched channel, invoking find_matching_scan_result                                     | Return value is nullptr indicating no matching scan result       | Should Fail     |
 */
TEST(dm_easy_mesh_t, find_matching_scan_result_partial_mismatch)
{
    std::cout << "Entering find_matching_scan_result_partial_mismatch test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    em_scan_result_id_t stored{};
    strcpy(stored.net_id, "test_net");
    unsigned char mac[6] = {0x01,0x02,0x03,0x04,0x05,0x06};
    memcpy(stored.dev_mac, mac, sizeof(mac));
    memcpy(stored.scanner_mac, mac, sizeof(mac));
    stored.op_class     = 81;
    stored.channel      = 1;
    stored.scanner_type = em_scanner_type_radio;
    mesh.create_new_scan_result(&stored);
    em_scan_result_id_t lookup = stored;
    lookup.channel = 6;  // mismatch
    std::cout << "Invoking find_matching_scan_result with mismatched channel" << std::endl;
    dm_scan_result_t* result = mesh.find_matching_scan_result(&lookup);
    EXPECT_EQ(result, nullptr);
    mesh.deinit();
    std::cout << "Exiting find_matching_scan_result_partial_mismatch test" << std::endl;
}

/**
 * @brief Test for verifying find_matching_scan_result API with a null id
 *
 * This test checks the behavior of the find_matching_scan_result method when invoked with a nullptr as the identifier.
 * The objective is to ensure that the API properly handles null pointers and returns a nullptr as a result.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 152@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                                         | Expected Result                                                             | Notes        |
 * | :--------------: | --------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- | --------------------------------------------------------------------------- | ------------ |
 * | 01               | Create an instance of dm_easy_mesh_t and initialize it using the init() method                  | No input, no output                                               | Mesh object is properly initialized                                         | Should be successful |
 * | 02               | Invoke find_matching_scan_result with a nullptr as the id and check the returned result via EXPECT_EQ | input: id = nullptr, output: result pointer                               | The API returns a nullptr validating that the function correctly handles null inputs | Should Pass  |
 */
TEST(dm_easy_mesh_t, find_matching_scan_result_nullptr_id)
{
    std::cout << "Entering find_matching_scan_result_nullptr_id test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    std::cout << "Invoking find_matching_scan_result with NULL id" << std::endl;
    dm_scan_result_t* result = mesh.find_matching_scan_result(nullptr);
    EXPECT_EQ(result, nullptr);
    mesh.deinit();
    std::cout << "Exiting find_matching_scan_result_nullptr_id test" << std::endl;
}

/**
 * @brief Verify that the find_sta API returns a valid station pointer when provided valid MAC addresses.
 *
 * This test initializes a mesh object, populates it with a station entry, converts string MAC addresses into byte arrays, 
 * and finally calls the find_sta API with valid station and BSSID MAC addresses. The test validates that the API correctly 
 * finds the station, resulting in a non-null pointer. This ensures that the station lookup functionality works as expected 
 * for valid input data.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 153@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize mesh object, call init and populate_sta with valid station data | mesh.init(), populate_sta: mesh, input1 = "AA:BB:CC:DD:EE:01", input2 = "11:22:33:44:55:66", input3 = "66:55:44:33:22:11" | Mesh object is initialized and station is added successfully | Should be successful |
 * | 02 | Convert station and BSSID string MAC addresses into mac bytes | string_to_macbytes: input = "AA:BB:CC:DD:EE:01", output = sta_mac; string_to_macbytes: input = "11:22:33:44:55:66", output = bssid | MAC address strings are correctly converted into byte arrays | Should be successful |
 * | 03 | Invoke find_sta API with valid STA MAC and BSSID, and verify the returned pointer is non-null | find_sta: input: sta_mac, bssid; EXPECT_NE(result, nullptr) | API returns a non-null pointer (dm_sta_t*) and the assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, find_sta_valid_match)
{
    std::cout << "Entering find_sta_valid_match test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    populate_sta(
        mesh,
        "AA:BB:CC:DD:EE:01",
        "11:22:33:44:55:66",
        "66:55:44:33:22:11"
    );
    mac_address_t sta_mac {};
    bssid_t bssid {};
    dm_easy_mesh_t::string_to_macbytes(
        const_cast<char *>("AA:BB:CC:DD:EE:01"),
        sta_mac
    );
    dm_easy_mesh_t::string_to_macbytes(
        const_cast<char *>("11:22:33:44:55:66"),
        bssid
    );
    std::cout << "Invoking find_sta with valid STA MAC and BSSID" << std::endl;
    dm_sta_t *result = mesh.find_sta(sta_mac, bssid);
    EXPECT_NE(result, nullptr);
    if (result) {
        mac_addr_str_t sta_str;
        dm_easy_mesh_t::macbytes_to_string(result->m_sta_info.id, sta_str);
        std::cout << "STA found successfully, MAC=" << sta_str << std::endl;
    }
    mesh.deinit();
    std::cout << "Exiting find_sta_valid_match test" << std::endl;
}

/**
 * @brief Validate find_sta behavior when no STA entries are present
 *
 * This test initializes a dm_easy_mesh_t object and attempts to find a station using the find_sta API 
 * while the STA map is empty. It verifies that the API returns a nullptr, which indicates that no matching STA entry exists.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 154@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize mesh and invoke find_sta with valid STA MAC and BSSID on an empty STA map | mesh.init(), sta_mac = AA:AA:AA:AA:AA:AA, bssid = BB:BB:BB:BB:BB:BB | API returns a nullptr indicating that no STA entry was found | Should Pass |
 */
TEST(dm_easy_mesh_t, find_sta_no_entries)
{
    std::cout << "Entering find_sta_no_entries test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t sta_mac{};
    bssid_t bssid{};
	dm_easy_mesh_t::string_to_macbytes(
        const_cast<char *>("AA:AA:AA:AA:AA:AA"),
        sta_mac
    );
    dm_easy_mesh_t::string_to_macbytes(
        const_cast<char *>("BB:BB:BB:BB:BB:BB"),
        bssid
    );
    std::cout << "Invoking find_sta with empty STA map" << std::endl;
    dm_sta_t* result = mesh.find_sta(sta_mac, bssid);
    EXPECT_EQ(result, nullptr);
    mesh.deinit();
    std::cout << "Exiting find_sta_no_entries test" << std::endl;
}

/**
 * @brief Test to verify behavior of find_sta when provided with a partially mismatched STA MAC address
 *
 * This test verifies that the find_sta API returns a null pointer when the STA MAC address provided
 * does not match the one stored, even if the BSSID is correct. The test first initializes a mesh object,
 * populates it with a known STA, and then attempts to find a STA using a mismatching MAC address. This ensures
 * the API correctly identifies and rejects invalid STA MAC addresses.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 155@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                                                                                                               | Expected Result                                                            | Notes          |
 * | :--------------: | --------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | -------------- |
 * | 01               | Initialize mesh object and populate STA details                                               | mesh object created; populate_sta with sta_mac = "AA:BB:CC:DD:EE:01", bssid = "11:22:33:44:55:66", radio_mac = "66:55:44:33:22:11"       | Mesh initialized and STA populated successfully                          | Should be successful |
 * | 02               | Convert string MAC addresses to byte array for mismatched STA MAC and correct BSSID             | dm_easy_mesh_t::string_to_macbytes with input: "AA:BB:CC:DD:EE:FF" for wrong_sta_mac; input: "11:22:33:44:55:66" for correct_bssid           | MAC addresses converted properly                                           | Should be successful |
 * | 03               | Invoke find_sta with mismatched STA MAC and verify the API returns a null pointer               | find_sta API invoked with input: wrong_sta_mac = "AA:BB:CC:DD:EE:FF", correct_bssid = "11:22:33:44:55:66"; output: result expected = nullptr | API returns nullptr confirming that no matching STA entry exists          | Should Pass    |
 */
TEST(dm_easy_mesh_t, find_sta_partial_mismatch_sta_mac)
{
    std::cout << "Entering find_sta_partial_mismatch_sta_mac test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    populate_sta(
        mesh,
        "AA:BB:CC:DD:EE:01",
        "11:22:33:44:55:66",
        "66:55:44:33:22:11"
    );
    mac_address_t wrong_sta_mac{};
    bssid_t correct_bssid{};
    dm_easy_mesh_t::string_to_macbytes(
        const_cast<char *>("AA:BB:CC:DD:EE:FF"),
        wrong_sta_mac
    );
    dm_easy_mesh_t::string_to_macbytes(
        const_cast<char *>("11:22:33:44:55:66"),
        correct_bssid
    );
    std::cout << "Invoking find_sta with mismatched STA MAC" << std::endl;
    dm_sta_t* result = mesh.find_sta(wrong_sta_mac, correct_bssid);
    EXPECT_EQ(result, nullptr);
    mesh.deinit();
    std::cout << "Exiting find_sta_partial_mismatch_sta_mac test" << std::endl;
}

/**
 * @brief Verify that the find_sta API returns nullptr when a correct STA MAC is provided with a mismatched BSSID.
 *
 * This test verifies that the find_sta API does not incorrectly match or retrieve a station when the supplied BSSID does not match the one stored.
 * The test sets up a mesh instance, populates it with a station entry using a specific BSSID, then invokes the API with the correct station MAC but a different BSSID.
 * The expected behavior is that the API returns nullptr, indicating no station is found under the mismatched BSSID.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 156@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Instantiate dm_easy_mesh_t and initialize the mesh instance using init() | N/A | Mesh instance successfully initialized | Should be successful |
 * | 02 | Populate the mesh with a station entry using populate_sta() | sta_mac = "AA:BB:CC:DD:EE:01", current_bssid = "11:22:33:44:55:66", target_bssid = "66:55:44:33:22:11" | Station record is added to the mesh | Should be successful |
 * | 03 | Convert the station MAC string to mac address bytes using string_to_macbytes() | input = "AA:BB:CC:DD:EE:01", output variable = correct_sta_mac | correct_sta_mac is correctly populated | Should be successful |
 * | 04 | Convert the BSSID string to mac address bytes using string_to_macbytes() | input = "FF:FF:FF:FF:FF:FF", output variable = wrong_bssid | wrong_bssid is correctly populated | Should be successful |
 * | 05 | Invoke find_sta() with the correct STA MAC and wrong BSSID, and verify the result | input: correct_sta_mac, wrong_bssid; output: result pointer | result pointer is nullptr; the EXPECT_EQ assertion passes | Should Fail |
 */
TEST(dm_easy_mesh_t, find_sta_partial_mismatch_bssid)
{
    std::cout << "Entering find_sta_partial_mismatch_bssid test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    populate_sta(
        mesh,
        "AA:BB:CC:DD:EE:01",
        "11:22:33:44:55:66",
        "66:55:44:33:22:11"
    );
    mac_address_t correct_sta_mac{};
    bssid_t wrong_bssid{};
    dm_easy_mesh_t::string_to_macbytes(
        const_cast<char *>("AA:BB:CC:DD:EE:01"),
        correct_sta_mac
    );
    dm_easy_mesh_t::string_to_macbytes(
        const_cast<char *>("FF:FF:FF:FF:FF:FF"),
        wrong_bssid
    );
    std::cout << "Invoking find_sta with mismatched BSSID" << std::endl;
    dm_sta_t* result = mesh.find_sta(correct_sta_mac, wrong_bssid);
    EXPECT_EQ(result, nullptr);
    mesh.deinit();
    std::cout << "Exiting find_sta_partial_mismatch_bssid test" << std::endl;
}

/**
 * @brief Verify that the find_sta API returns nullptr when supplied with zeroed MAC address inputs.
 *
 * This test ensures that the API correctly handles the edge case where both the station MAC and the BSSID are zeroed out. It verifies that invoking find_sta() with such inputs returns a nullptr, preventing potential improper station lookups.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 157@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                       | Test Data                                                | Expected Result                                                                                | Notes         |
 * | :--------------: | ----------------------------------------------------------------- | -------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize dm_easy_mesh_t instance, zero MAC addresses and invoke find_sta() API with zeroed inputs. | input: zero_sta = 0, zero_bssid = 0, output: result from find_sta         | Return value should be nullptr; EXPECT_EQ(result, nullptr) assertion should pass. | Should Pass   |
 */
TEST(dm_easy_mesh_t, find_sta_zero_mac_inputs)
{
    std::cout << "Entering find_sta_zero_mac_inputs test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t zero_sta{};
    bssid_t zero_bssid{};
    memset(zero_sta, 0, sizeof(zero_sta));
    memset(zero_bssid, 0, sizeof(zero_bssid));
    std::cout << "Invoking find_sta with zeroed MAC inputs" << std::endl;
    dm_sta_t* result = mesh.find_sta(zero_sta, zero_bssid);
    EXPECT_EQ(result, nullptr);
    mesh.deinit();
    std::cout << "Exiting find_sta_zero_mac_inputs test" << std::endl;
}

/**
 * @brief Test the behavior of find_sta when init() is not called
 *
 * This test verifies that attempting to find a station using dm_easy_mesh_t::find_sta without first initializing the mesh (by calling init()) returns a nullptr. The purpose is to ensure that the API correctly handles uninitialized states.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 158@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Instantiate dm_easy_mesh_t, convert MAC addresses for station and BSSID, then invoke find_sta without calling init() | input: sta_mac = AA:AA:AA:AA:AA:AA, bssid = BB:BB:BB:BB:BB:BB; output: result pointer | find_sta returns nullptr as confirmed by EXPECT_EQ(result, nullptr) | Should Pass |
 */
TEST(dm_easy_mesh_t, find_sta_without_init_bug)
{
    std::cout << "Entering find_sta_without_init_bug test" << std::endl;
    dm_easy_mesh_t mesh;
    mac_address_t sta_mac{};
    bssid_t bssid{};
    dm_easy_mesh_t::string_to_macbytes(
        const_cast<char *>("AA:AA:AA:AA:AA:AA"),
        sta_mac
    );
    dm_easy_mesh_t::string_to_macbytes(
        const_cast<char *>("BB:BB:BB:BB:BB:BB"),
        bssid
    );
    std::cout << "Invoking find_sta without calling init()" << std::endl;
    dm_sta_t* result = mesh.find_sta(sta_mac, bssid);
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting find_sta_without_init_bug test" << std::endl;
}

/**
 * @brief Validate retrieval of a valid agent AL interface.
 *
 * This test verifies that the get_agent_al_interface() function successfully retrieves a valid network interface from a dm_easy_mesh_t object when the interface is properly initialized with a valid interface name, MAC address, and media type.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 159@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                           | Test Data                                                                                              | Expected Result                                                                                              | Notes      |
 * | :--------------: | ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ | ---------- |
 * | 01               | Initialize dm_easy_mesh_t object with valid interface name, MAC address, and media type; invoke get_agent_al_interface() | input: validName = "ValidInterface", validMac = 0xAA,0xBB,0xCC,0xDD,0xEE,0xFF, media = em_media_type_ieee80211ac_5 | Returned interface pointer is not null and its properties (name, MAC address, and media type) match expected values | Should Pass |
 */
TEST(dm_easy_mesh_t, get_agent_al_interface_valid_AL_interface)
{
    const char* testName = "get_agent_al_interface_valid_AL_interface";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t obj;
    const char* validName = "ValidInterface";
    strncpy(obj.m_device.m_device_info.intf.name, validName, sizeof(obj.m_device.m_device_info.intf.name) - 1);
    obj.m_device.m_device_info.intf.name[sizeof(obj.m_device.m_device_info.intf.name) - 1] = '\0';
    unsigned char validMac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    memcpy(obj.m_device.m_device_info.intf.mac, validMac, sizeof(validMac));
    obj.m_device.m_device_info.intf.media = em_media_type_ieee80211ac_5;

    std::cout << "Invoking get_agent_al_interface()" << std::endl;
    em_interface_t* iface = obj.get_agent_al_interface();
    ASSERT_NE(iface, nullptr);
    std::cout << "Retrieved interface name: " << iface->name << std::endl;
    std::cout << "Retrieved MAC address: ";
    for (size_t i = 0; i < sizeof(iface->mac); i++) {
        std::cout << std::hex << static_cast<int>(iface->mac[i]) << " ";
    }
    std::cout << std::dec << std::endl;
    std::cout << "Retrieved media type: " << iface->media << std::endl;

    ASSERT_STREQ(iface->name, validName);
    ASSERT_EQ(std::memcmp(iface->mac, validMac, sizeof(validMac)), 0);
    ASSERT_EQ(iface->media, em_media_type_ieee80211ac_5);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_agent_al_interface() returns a valid interface when not configured
 *
 * This test verifies that the get_agent_al_interface() method correctly returns a non-null pointer even when the agent AL interface is not configured. It checks that the interface details such as name, MAC address, and media type are retrievable, ensuring the method's behavior is as expected.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 160@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data |Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Instantiate dm_easy_mesh_t object and set test name | testName = "get_agent_al_interface_not_configured" | Object created and test name initialized | Should be successful |
 * | 02 | Invoke get_agent_al_interface() on the object | Method: get_agent_al_interface() | Returns a valid (non-null) em_interface_t pointer | Should Pass |
 * | 03 | Retrieve and display interface details (name, MAC address, media type) | Output: iface->name, iface->mac, iface->media | Correct interface details printed to stdout | Should be successful |
 */
TEST(dm_easy_mesh_t, get_agent_al_interface_not_configured)
{
    const char* testName = "get_agent_al_interface_not_configured";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t obj;
    std::cout << "Invoking get_agent_al_interface()" << std::endl;
    em_interface_t* iface = obj.get_agent_al_interface();
    ASSERT_NE(iface, nullptr);
    std::cout << "Retrieved interface name: " << iface->name << std::endl;
    std::cout << "Retrieved MAC address: ";
    for (size_t i = 0; i < sizeof(iface->mac); i++) {
        std::cout << std::hex << static_cast<int>(iface->mac[i]) << " ";
    }
    std::cout << std::dec << std::endl;
    std::cout << "Retrieved media type: " << iface->media << std::endl;
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_agent_al_interface_mac returns the correct MAC address.
 *
 * This test verifies that the get_agent_al_interface_mac method correctly retrieves the MAC address that was previously set in the device's information structure. It ensures that the returned pointer is not null and that the 6-byte MAC value matches the expected valid MAC address.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 161@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object and set the valid MAC address in the device info. | valid_mac = {0x10, 0x11, 0x22, 0x33, 0x44, 0x55} assigned to m_device.m_device_info.intf.mac | The MAC address is successfully set in the object's device information. | Should be successful |
 * | 02 | Invoke get_agent_al_interface_mac() method to retrieve the stored MAC address. | Invocation of get_agent_al_interface_mac() | Returns a non-null pointer to the MAC address. | Should Pass |
 * | 03 | Verify the retrieved MAC address matches the expected valid MAC address using std::memcmp. | ret_mac compared with valid_mac using std::memcmp | The result of std::memcmp is 0, confirming the addresses match. | Should Pass |
 */
TEST(dm_easy_mesh_t, get_agent_al_interface_mac_valid_retrieval)
{
    std::cout << "Entering get_agent_al_interface_mac_valid_retrieval test" << std::endl;
    dm_easy_mesh_t obj;
    unsigned char valid_mac[6] = {0x10, 0x11, 0x22, 0x33, 0x44, 0x55};
	memcpy(obj.m_device.m_device_info.intf.mac, valid_mac, sizeof(valid_mac));
    std::cout << "Invoking get_agent_al_interface_mac() method." << std::endl;
    unsigned char * ret_mac = obj.get_agent_al_interface_mac();
    EXPECT_NE(ret_mac, nullptr);
    if(ret_mac)
    {
        std::cout << "Retrieved MAC address bytes: ";
        for (int i = 0; i < 6; i++) 
        {
            std::cout << std::hex << static_cast<int>(ret_mac[i]) << " ";
        }
        std::cout << std::dec << std::endl;
    }
	EXPECT_EQ(std::memcmp(ret_mac, valid_mac, sizeof(valid_mac)), 0);
    std::cout << "Exiting get_agent_al_interface_mac_valid_retrieval test" << std::endl;
}

/**
 * @brief Validates that get_agent_al_interface_name() returns the correct interface name.
 *
 * This test configures a dm_easy_mesh_t object by setting its device interface name to "eth0", then invokes get_agent_al_interface_name() to retrieve the name. It verifies that the returned pointer is not NULL and that the name matches the expected value "eth0".@n
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 162@n
 * **Priority:** High@n
 * @n
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * @n
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                          | Test Data                                          | Expected Result                                   | Notes               |
 * | :--------------: | -------------------------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------- | ------------------- |
 * | 01               | Set device interface name to "eth0" in the dm_easy_mesh_t object.    | input: interface name = "eth0"                     | The device interface name is set to "eth0".       | Should be successful|
 * | 02               | Invoke get_agent_al_interface_name() on the mesh object.             | output: returnedName pointer                       | Method returns a non-null pointer.                | Should Pass         |
 * | 03               | Validate that the returned interface name matches "eth0".            | output: returnedName value = "eth0"                | ASSERT_STREQ confirms the returned name equals "eth0". | Should Pass         |
 */
TEST(dm_easy_mesh_t, get_agent_al_interface_name_valid_agent_interface_name)
{
    std::cout << "Entering get_agent_al_interface_name_valid_agent_interface_name test" << std::endl;    
    dm_easy_mesh_t mesh;
    memcpy(mesh.m_device.m_device_info.intf.name, "eth0", sizeof("eth0"));
    std::cout << "Set device interface name to: " << mesh.m_device.m_device_info.intf.name << std::endl;    
    std::cout << "Invoking get_agent_al_interface_name()" << std::endl;
    char *returnedName = mesh.get_agent_al_interface_name();
    std::cout << "Method returned: " << (returnedName ? returnedName : "NULL") << std::endl;    
    EXPECT_NE(returnedName, nullptr);
    EXPECT_STREQ(returnedName, "eth0");    
    std::cout << "Exiting get_agent_al_interface_name_valid_agent_interface_name test" << std::endl;
}

/**
 * @brief Test to validate that get_agent_al_interface_name() correctly returns an empty string when the device's agent interface name is empty.
 *
 * This test verifies that when the device interface name is set to an empty string, the method get_agent_al_interface_name() returns a non-null pointer and an empty string. This behavior is critical because it ensures that the API handles the edge case of an empty configuration gracefully without returning a NULL pointer.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 163@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                                     | Expected Result                                                       | Notes         |
 * | :--------------: | --------------------------------------------------------------------------------------------- | ------------------------------------------------------------- | --------------------------------------------------------------------- | ------------- |
 * | 01               | Set the device interface name of mesh to an empty string                                      | mesh.m_device.m_device_info.intf.name = ""                     | The device interface name is set to an empty string                   | Should be successful |
 * | 02               | Invoke get_agent_al_interface_name() and verify it returns a valid pointer to an empty string   | input: device with empty interface name, output: returnedName   | returnedName != nullptr and returnedName equals ""                   | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_agent_al_interface_name_empty_agent_interface_name)
{
    std::cout << "Entering get_agent_al_interface_name_empty_agent_interface_name test" << std::endl;   
    dm_easy_mesh_t mesh;
    memcpy(mesh.m_device.m_device_info.intf.name, "", sizeof(""));
    std::cout << "Set device interface name to an empty string" << std::endl;    
    std::cout << "Invoking get_agent_al_interface_name()" << std::endl;
    char *returnedName = mesh.get_agent_al_interface_name();
    if(returnedName)
    {
        std::cout << "Method returned an empty string" << std::endl;
    }
    else
    {
        std::cout << "Method returned: NULL" << std::endl;
    }    
    EXPECT_NE(returnedName, nullptr);
    EXPECT_STREQ(returnedName, "");    
    std::cout << "Exiting get_agent_al_interface_name_empty_agent_interface_name test" << std::endl;
}

/**
 * @brief Test that get_ap_mld retrieves valid AP MLD info at index 0 with configured parameters
 *
 * This test verifies that when a mesh object with one configured AP MLD is created and initialized with valid parameters,
 * calling get_ap_mld with index 0 returns a non-null pointer and the retrieved AP MLD information matches the expected values.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 164@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object with one AP MLD configured with valid mac_addr, ssid, and other parameters; call get_ap_mld with index 0 | m_num_ap_mld = 1, mac_addr_valid = true, str = false, emlsr = true, ssid = "TestSSID", mac_addr = {0x10,0x11,0x23,0x3D,0x4D,0x5E}, index = 0 | Returns a non-null pointer; retrieved mac_addr elements match valid_mac values as asserted | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ap_mld_valid_index_zero_configured)
{
    std::cout << "Entering get_ap_mld_valid_index_zero_configured test" << std::endl;    
    dm_easy_mesh_t meshObj;
    meshObj.m_num_ap_mld = 1;
    meshObj.m_ap_mld[0].m_ap_mld_info.mac_addr_valid = true;
    meshObj.m_ap_mld[0].m_ap_mld_info.str = false;
	meshObj.m_ap_mld[0].m_ap_mld_info.emlsr = true;
	memcpy(meshObj.m_ap_mld[0].m_ap_mld_info.ssid, "TestSSID", sizeof("TestSSID"));
	unsigned char valid_mac[] = {0x10, 0x11, 0x23, 0x3D, 0x4D, 0x5E};
	memcpy(meshObj.m_ap_mld[0].m_ap_mld_info.mac_addr, valid_mac, sizeof(valid_mac));
    unsigned int index = 0;
    std::cout << "Invoking get_ap_mld with index = " << index << std::endl;
    dm_ap_mld_t* apMldPtr = meshObj.get_ap_mld(index);
    if(apMldPtr != nullptr)
    {
        em_ap_mld_info_t* info = apMldPtr->get_ap_mld_info();
        std::cout << "Retrieved AP MLD info: " << std::endl;
		std::cout << "mac_addr_valid = " << info->mac_addr_valid << std::endl;
		std::cout << "str = " << info->str << std::endl;
		std::cout << "emlsr = " << info->emlsr << std::endl;
		std::cout << "ssid = " << info->ssid << std::endl;
		for (size_t i = 0; i < sizeof(valid_mac); ++i) {
            EXPECT_EQ(info->mac_addr[i], valid_mac[i]);
        }
    }    
    EXPECT_NE(apMldPtr, nullptr);
    std::cout << "Exiting get_ap_mld_valid_index_zero_configured test" << std::endl;
}

/**
 * @brief Test get_ap_mld to verify it returns a valid pointer when no AP is configured
 *
 * This test verifies that even when the number of AP MLD configurations is set to zero, calling get_ap_mld with index 0 returns a non-null pointer. This ensures that the API handles the case with no configured AP MLDs gracefully.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 165@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                            | Test Data                                              | Expected Result                            | Notes       |
 * | :--------------: | ------------------------------------------------------------------------------------------------------ | ------------------------------------------------------ | ----------------------------------------- | ----------- |
 * | 01               | Initialize dm_easy_mesh_t object with m_num_ap_mld set to 0, set index to 0 and invoke get_ap_mld()   | m_num_ap_mld = 0, index = 0, output = pointer from get_ap_mld() | Returned pointer should not be nullptr     | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ap_mld_valid_index_zero_no_ap_configured)
{
    std::cout << "Entering get_ap_mld_valid_index_zero_no_ap_configured test" << std::endl;    
    dm_easy_mesh_t meshObj;
    meshObj.m_num_ap_mld = 0;    
    unsigned int index = 0;
    std::cout << "Invoking get_ap_mld with index = " << index << std::endl;
    dm_ap_mld_t* apMldPtr = meshObj.get_ap_mld(index);
    if(apMldPtr != nullptr)
    {
        em_ap_mld_info_t* info = apMldPtr->get_ap_mld_info();
        std::cout << "Retrieved AP MLD info: " << std::endl;
		std::cout << "mac_addr_valid = " << info->mac_addr_valid << std::endl;
		std::cout << "str = " << info->str << std::endl;
		std::cout << "emlsr = " << info->emlsr << std::endl;
		std::cout << "ssid = " << info->ssid << std::endl;
    }    
    EXPECT_NE(apMldPtr, nullptr);
    std::cout << "Exiting get_ap_mld_valid_index_zero_no_ap_configured test" << std::endl;
}

/**
 * @brief Verify that get_ap_mld returns nullptr when provided with an out-of-range index.
 *
 * This test checks that the get_ap_mld method of dm_easy_mesh_t properly handles an index that exceeds the number of valid elements. It ensures that invalid access is safely handled by returning a null pointer.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 166@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                                                       | Test Data                                                                                                                                                                                                                                                     | Expected Result                                                                                  | Notes        |
 * | :--------------: | --------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- | ------------ |
 * | 01               | Initialize dm_easy_mesh_t object with m_num_ap_mld set to 2, configure m_ap_mld[3] fields, and assign an out-of-range index  | m_num_ap_mld = 2, m_ap_mld[3].m_ap_mld_info.mac_addr_valid = true, m_ap_mld[3].m_ap_mld_info.str = false, m_ap_mld[3].m_ap_mld_info.emlsr = true, m_ap_mld[3].m_ap_mld_info.ssid = "TestSSID", m_ap_mld[3].m_ap_mld_info.mac_addr = {0x10, 0x11, 0x23, 0x3D, 0x4D, 0x5E}, index = 4 | Return value is a nullptr as verified by EXPECT_EQ(apMldPtr, nullptr) | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ap_mld_index_out_of_range)
{
    std::cout << "Entering get_ap_mld_index_out_of_range test" << std::endl;    
    dm_easy_mesh_t meshObj;
    meshObj.m_num_ap_mld = 2;
    meshObj.m_ap_mld[3].m_ap_mld_info.mac_addr_valid = true;
    meshObj.m_ap_mld[3].m_ap_mld_info.str = false;
    meshObj.m_ap_mld[3].m_ap_mld_info.emlsr = true;
    memcpy(meshObj.m_ap_mld[3].m_ap_mld_info.ssid, "TestSSID", sizeof("TestSSID"));
    unsigned char valid_mac[] = {0x10, 0x11, 0x23, 0x3D, 0x4D, 0x5E};
    memcpy(meshObj.m_ap_mld[3].m_ap_mld_info.mac_addr, valid_mac, sizeof(valid_mac));    
    unsigned int index = 4;
    std::cout << "Invoking get_ap_mld with index = " << index << std::endl;
    dm_ap_mld_t* apMldPtr = meshObj.get_ap_mld(index);
    EXPECT_EQ(apMldPtr, nullptr);
    std::cout << "Exiting get_ap_mld_index_out_of_range test" << std::endl;
}

/**
 * @brief Verifies that get_ap_mld_by_ref correctly retrieves the AP MLD entry when index zero is configured.
 *
 * This test sets up a dm_easy_mesh_t object with one AP MLD entry configured with specific parameters.
 * It then calls the get_ap_mld_by_ref method with index 0 and verifies that the returned AP MLD reference
 * contains the expected values for mac_addr_valid, str, emlsr, ssid, and mac_addr. This ensures that the
 * API accurately accesses the configured AP MLD information.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 167@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |@n
 * | :----: | --------- | ---------- |-------------- | ----- |@n
 * | 01 | Configure mesh object with one AP MLD entry and set its parameters | m_num_ap_mld = 1, mac_addr_valid = true, str = false, emlsr = true, ssid = "TestSSID", mac_addr = {0x10, 0x11, 0x23, 0x3D, 0x4D, 0x5E} | Mesh object successfully configured with valid AP MLD entry | Should be successful |@n
 * | 02 | Invoke get_ap_mld_by_ref with index = 0 | index = 0 | Returns a valid reference to the AP MLD entry | Should Pass |@n
 * | 03 | Validate the retrieved AP MLD information against the expected configuration | Returned values: mac_addr_valid = true, str = false, emlsr = true, ssid = "TestSSID", mac_addr = {0x10, 0x11, 0x23, 0x3D, 0x4D, 0x5E} | All assertions pass and values match the expected configuration | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ap_mld_by_ref_valid_index_zero_configured)
{
    std::cout << "Entering get_ap_mld_by_ref_valid_index_zero_configured test" << std::endl;
    dm_easy_mesh_t meshObj;
    meshObj.m_num_ap_mld = 1;
    meshObj.m_ap_mld[0].m_ap_mld_info.mac_addr_valid = true;
    meshObj.m_ap_mld[0].m_ap_mld_info.str = false;
    meshObj.m_ap_mld[0].m_ap_mld_info.emlsr = true;
    memcpy(meshObj.m_ap_mld[0].m_ap_mld_info.ssid, "TestSSID", sizeof("TestSSID"));
    unsigned char valid_mac[] = {0x10, 0x11, 0x23, 0x3D, 0x4D, 0x5E};
    memcpy(meshObj.m_ap_mld[0].m_ap_mld_info.mac_addr, valid_mac, sizeof(valid_mac));
    unsigned int index = 0;
    std::cout << "Invoking get_ap_mld_by_ref with index = " << index << std::endl;
    dm_ap_mld_t& apMldRef = meshObj.get_ap_mld_by_ref(index);
    std::cout << "Retrieved AP MLD info:" << std::endl;
    std::cout << "  mac_addr_valid = " << apMldRef.m_ap_mld_info.mac_addr_valid << std::endl;
    std::cout << "  str            = " << apMldRef.m_ap_mld_info.str << std::endl;
    std::cout << "  emlsr          = " << apMldRef.m_ap_mld_info.emlsr << std::endl;
    std::cout << "  ssid           = " << apMldRef.m_ap_mld_info.ssid << std::endl;
    EXPECT_TRUE(apMldRef.m_ap_mld_info.mac_addr_valid);
    EXPECT_FALSE(apMldRef.m_ap_mld_info.str);
    EXPECT_TRUE(apMldRef.m_ap_mld_info.emlsr);
    EXPECT_STREQ(apMldRef.m_ap_mld_info.ssid, "TestSSID");
    for (size_t i = 0; i < sizeof(valid_mac); ++i) {
        EXPECT_EQ(apMldRef.m_ap_mld_info.mac_addr[i], valid_mac[i]);
    }
    std::cout << "Exiting get_ap_mld_by_ref_valid_index_zero_configured test" << std::endl;
}

/**
 * @brief Verify that get_ap_mld_by_ref returns correct AP MLD info when index is zero and no AP is configured
 *
 * This test sets up a dm_easy_mesh_t object with one AP MLD and verifies that the get_ap_mld_by_ref function returns the expected AP MLD info with mac_addr_valid set to false. This ensures that the function correctly handles the scenario when no AP is configured.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 168@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                                   | Test Data                                                  | Expected Result                                                                               | Notes       |
 * | :--------------: | ------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | --------------------------------------------------------------------------------------------- | ----------- |
 * | 01               | Initialize dm_easy_mesh_t object with m_num_ap_mld = 1 and index = 0, then invoke get_ap_mld_by_ref             | meshObj.m_num_ap_mld = 1, index = 0                         | Returns reference to AP MLD object with m_ap_mld_info.mac_addr_valid = false                   | Should Pass |
 * | 02               | Validate that the returned AP MLD object's m_ap_mld_info.mac_addr_valid is false using EXPECT_FALSE macro         | Retrieved apMldRef with m_ap_mld_info.mac_addr_valid = false | Assertion passes confirming mac_addr_valid is false                                           | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ap_mld_by_ref_valid_index_zero_no_ap_configured)
{
    std::cout << "Entering get_ap_mld_by_ref_valid_index_zero_no_ap_configured test" << std::endl;
    dm_easy_mesh_t meshObj;
    meshObj.m_num_ap_mld = 1;
    unsigned int index = 0;
    std::cout << "Invoking get_ap_mld_by_ref with index = " << index << std::endl;
    dm_ap_mld_t& apMldRef = meshObj.get_ap_mld_by_ref(index);
    std::cout << "Retrieved AP MLD info:" << std::endl;
    std::cout << "  mac_addr_valid = " << apMldRef.m_ap_mld_info.mac_addr_valid << std::endl;
    EXPECT_FALSE(apMldRef.m_ap_mld_info.mac_addr_valid);
    std::cout << "Exiting get_ap_mld_by_ref_valid_index_zero_no_ap_configured test" << std::endl;
}

/**
 * @brief Test get_ap_mld_by_ref with an invalid reference index
 *
 * This test verifies that the get_ap_mld_by_ref API correctly handles the situation where the reference index is out-of-range.
 * The test sets up a dm_easy_mesh_t object with a fixed number of AP/MLD entries and predefined attributes for one of the entries.
 * It then calls get_ap_mld_by_ref with an index that exceeds the valid range and asserts that the returned AP/MLD info indicates an invalid MAC address.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 169@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                                | Test Data                                                                                                                                                                                                                                                                                   | Expected Result                                                                                                       | Notes      |
 * | :--------------: | ---------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- | ---------- |
 * | 01               | Set up dm_easy_mesh_t object with predefined AP/MLD values and invoke get_ap_mld_by_ref with index out-of-range | m_num_ap_mld = 2, m_ap_mld[3].m_ap_mld_info.mac_addr_valid = true, m_ap_mld[3].m_ap_mld_info.str = false, m_ap_mld[3].m_ap_mld_info.emlsr = true, m_ap_mld[3].m_ap_mld_info.ssid = "TestSSID", m_ap_mld[3].m_ap_mld_info.mac_addr = [0x10,0x11,0x23,0x3D,0x4D,0x5E], index = 4 | Return reference with m_ap_mld_info.mac_addr_valid set to false, satisfying the EXPECT_FALSE assertion | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ap_mld_by_ref_index_out_of_range)
{
    std::cout << "Entering get_ap_mld_by_ref_index_out_of_range test" << std::endl;
    dm_easy_mesh_t meshObj;
    meshObj.m_num_ap_mld = 2;
    meshObj.m_ap_mld[3].m_ap_mld_info.mac_addr_valid = true;
    meshObj.m_ap_mld[3].m_ap_mld_info.str = false;
    meshObj.m_ap_mld[3].m_ap_mld_info.emlsr = true;
    memcpy(meshObj.m_ap_mld[3].m_ap_mld_info.ssid, "TestSSID", sizeof("TestSSID"));
    unsigned char valid_mac[] = {0x10, 0x11, 0x23, 0x3D, 0x4D, 0x5E};
    memcpy(meshObj.m_ap_mld[3].m_ap_mld_info.mac_addr, valid_mac, sizeof(valid_mac));    
    unsigned int index = 4;
    std::cout << "Invoking get_ap_mld with index = " << index << std::endl;
    dm_ap_mld_t& apMldRef = meshObj.get_ap_mld_by_ref(index);
    EXPECT_FALSE(apMldRef.m_ap_mld_info.mac_addr_valid);
    std::cout << "Exiting get_ap_mld_by_ref_index_out_of_range test" << std::endl;
}

/**
 * @brief Validates retrieval of AP MLD info using a valid BSSID
 *
 * This test validates that the function get_ap_mld_frm_bssid correctly retrieves the AP MLD information when provided with a valid BSSID. It configures a mesh instance with one AP MLD entry containing two affiliated APs, one of which matches the target BSSID.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 170@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t instance, set m_num_ap_mld to 1, and configure AP MLD info with 2 affiliated APs. | instance.m_num_ap_mld = 1, info.num_affiliated_ap = 2, affiliated_ap[0].mac_addr = {0x11,0x22,0x33,0x44,0x55,0x66}, affiliated_ap[1].mac_addr = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF} | Instance is correctly configured with one AP MLD and two affiliated AP entries. | Should be successful |
 * | 02 | Invoke get_ap_mld_frm_bssid with target_bssid that matches one of the affiliated AP addresses. | target_bssid = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF} | Returned pointer is not null. | Should Pass |
 * | 03 | Validate the retrieved AP MLD info for the correct number of affiliated APs. | result->num_affiliated_ap expected = 2 | The number of affiliated APs equals 2. | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ap_mld_frm_bssid_valid_ap_mld_info_retrieval)
{
    std::cout << "Entering get_ap_mld_frm_bssid_valid_ap_mld_info_retrieval test" << std::endl;
    dm_easy_mesh_t instance{};
    instance.m_num_ap_mld = 1;
    em_ap_mld_info_t &info = instance.m_ap_mld[0].m_ap_mld_info;
    info.num_affiliated_ap = 2;
    unsigned char target_bssid[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    unsigned char other_bssid[6]  = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
    memcpy(info.affiliated_ap[0].mac_addr, other_bssid, sizeof(mac_address_t));
    memcpy(info.affiliated_ap[1].mac_addr, target_bssid, sizeof(mac_address_t));
    std::cout << "Configured AP MLD with 2 affiliated APs" << std::endl;
    std::cout << "Invoking get_ap_mld_frm_bssid" << std::endl;
    em_ap_mld_info_t *result = instance.get_ap_mld_frm_bssid(target_bssid);
    EXPECT_NE(result, nullptr);
    if (result) {
        std::cout << "Returned non-null AP MLD info" << std::endl;
        EXPECT_EQ(result->num_affiliated_ap, 2);
    }
    std::cout << "Exiting get_ap_mld_frm_bssid_valid_ap_mld_info_retrieval test" << std::endl;
}

/**
 * @brief Verify that get_ap_mld_frm_bssid returns a null pointer for a non-existent BSSID
 *
 * This test verifies that when get_ap_mld_frm_bssid is invoked with a BSSID that does not match any
 * of the affiliated AP MAC addresses stored in the instance, the function correctly returns a null pointer.
 * This behavior ensures that the API properly handles cases where no valid AP MLD information is found.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 171@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                          | Test Data                                                                                                              | Expected Result                                                                               | Notes            |
 * | :--------------: | ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- | ---------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and set one AP MLD with an affiliated AP having an existing BSSID   | m_num_ap_mld = 1, num_affiliated_ap = 1, existing_bssid = 0xAA,0xBB,0xCC,0xDD,0xEE,0xFF                                   | Instance initializes with proper AP MLD configuration                                          | Should be successful |
 * | 02               | Define a non-existent BSSID that does not match the existing BSSID                                     | search_bssid = 0x10,0x20,0x30,0x40,0x50,0x60                                                                              | Non-existent BSSID is set correctly                                                            | Should be successful |
 * | 03               | Invoke get_ap_mld_frm_bssid with the non-existent BSSID and capture the result                         | Input: search_bssid = 0x10,0x20,0x30,0x40,0x50,0x60; Output: result pointer                                               | The function returns a null pointer indicating no matching AP data                             | Should Pass      |
 * | 04               | Verify the returned result using an assertion                                                        | result pointer as returned by the API                                                                                  | EXPECT_EQ(result, nullptr) assertion passes                                                    | Should be successful |
 */
TEST(dm_easy_mesh_t, get_ap_mld_frm_bssid_non_existent_bssid_returns_null)
{
    std::cout << "Entering get_ap_mld_frm_bssid_non_existent_bssid_returns_null test" << std::endl;
    dm_easy_mesh_t instance{};
    instance.m_num_ap_mld = 1;
    em_ap_mld_info_t &info = instance.m_ap_mld[0].m_ap_mld_info;
    info.num_affiliated_ap = 1;
    unsigned char existing_bssid[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    memcpy(info.affiliated_ap[0].mac_addr, existing_bssid, sizeof(mac_address_t));
    unsigned char search_bssid[6] = {0x10, 0x20, 0x30, 0x40, 0x50, 0x60};
    std::cout << "Invoking get_ap_mld_frm_bssid with non-matching BSSID" << std::endl;
    em_ap_mld_info_t *result = instance.get_ap_mld_frm_bssid(search_bssid);
    EXPECT_EQ(result, nullptr);
    std::cout << "Returned NULL as expected" << std::endl;
    std::cout << "Exiting get_ap_mld_frm_bssid_non_existent_bssid_returns_null test" << std::endl;
}

/**
 * @brief Test that verifies get_ap_mld_frm_bssid returns nullptr when AP MLD data is absent.
 *
 * This test checks the behavior of the get_ap_mld_frm_bssid API when the device instance is not populated with any AP MLD data.
 * It ensures that when a valid BSSID is provided and the AP MLD list is empty, the API correctly returns a nullptr.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 172@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                       | Test Data                                                          | Expected Result                                                      | Notes       |
 * | :--------------: | ------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ | -------------------------------------------------------------------- | ----------- |
 * | 01               | Initialize dm_easy_mesh_t instance and set m_num_ap_mld to 0                                     | m_num_ap_mld = 0                                                   | Instance created with no AP MLD data                                 | Should be successful |
 * | 02               | Define the BSSID and invoke get_ap_mld_frm_bssid on the instance with an empty AP MLD list         | any_bssid = {0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC}, instance.m_num_ap_mld = 0 | Returned value is nullptr and EXPECT_EQ check passes                 | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ap_mld_frm_bssid_default_instance_without_ap_mld_data)
{
    std::cout << "Entering get_ap_mld_frm_bssid_default_instance_without_ap_mld_data test" << std::endl;
    dm_easy_mesh_t instance{};
    instance.m_num_ap_mld = 0;
    unsigned char any_bssid[6] = {0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC};
    std::cout << "Invoking get_ap_mld_frm_bssid with empty AP MLD list" << std::endl;
    em_ap_mld_info_t *result = instance.get_ap_mld_frm_bssid(any_bssid);
    EXPECT_EQ(result, nullptr);
    std::cout << "Returned NULL as expected" << std::endl;
    std::cout << "Exiting get_ap_mld_frm_bssid_default_instance_without_ap_mld_data test" << std::endl;
}

/**
 * @brief Test get_ap_mld_frm_bssid function with NULL bssid input to ensure proper handling of invalid argument
 *
 * This test verifies that the get_ap_mld_frm_bssid API returns a null pointer when provided with a NULL bssid input.
 * It confirms that the function correctly detects an invalid input and behaves as expected without crashing or returning unexpected data.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 173@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                                 | Test Data                                                                                                                        | Expected Result                                            | Notes      |
 * | :--------------: | ----------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ---------- |
 * | 01               | Create a dm_easy_mesh_t instance, set up valid AP MLD info, and invoke get_ap_mld_frm_bssid with NULL input. | instance.m_num_ap_mld = 1, info.num_affiliated_ap = 1, affiliated_ap[0].mac_addr = 0xAA,0xBB,0xCC,0xDD,0xEE,0xFF; bssid = nullptr | API returns a nullptr; Assertion: EXPECT_EQ(result, nullptr) | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ap_mld_frm_bssid_null_bssid_input)
{
    std::cout << "Entering get_ap_mld_frm_bssid_null_bssid_input test" << std::endl;
    dm_easy_mesh_t instance{};
    instance.m_num_ap_mld = 1;
    em_ap_mld_info_t &info = instance.m_ap_mld[0].m_ap_mld_info;
    info.num_affiliated_ap = 1;
    unsigned char existing_bssid[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    memcpy(info.affiliated_ap[0].mac_addr, existing_bssid, sizeof(mac_address_t));
    std::cout << "Invoking get_ap_mld_frm_bssid with NULL bssid pointer" << std::endl;
    em_ap_mld_info_t *result = instance.get_ap_mld_frm_bssid(nullptr);
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_ap_mld_frm_bssid_null_bssid_input test" << std::endl;
}

/**
 * @brief Validate that get_ap_mld_frm_bssid returns valid AP MLD info for matching BSSID
 *
 * This test verifies that when a dm_easy_mesh_t instance is properly configured with a single AP MLD and its affiliated AP's MAC address matches the provided BSSID, the static method get_ap_mld_frm_bssid correctly returns a non-null pointer with matching MAC address data.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 174@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                         | Test Data                                                                               | Expected Result                                                                                                 | Notes             |
 * | :--------------: | --------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- | ----------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and configure a single AP MLD with a matching affiliated AP BSSID. | instance.m_num_ap_mld = 1, info.num_affiliated_ap = 1, bssid = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF} | Instance is created with valid AP MLD info and the affiliated AP MAC address is set to the expected BSSID.       | Should be successful |
 * | 02               | Invoke get_ap_mld_frm_bssid API and validate that the returned pointer is non-null and contains matching MAC address. | API call: get_ap_mld_frm_bssid(static_cast<void *>(&instance), bssid)                      | The API returns a non-null pointer, and memcmp of the affiliated AP MAC address with the provided BSSID equals 0.   | Should Pass       |
 */
TEST(dm_easy_mesh_t, static_get_ap_mld_frm_bssid_valid_match)
{
    std::cout << "Entering static_get_ap_mld_frm_bssid_valid_match test" << std::endl;
    dm_easy_mesh_t instance{};
    instance.m_num_ap_mld = 1;
    em_ap_mld_info_t &info = instance.m_ap_mld[0].m_ap_mld_info;
    info.num_affiliated_ap = 1;
    unsigned char bssid[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    memcpy(info.affiliated_ap[0].mac_addr, bssid, sizeof(mac_address_t));
    std::cout << "Invoking static get_ap_mld_frm_bssid with valid dm and matching bssid" << std::endl;
    em_ap_mld_info_t *result = dm_easy_mesh_t::get_ap_mld_frm_bssid(static_cast<void *>(&instance), bssid);
    EXPECT_NE(result, nullptr);
    if (result) {
        EXPECT_EQ(
            memcmp(result->affiliated_ap[0].mac_addr, bssid, sizeof(mac_address_t)),
            0
        );
    }
    std::cout << "Exiting static_get_ap_mld_frm_bssid_valid_match test" << std::endl;
}

/**
 * @brief Test static_get_ap_mld_frm_bssid API for handling non-matching BSSID
 *
 * This test verifies that when the lookup BSSID does not match any stored affiliated AP BSSID in the dm_easy_mesh_t instance, the API returns a nullptr. This ensures that the function correctly identifies non-existent matches.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 175@n
 * **Priority:** High
 * 
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                      | Test Data                                                                                     | Expected Result                                          | Notes       |
 * | :---------------:| ------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------- | -------------------------------------------------------- | ----------- |
 * | 01               | Initialize dm_easy_mesh_t with one AP MLD and set its affiliated AP's BSSID to AA,BB,CC,DD,EE,FF; invoke static_get_ap_mld_frm_bssid with lookup BSSID 11,22,33,44,55,66 | instance.m_num_ap_mld=1, info.num_affiliated_ap=1, stored_bssid=AA,BB,CC,DD,EE,FF, lookup_bssid=11,22,33,44,55,66 | API returns nullptr and EXPECT_EQ(result, nullptr) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_ap_mld_frm_bssid_no_match)
{
    std::cout << "Entering static_get_ap_mld_frm_bssid_no_match test" << std::endl;
    dm_easy_mesh_t instance{};
    instance.m_num_ap_mld = 1;
    em_ap_mld_info_t &info = instance.m_ap_mld[0].m_ap_mld_info;
    info.num_affiliated_ap = 1;
    unsigned char stored_bssid[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    unsigned char lookup_bssid[6] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
    memcpy(info.affiliated_ap[0].mac_addr, stored_bssid, sizeof(mac_address_t));
    std::cout << "Invoking static get_ap_mld_frm_bssid with non-matching bssid" << std::endl;
    em_ap_mld_info_t *result = dm_easy_mesh_t::get_ap_mld_frm_bssid(static_cast<void *>(&instance), lookup_bssid);
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting static_get_ap_mld_frm_bssid_no_match test" << std::endl;
}

/**
 * @brief Verify that get_ap_mld_frm_bssid returns nullptr when no AP MLD is configured
 *
 * This test case checks the behavior of the get_ap_mld_frm_bssid API in the scenario where no AP MLD configuration is present. It creates an instance with m_num_ap_mld set to 0, sets up a BSSID array, then invokes the API and verifies that a nullptr is returned. This ensures that the API correctly handles the absence of AP MLD configuration.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 176@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                                     | Test Data                                                                  | Expected Result                                         | Notes       |
 * | :--------------: | ---------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | ------------------------------------------------------- | ----------- |
 * | 01               | Create an instance of dm_easy_mesh_t, set m_num_ap_mld to 0, define BSSID array, invoke get_ap_mld_frm_bssid | instance.m_num_ap_mld = 0, bssid = {0x10, 0x20, 0x30, 0x40, 0x50, 0x60} | API returns nullptr and EXPECT_EQ check passes          | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_ap_mld_frm_bssid_no_ap_mld_configured)
{
    std::cout << "Entering static_get_ap_mld_frm_bssid_no_ap_mld_configured test" << std::endl;
    dm_easy_mesh_t instance{};
    instance.m_num_ap_mld = 0;
    unsigned char bssid[6] = {0x10, 0x20, 0x30, 0x40, 0x50, 0x60};
    std::cout << "Invoking static get_ap_mld_frm_bssid with no AP MLD configured" << std::endl;
    em_ap_mld_info_t *result = dm_easy_mesh_t::get_ap_mld_frm_bssid(static_cast<void *>(&instance), bssid);
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting static_get_ap_mld_frm_bssid_no_ap_mld_configured test" << std::endl;
}

/**
 * @brief Test static_get_ap_mld_frm_bssid API with a NULL dm pointer
 *
 * This test verifies that the static_get_ap_mld_frm_bssid function behaves correctly when provided with a NULL dm pointer. It ensures that the function returns a NULL pointer as expected when the dm pointer is invalid.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 177@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                  | Test Data                                                           | Expected Result                                           | Notes      |
 * | :--------------: | -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- | --------------------------------------------------------- | ---------- |
 * | 01               | Invoke get_ap_mld_frm_bssid with dm pointer set to nullptr and a valid bssid array            | dm pointer = nullptr, bssid = 0xAA,0xBB,0xCC,0xDD,0xEE,0xFF        | API returns nullptr and EXPECT_EQ(result, nullptr) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_ap_mld_frm_bssid_null_dm_pointer)
{
    std::cout << "Entering static_get_ap_mld_frm_bssid_null_dm_pointer test" << std::endl;
    unsigned char bssid[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    std::cout << "Invoking static get_ap_mld_frm_bssid with NULL dm pointer" << std::endl;
    em_ap_mld_info_t *result = dm_easy_mesh_t::get_ap_mld_frm_bssid(nullptr, bssid);
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting static_get_ap_mld_frm_bssid_null_dm_pointer test" << std::endl;
}

/**
 * @brief Verify that get_ap_mld_frm_bssid returns nullptr when provided with a NULL bssid pointer.
 *
 * This test case verifies that the API dm_easy_mesh_t::get_ap_mld_frm_bssid correctly handles the scenario
 * where a NULL bssid pointer is passed. The function is expected to return a nullptr when the second parameter is NULL,
 * ensuring that the implementation properly checks for invalid input.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 178@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t instance and configure ap_mld information with a valid MAC address. | instance.m_num_ap_mld = 1, info.num_affiliated_ap = 1, valid_bssid = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF} copied into info.affiliated_ap[0].mac_addr | Instance is configured correctly with m_num_ap_mld set to 1 and ap_mld information having a valid MAC address. | Should be successful |
 * | 02 | Invoke static get_ap_mld_frm_bssid with a NULL bssid pointer. | instance pointer = address of instance, bssid = nullptr | API returns a nullptr indicating that the invalid NULL bssid pointer is handled appropriately. | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_ap_mld_frm_bssid_null_bssid)
{
    std::cout << "Entering static_get_ap_mld_frm_bssid_null_bssid test" << std::endl;
    dm_easy_mesh_t instance{};
    instance.m_num_ap_mld = 1;
    em_ap_mld_info_t &info = instance.m_ap_mld[0].m_ap_mld_info;
    info.num_affiliated_ap = 1;
    unsigned char valid_bssid[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    memcpy(info.affiliated_ap[0].mac_addr, valid_bssid, sizeof(mac_address_t));
    std::cout << "Invoking static get_ap_mld_frm_bssid with NULL bssid pointer" << std::endl;
    em_ap_mld_info_t *result = dm_easy_mesh_t::get_ap_mld_frm_bssid(static_cast<void *>(&instance), nullptr);
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting static_get_ap_mld_frm_bssid_null_bssid test" << std::endl;
}

/**
 * @brief Validate get_backhaul_bss_info() returns correct backhaul BSS info when configured properly
 *
 * This test verifies that when a BSS with backhaul configuration and its matching radio are properly set up, the 
 * get_backhaul_bss_info() API returns the correct BSS information. It checks that the returned pointer is not null and 
 * that the BSS's haul type and enabled flag are as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 179@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Configure one BSS with valid backhaul info, including setting m_num_bss, haul type, VAP mode, enabled flag, and RUID MAC | m_num_bss = 1, bss.id.haul_type = em_haul_type_backhaul, bss.vap_mode = em_vap_mode_ap, bss.enabled = true, ruid_mac = {0x10,0x11,0x12,0x13,0x14,0x15} | BSS properly configured with backhaul settings | Should be successful |
 * | 02 | Configure matching radio with the same MAC and enable the radio | m_num_radios = 1, radio.m_radio_info.intf.mac = {0x10,0x11,0x12,0x13,0x14,0x15}, radio.m_radio_info.enabled = true | Radio properly configured and enabled | Should be successful |
 * | 03 | Call get_backhaul_bss_info() API to retrieve the backhaul BSS information | Invocation of easyMesh.get_backhaul_bss_info() | API should return a non-null pointer | Should Pass |
 * | 04 | Verify that the returned BSS info has the expected backhaul type and enabled flag | result->id.haul_type should equal em_haul_type_backhaul, result->enabled should be true | The API returns the correct backhaul BSS info | Should Pass |
 */
TEST(dm_easy_mesh_t, get_backhaul_bss_info_valid_backhaul_bss_exists)
{
    std::cout << "Entering get_backhaul_bss_info_valid_backhaul_bss_exists test" << std::endl;
    dm_easy_mesh_t easyMesh;
    /* Configure one BSS */
    easyMesh.m_num_bss = 1;
    em_bss_info_t &bss = easyMesh.m_bss[0].m_bss_info;
    bss.id.haul_type = em_haul_type_backhaul;
    bss.vap_mode = em_vap_mode_ap;
    bss.enabled = true;
    unsigned char ruid_mac[6] = {0x10,0x11,0x12,0x13,0x14,0x15};
    memcpy(bss.ruid.mac, ruid_mac, sizeof(mac_address_t));
    /* Configure matching radio */
    easyMesh.m_num_radios = 1;
    dm_radio_t &radio = easyMesh.m_radio[0];
    // IMPORTANT: match what get_radio() actually uses
    memcpy(radio.m_radio_info.intf.mac, ruid_mac, sizeof(mac_address_t));
    radio.m_radio_info.enabled = true;
    std::cout << "Invoking get_backhaul_bss_info()" << std::endl;
    em_bss_info_t *result = easyMesh.get_backhaul_bss_info();
    EXPECT_NE(result, nullptr);
    if (result) {
        EXPECT_EQ(result->id.haul_type, em_haul_type_backhaul);
        EXPECT_TRUE(result->enabled);
    }
    std::cout << "Exiting get_backhaul_bss_info_valid_backhaul_bss_exists test" << std::endl;
}

/**
 * @brief Test to verify that get_backhaul_bss_info returns nullptr when no BSS is configured
 *
 * This test verifies that when the number of BSS is set to zero, the get_backhaul_bss_info API returns a nullptr, indicating that no backhaul BSS is configured. This ensures that the API correctly handles scenarios with no configuration.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 180@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                             | Test Data                         | Expected Result                                                        | Notes       |
 * | :--------------: | ----------------------------------------------------------------------- | --------------------------------- | ---------------------------------------------------------------------- | ----------- |
 * | 01               | Initialize easyMesh with m_num_bss set to 0 and call get_backhaul_bss_info API | m_num_bss = 0, output: result should be nullptr | API should return a nullptr indicating no BSS is configured, and EXPECT_EQ check passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_backhaul_bss_info_no_bss_configured)
{
    std::cout << "Entering get_backhaul_bss_info_no_bss_configured test" << std::endl;
    dm_easy_mesh_t easyMesh;
    easyMesh.m_num_bss = 0;
    std::cout << "Invoking get_backhaul_bss_info()" << std::endl;
    em_bss_info_t *result = easyMesh.get_backhaul_bss_info();
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_backhaul_bss_info_no_bss_configured test" << std::endl;
}

/**
 * @brief Verify that get_backhaul_bss_info returns nullptr for non-backhaul BSS configuration
 *
 * This test initializes a dm_easy_mesh_t object with a BSS that is configured as a non-backhaul BSS.
 * It sets the BSS information to have a fronthaul type and AP mode, and then invokes get_backhaul_bss_info()
 * to confirm that no backhaul BSS is present. This ensures that the API correctly identifies absence of a backhaul BSS.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 181@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                                                                                        | Expected Result                                                      | Notes         |
 * | :--------------: | --------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and configure BSS as non-backhaul         | m_num_bss = 1, bss.id.haul_type = em_haul_type_fronthaul, bss.vap_mode = em_vap_mode_ap, bss.enabled = true                        | Instance is set up correctly with a non-backhaul BSS                  | Should be successful |
 * | 02               | Invoke get_backhaul_bss_info() and validate its return value                 | Function call: get_backhaul_bss_info(), expected output: nullptr                                                                   | Returned value is nullptr as verified by EXPECT_EQ(result, nullptr)    | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_backhaul_bss_info_non_backhaul_bss)
{
    std::cout << "Entering get_backhaul_bss_info_non_backhaul_bss test" << std::endl;
    dm_easy_mesh_t easyMesh;
    easyMesh.m_num_bss = 1;
    em_bss_info_t &bss = easyMesh.m_bss[0].m_bss_info;
    bss.id.haul_type = em_haul_type_fronthaul;
    bss.vap_mode = em_vap_mode_ap;
    bss.enabled = true;
    std::cout << "Invoking get_backhaul_bss_info()" << std::endl;
    em_bss_info_t *result = easyMesh.get_backhaul_bss_info();
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_backhaul_bss_info_non_backhaul_bss test" << std::endl;
}

/**
 * @brief Validates get_backhaul_bss_info() behavior when radio configuration is missing.
 *
 * This test sets up a dm_easy_mesh_t instance with one backhaul BSS configured in access point mode and a valid ruid MAC address, but intentionally leaves the radio configuration empty to simulate a missing radio scenario. The test verifies that get_backhaul_bss_info() returns nullptr under these conditions.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 182@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                         | Test Data                                                                                                                       | Expected Result                                                       | Notes            |
 * | :--------------: | --------------------------------------------------------------------| -------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- | ---------------- |
 * |       01         | Initialize the dm_easy_mesh_t object and configure BSS info           | m_num_bss = 1, bss.id.haul_type = em_haul_type_backhaul, bss.vap_mode = em_vap_mode_ap, bss.enabled = true, ruid_mac = AA,BB,CC,DD,EE,FF | dm_easy_mesh_t object and BSS info correctly initialized               | Should be successful |
 * |       02         | Set radio configuration count to zero                               | m_num_radios = 0                                                                                                                 | No radio is configured                                                | Should be successful |
 * |       03         | Invoke get_backhaul_bss_info and validate its return value            | Call get_backhaul_bss_info()                                                                                                       | Return value is nullptr as expected; assertion check passes           | Should Pass      |
 */
TEST(dm_easy_mesh_t, get_backhaul_bss_info_radio_missing)
{
    std::cout << "Entering get_backhaul_bss_info_radio_missing test" << std::endl;
    dm_easy_mesh_t easyMesh;
    easyMesh.m_num_bss = 1;
    em_bss_info_t &bss = easyMesh.m_bss[0].m_bss_info;
    bss.id.haul_type = em_haul_type_backhaul;
    bss.vap_mode = em_vap_mode_ap;
    bss.enabled = true;
    unsigned char ruid_mac[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    memcpy(bss.ruid.mac, ruid_mac, sizeof(mac_address_t));
    /* No radios configured */
    easyMesh.m_num_radios = 0;
    std::cout << "Invoking get_backhaul_bss_info()" << std::endl;
    em_bss_info_t *result = easyMesh.get_backhaul_bss_info();
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_backhaul_bss_info_radio_missing test" << std::endl;
}

/**
 * @brief Validate that get_backhaul_bss_info() returns nullptr when the radio is disabled.
 *
 * This test verifies that when the backhaul BSS is configured correctly but the corresponding radio is disabled,
 * the get_backhaul_bss_info() API should return a nullptr. This behavior ensures that the function correctly handles
 * cases where the radio is not active despite the BSS configuration.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 183@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | ------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t instance, configure one BSS with backhaul type and active status, and configure one radio as disabled. | dm_easy_mesh_t instance, m_num_bss=1, bss.m_bss_info: id.haul_type = em_haul_type_backhaul, vap_mode = em_vap_mode_ap, enabled = true, ruid.mac = [0x01,0x02,0x03,0x04,0x05,0x06], m_num_radios=1, radio.m_radio_info: enabled = false, id.dev_mac = [0x01,0x02,0x03,0x04,0x05,0x06] | The get_backhaul_bss_info() API returns nullptr and the EXPECT_EQ assertion passes. | Should Pass |
 */
TEST(dm_easy_mesh_t, get_backhaul_bss_info_radio_disabled)
{
    std::cout << "Entering get_backhaul_bss_info_radio_disabled test" << std::endl;
    dm_easy_mesh_t easyMesh;
    easyMesh.m_num_bss = 1;
    em_bss_info_t &bss = easyMesh.m_bss[0].m_bss_info;
    bss.id.haul_type = em_haul_type_backhaul;
    bss.vap_mode = em_vap_mode_ap;
    bss.enabled = true;
    unsigned char ruid_mac[6] = {0x01,0x02,0x03,0x04,0x05,0x06};
    memcpy(bss.ruid.mac, ruid_mac, sizeof(mac_address_t));
    easyMesh.m_num_radios = 1;
    dm_radio_t &radio = easyMesh.m_radio[0];
    memcpy(radio.m_radio_info.id.dev_mac, ruid_mac, sizeof(mac_address_t));
    radio.m_radio_info.enabled = false;
    std::cout << "Invoking get_backhaul_bss_info()" << std::endl;
    em_bss_info_t *result = easyMesh.get_backhaul_bss_info();
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_backhaul_bss_info_radio_disabled test" << std::endl;
}

/**
 * @brief Verify that get_backhaul_bss_info returns nullptr when the BSS is disabled
 *
 * This test sets up a dm_easy_mesh_t instance with one BSS configured as a backhaul BSS,
 * but with the enabled flag set to false. It also configures a corresponding radio that is enabled.
 * The objective is to verify that when the BSS is disabled, invoking get_backhaul_bss_info correctly
 * returns a nullptr.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 184@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | --------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t instance and configure one BSS with backhaul type, AP mode, disabled state, and set its MAC address; also configure one radio with the same MAC address and enabled state. | m_num_bss = 1, bss[0].m_bss_info: haul_type = em_haul_type_backhaul, vap_mode = em_vap_mode_ap, enabled = false, ruid_mac = {0x10, 0x20, 0x30, 0x40, 0x50, 0x60}; m_num_radios = 1, radio.m_radio_info.enabled = true, radio.m_radio_info.id.dev_mac = {0x10, 0x20, 0x30, 0x40, 0x50, 0x60} | dm_easy_mesh_t instance is set up with the intended configuration | Should be successful |
 * | 02 | Invoke get_backhaul_bss_info() and assert that it returns a nullptr when the BSS is disabled. | Function call: easyMesh.get_backhaul_bss_info() | Return value is nullptr and EXPECT_EQ confirms the result | Should Pass |
 */
TEST(dm_easy_mesh_t, get_backhaul_bss_info_bss_disabled)
{
    std::cout << "Entering get_backhaul_bss_info_bss_disabled test" << std::endl;
    dm_easy_mesh_t easyMesh;
    easyMesh.m_num_bss = 1;
    em_bss_info_t &bss = easyMesh.m_bss[0].m_bss_info;
    bss.id.haul_type = em_haul_type_backhaul;
    bss.vap_mode = em_vap_mode_ap;
    bss.enabled = false;
    unsigned char ruid_mac[6] = {0x10,0x20,0x30,0x40,0x50,0x60};
    memcpy(bss.ruid.mac, ruid_mac, sizeof(mac_address_t));
    easyMesh.m_num_radios = 1;
    dm_radio_t &radio = easyMesh.m_radio[0];
    memcpy(radio.m_radio_info.id.dev_mac, ruid_mac, sizeof(mac_address_t));
    radio.m_radio_info.enabled = true;
    std::cout << "Invoking get_backhaul_bss_info()" << std::endl;
    em_bss_info_t *result = easyMesh.get_backhaul_bss_info();
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_backhaul_bss_info_bss_disabled test" << std::endl;
}

/**
 * @brief Validate that get_bss returns a valid pointer for an existing BSS entry in the mesh.
 *
 * This test verifies that when the dm_easy_mesh_t object has one valid BSS entry defined by proper radio and BSS MAC addresses,
 * invoking get_bss with these addresses successfully retrieves the corresponding BSS information. It ensures that the API
 * correctly returns a non-null pointer for existing entries.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 185@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                               | Test Data                                                                                                                         | Expected Result                                                                 | Notes       |
 * | :--------------: | --------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- | ----------- |
 * | 01               | Initialize a dm_easy_mesh_t object with one BSS entry and set valid radio and BSS MAC addresses, then invoke get_bss API using these addresses. | mesh.m_num_bss = 1, radio_mac = {0x12,0x34,0x56,0x78,0x9A,0xBC}, bss_mac = {0xAB,0xCD,0xEF,0x12,0x34,0x56}, result pointer | get_bss returns a non-null pointer; the EXPECT_NE assertion is passed.          | Should Pass |
 */
TEST(dm_easy_mesh_t, get_bss_valid_existing)
{
    const char *testName = "get_bss_valid_existing";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 1;
    unsigned char radio_mac[6] = {0x12,0x34,0x56,0x78,0x9A,0xBC};
    unsigned char bss_mac[6]   = {0xAB,0xCD,0xEF,0x12,0x34,0x56};
    memcpy(mesh.m_bss[0].m_bss_info.ruid.mac, radio_mac, sizeof(mac_address_t));
    memcpy(mesh.m_bss[0].m_bss_info.bssid.mac, bss_mac, sizeof(mac_address_t));
    std::cout << "Invoking get_bss()" << std::endl;
    dm_bss_t *result = mesh.get_bss(radio_mac, bss_mac);
    EXPECT_NE(result, nullptr);
    if (result) {
        std::cout << "BSS found successfully" << std::endl;
    }
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate get_bss API returns nullptr when an invalid BSS MAC is provided
 *
 * Validate that the get_bss API correctly returns a nullptr when invoked with a valid radio MAC but an invalid (wrong) BSS MAC.
 * This test ensures that the API does not return a valid BSS entry when the provided BSS MAC does not match the stored valid BSS MAC.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 186@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                              | Test Data                                                                                                   | Expected Result                                                              | Notes           |
 * | :--------------: | -------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- | --------------- |
 * |01| Initialize dm_easy_mesh_t object and its properties, including setting m_num_bss to 1 and defining valid MAC addresses for radio and BSS | mesh.m_num_bss = 1, radio_mac = {0x12,0x34,0x56,0x78,0x9A,0xBC}, valid_bss = {0xAB,0xCD,0xEF,0x12,0x34,0x56} | Object is initialized with one BSS entry set with valid radio and BSS MAC addresses           | Should be successful |
 * |02| Set up the test by copying the defined MAC addresses into the object's members and defining a wrong BSS MAC to simulate the error scenario | wrong_bss = {0x00,0x00,0x00,0x00,0x00,0x00}                                                                   | The object has valid BSS details, but a wrong BSS MAC is provided for the API call              | Should be successful |
 * |03| Invoke the get_bss API with the valid radio MAC and the wrong BSS MAC and verify the return value using an assertion | Call get_bss(radio_mac, wrong_bss)                                                                            | Returns nullptr, and the test assertion EXPECT_EQ(result, nullptr) passes                         | Should Pass     |
 */
TEST(dm_easy_mesh_t, get_bss_invalid_bss_mac)
{
    std::cout << "Entering get_bss_invalid_bss_mac test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 1;
    unsigned char radio_mac[6] = {0x12,0x34,0x56,0x78,0x9A,0xBC};
    unsigned char valid_bss[6] = {0xAB,0xCD,0xEF,0x12,0x34,0x56};
    unsigned char wrong_bss[6] = {0x00,0x00,0x00,0x00,0x00,0x00};
    memcpy(mesh.m_bss[0].m_bss_info.ruid.mac, radio_mac, sizeof(mac_address_t));
    memcpy(mesh.m_bss[0].m_bss_info.bssid.mac, valid_bss, sizeof(mac_address_t));
    std::cout << "Invoking get_bss()" << std::endl;
    dm_bss_t *result = mesh.get_bss(radio_mac, wrong_bss);
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_bss_invalid_bss_mac test" << std::endl;
}

/**
 * @brief Validate get_bss() with invalid radio MAC input
 *
 * This test verifies that calling get_bss() with an incorrect radio MAC returns a null pointer, indicating that the API does not find a matching BSS entry when provided with invalid radio MAC data.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 187@n
 * **Priority:** High
 * 
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Set the number of BSS and prepare a valid radio MAC for a valid BSS entry | mesh.m_num_bss = 1, valid_radio = {0x12,0x34,0x56,0x78,0x9A,0xBC} | Valid radio MAC is set in the mesh structure | Should be successful |
 * | 02 | Configure the BSS MAC and copy the valid radio MAC to the BSS information | bss_mac = {0xAB,0xCD,0xEF,0x12,0x34,0x56}, copy valid_radio into mesh.m_bss[0].m_bss_info.ruid.mac, copy bss_mac into mesh.m_bss[0].m_bss_info.bssid.mac | BSS information is correctly set with valid radio MAC and BSS MAC | Should be successful |
 * | 03 | Invoke get_bss() with an invalid radio MAC and valid BSS MAC | wrong_radio = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}, bss_mac = {0xAB,0xCD,0xEF,0x12,0x34,0x56} | API returns nullptr, and EXPECT_EQ(result, nullptr) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_bss_invalid_radio_mac)
{
    std::cout << "Entering get_bss_invalid_radio_mac test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 1;
    unsigned char valid_radio[6] = {0x12,0x34,0x56,0x78,0x9A,0xBC};
    unsigned char wrong_radio[6] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
    unsigned char bss_mac[6]     = {0xAB,0xCD,0xEF,0x12,0x34,0x56};
    memcpy(mesh.m_bss[0].m_bss_info.ruid.mac, valid_radio, sizeof(mac_address_t));
    memcpy(mesh.m_bss[0].m_bss_info.bssid.mac, bss_mac, sizeof(mac_address_t));
    std::cout << "Invoking get_bss()" << std::endl;
    dm_bss_t *result = mesh.get_bss(wrong_radio, bss_mac);
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_bss_invalid_radio_mac test" << std::endl;
}

/**
 * @brief Verify that get_bss returns nullptr when no BSS is configured
 *
 * This test verifies that the get_bss API correctly returns a nullptr when the mesh instance has no BSS configured.
 * It is important to ensure that the system handles unconfigured BSS states gracefully without causing undefined behavior.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 188@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize mesh instance, set m_num_bss to 0, and invoke get_bss with provided radio and BSS addresses | mesh.m_num_bss = 0, radio[6] = {0x01,0x02,0x03,0x04,0x05,0x06}, bss[6] = {0x10,0x11,0x12,0x13,0x14,0x15} | API returns nullptr indicating that no BSS is configured and the assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_bss_1_no_bss_configured)
{
    std::cout << "Entering get_bss_1_no_bss_configured test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 0;
    unsigned char radio[6] = {0x01,0x02,0x03,0x04,0x05,0x06};
    unsigned char bss[6]   = {0x10,0x11,0x12,0x13,0x14,0x15};
    dm_bss_t *result = mesh.get_bss(radio, bss);
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_bss_1_no_bss_configured test" << std::endl;
}

/**
 * @brief Validate get_bss for a valid index zero
 *
 * This test verifies that, for a valid mesh configuration with one BSS, invoking the get_bss API with index 0 returns a non-null pointer
 * to the corresponding BSS structure with the correct vap_index (7) and enabled flag set to true.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 189@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                 | Test Data                                                                                                          | Expected Result                                                         | Notes          |
 * | :--------------: | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------- | -------------- |
 * | 01               | Initialize a dm_easy_mesh_t instance with one BSS and configure its fields. | input: mesh.m_num_bss = 1, mesh.m_bss[0].m_bss_info.vap_index = 7, mesh.m_bss[0].m_bss_info.enabled = true          | Mesh instance is set up correctly with proper BSS configuration         | Should be successful |
 * | 02               | Invoke get_bss API using index 0.                                             | input: index = 0; output: bss pointer                                                                              | Returned pointer is not nullptr                                          | Should Pass    |
 * | 03               | Validate the retrieved BSS data against expected initialization values.     | output: bss->m_bss_info.vap_index, bss->m_bss_info.enabled                                                          | bss->m_bss_info.vap_index equals 7 and bss->m_bss_info.enabled is true    | Should Pass    |
 */
TEST(dm_easy_mesh_t, get_bss_valid_index_zero)
{
    std::cout << "Entering get_bss_valid_index_zero test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 1;
    mesh.m_bss[0].m_bss_info.vap_index = 7;
    mesh.m_bss[0].m_bss_info.enabled = true;
    std::cout << "Invoking get_bss(index = 0)" << std::endl;
    dm_bss_t *bss = mesh.get_bss(0);
    EXPECT_NE(bss, nullptr);
    EXPECT_EQ(bss->m_bss_info.vap_index, 7);
    EXPECT_TRUE(bss->m_bss_info.enabled);
    std::cout << "Exiting get_bss_valid_index_zero test" << std::endl;
}

/**
 * @brief Validate that get_bss returns the correct BSS details when queried with the valid last index in the mesh.
 *
 * This test verifies that the get_bss API correctly returns a non-null pointer along with the expected BSS configuration details (vap_index and enabled flag) when the last BSS in the mesh is accessed.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 190@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01| Initialize dm_easy_mesh_t instance and configure it with three BSS entries; assign vap_index=99 and enabled=false to the last BSS | m_num_bss=3, m_bss[2].m_bss_info.vap_index=99, m_bss[2].m_bss_info.enabled=false | Mesh instance is correctly configured with the last BSS settings | Should be successful |
 * | 02| Invoke get_bss API with index=2 to retrieve the last BSS entry | index=2 | A non-null pointer to BSS is returned with the correct configuration | Should Pass |
 * | 03| Assert that the returned pointer is not null | n/a | bss != nullptr | Should Pass |
 * | 04| Assert that the BSS vap_index is 99 | n/a | bss->m_bss_info.vap_index == 99 | Should Pass |
 * | 05| Assert that the BSS enabled flag is false | n/a | bss->m_bss_info.enabled is false | Should Pass |
 */
TEST(dm_easy_mesh_t, get_bss_valid_last_index)
{
    std::cout << "Entering get_bss_valid_last_index test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 3;
    mesh.m_bss[2].m_bss_info.vap_index = 99;
    mesh.m_bss[2].m_bss_info.enabled = false;
    std::cout << "Invoking get_bss(index = 2)" << std::endl;
    dm_bss_t *bss = mesh.get_bss(2);
    EXPECT_NE(bss, nullptr);
    EXPECT_EQ(bss->m_bss_info.vap_index, 99);
    EXPECT_FALSE(bss->m_bss_info.enabled);
    std::cout << "Exiting get_bss_valid_last_index test" << std::endl;
}

/**
 * @brief Test get_bss with an index out of the configured BSS range.
 *
 * This test verifies that the get_bss API returns a non-null pointer when an index beyond the configured number of BSS entries is provided.
 * The test is designed to ensure that even with an out-of-range index, the API handles the condition gracefully without causing a crash.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 191@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                        | Expected Result                                    | Notes       |
 * | :--------------: | --------------------------------------------------------------------------- | -------------------------------- | -------------------------------------------------- | ----------- |
 * | 01               | Initialize dm_easy_mesh_t, set m_num_bss to 1, and invoke get_bss with index 5 | mesh.m_num_bss = 1, index = 5      | API returns a non-null pointer indicating proper handling of out-of-range index | Should Pass |
 */
TEST(dm_easy_mesh_t, get_bss_index_out_of_configured_range)
{
    std::cout << "Entering get_bss_index_out_of_configured_range test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 1;
    unsigned int index = 5;
    std::cout << "Invoking get_bss(index = " << index << ")" << std::endl;
    dm_bss_t *bss = mesh.get_bss(index);
    EXPECT_NE(bss, nullptr);
    std::cout << "NOTE: Index is out of configured range. Pointer must not be dereferenced." << std::endl;
    std::cout << "Exiting get_bss_index_out_of_configured_range test" << std::endl;
}

/**
 * @brief Validate get_bss API when no BSS is configured
 *
 * This test validates that calling the get_bss API on a dm_easy_mesh_t object with m_num_bss set to 0 returns a non-null pointer even though no valid BSS is configured. The test helps ensure that the API always returns a pointer object, even when its content is invalid, to prevent potential null pointer issues.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 192@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                              | Test Data                                | Expected Result                                           | Notes         |
 * | :--------------: | -------------------------------------------------------------------------------------------------------- | ---------------------------------------- | --------------------------------------------------------- | ------------- |
 * |       01         | Create a dm_easy_mesh_t instance, set m_num_bss to 0, and invoke get_bss with index = 0                   | m_num_bss = 0, index = 0                   | get_bss returns a non-null pointer; assertion EXPECT_NE(bss, nullptr) passes | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_bss_no_bss_configured)
{
    std::cout << "Entering get_bss_no_bss_configured test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 0;
    std::cout << "Invoking get_bss(index = 0)" << std::endl;
    dm_bss_t *bss = mesh.get_bss(0);
    EXPECT_NE(bss, nullptr);
    std::cout << "NOTE: No BSS configured. Pointer exists but content is invalid." << std::endl;
    std::cout << "Exiting get_bss_no_bss_configured test" << std::endl;
}

/**
 * @brief Test to validate the integrity of multiple BSS entries retrieval
 *
 * This test validates that when multiple BSS entries are added to the dm_easy_mesh_t instance, the get_bss function returns the correctly assigned BSS information.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 193@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                        | Test Data                                                        | Expected Result                                                      | Notes         |
 * | :----:           | ------------------------------------------------------------------ | ---------------------------------------------------------------- | -------------------------------------------------------------------- | ------------- |
 * | 01               | Create a dm_easy_mesh_t instance and set m_num_bss to 2              | mesh.m_num_bss = 2                                               | Instance created with m_num_bss set to 2                             | Should be successful |
 * | 02               | Assign vap_index for each BSS entry in the mesh                      | mesh.m_bss[0].m_bss_info.vap_index = 1, mesh.m_bss[1].m_bss_info.vap_index = 2 | vap_index values assigned correctly for each entry                   | Should be successful |
 * | 03               | Invoke get_bss for index 0 and index 1 and validate the returned values | input index = 0, input index = 1                                   | bss0->m_bss_info.vap_index equals 1 and bss1->m_bss_info.vap_index equals 2 | Should Pass  |
 */
TEST(dm_easy_mesh_t, get_bss_multiple_entries_integrity)
{
    std::cout << "Entering get_bss_multiple_entries_integrity test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 2;
    mesh.m_bss[0].m_bss_info.vap_index = 1;
    mesh.m_bss[1].m_bss_info.vap_index = 2;
    dm_bss_t *bss0 = mesh.get_bss(0);
    dm_bss_t *bss1 = mesh.get_bss(1);
    EXPECT_EQ(bss0->m_bss_info.vap_index, 1);
    EXPECT_EQ(bss1->m_bss_info.vap_index, 2);
    std::cout << "Exiting get_bss_multiple_entries_integrity test" << std::endl;
}

/**
 * @brief Validate that the API returns a valid BSS reference for index zero
 *
 * This test verifies that invoking get_bss_by_ref with index 0 on a dm_easy_mesh_t instance that contains a single BSS returns a reference to that BSS with the expected properties. Specifically, it checks that the vap_index is correctly set to 10 and the enabled flag is true.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 194@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create an instance of dm_easy_mesh_t and configure it with a single BSS entry | m_num_bss = 1, m_bss[0].m_bss_info.vap_index = 10, m_bss[0].m_bss_info.enabled = true | Instance is initialized with one BSS having the specified values | Should be successful |
 * | 02 | Invoke get_bss_by_ref method with index 0 | input: index = 0 | Returns reference to BSS at index 0 with vap_index 10 and enabled true | Should Pass |
 * | 03 | Verify the returned BSS reference values using assertions | EXPECT_EQ(bssRef.m_bss_info.vap_index, 10), EXPECT_TRUE(bssRef.m_bss_info.enabled) | Assertions pass confirming correct values are returned | Should Pass |
 */
TEST(dm_easy_mesh_t, get_bss_by_ref_valid_index_zero)
{
    std::cout << "Entering get_bss_by_ref_valid_index_zero test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 1;
    mesh.m_bss[0].m_bss_info.vap_index = 10;
    mesh.m_bss[0].m_bss_info.enabled = true;
    std::cout << "Invoking get_bss_by_ref(index = 0)" << std::endl;
    dm_bss_t& bssRef = mesh.get_bss_by_ref(0);
    EXPECT_EQ(bssRef.m_bss_info.vap_index, 10);
    EXPECT_TRUE(bssRef.m_bss_info.enabled);
    std::cout << "Exiting get_bss_by_ref_valid_index_zero test" << std::endl;
}

/**
 * @brief Verify that get_bss_by_ref returns a valid BSS reference from the last index.
 *
 * This test case verifies that for a mesh object with a set number of BSS entries, invoking
 * get_bss_by_ref with the last valid index correctly returns a reference to the BSS with the
 * expected property values (vap_index and enabled flag). This ensures that the function handles
 * boundary indices appropriately.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 195@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                               | Test Data                                                              | Expected Result                                                              | Notes            |
 * | :--------------: | --------------------------------------------------------- | ---------------------------------------------------------------------- | ---------------------------------------------------------------------------- | ---------------- |
 * | 01               | Initialize mesh with a fixed number of BSS entries        | mesh.m_num_bss = 3                                                     | Mesh object has 3 BSS entries                                                | Should be successful |
 * | 02               | Set the properties of the last BSS entry                  | mesh.m_bss[2].m_bss_info.vap_index = 42, mesh.m_bss[2].m_bss_info.enabled = false | Last BSS properties set to vap_index 42 and enabled false                   | Should be successful |
 * | 03               | Invoke get_bss_by_ref with the last index                 | index = 2                                                              | Returns reference to BSS with vap_index 42 and enabled false                 | Should Pass      |
 * | 04               | Validate returned BSS properties using assertions         | output: bssRef.m_bss_info.vap_index, bssRef.m_bss_info.enabled           | EXPECT_EQ returns 42 and EXPECT_FALSE returns true                           | Should Pass      |
 */
TEST(dm_easy_mesh_t, get_bss_by_ref_valid_last_index)
{
    std::cout << "Entering get_bss_by_ref_valid_last_index test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 3;
    mesh.m_bss[2].m_bss_info.vap_index = 42;
    mesh.m_bss[2].m_bss_info.enabled = false;
    std::cout << "Invoking get_bss_by_ref(index = 2)" << std::endl;
    dm_bss_t& bssRef = mesh.get_bss_by_ref(2);
    EXPECT_EQ(bssRef.m_bss_info.vap_index, 42);
    EXPECT_FALSE(bssRef.m_bss_info.enabled);
    std::cout << "Exiting get_bss_by_ref_valid_last_index test" << std::endl;
}

/**
 * @brief Test to verify behavior of get_bss_by_ref when no BSS is configured.
 *
 * This test checks that when calling get_bss_by_ref on a dm_easy_mesh_t object with no BSS configured (m_num_bss = 0),
 * the API returns a reference, though the reference points to invalid data because no BSS is actually configured.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 196@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                       | Test Data                                                | Expected Result                                        | Notes       |
 * | :--------------: | ----------------------------------------------------------------- | -------------------------------------------------------- | ------------------------------------------------------ | ----------- |
 * | 01               | Invoke get_bss_by_ref with index 0 on a mesh with no BSS configured. | m_num_bss = 0, index = 0, returned reference = bssRef exists | A reference is returned but it points to invalid data. | Should Pass |
 */
TEST(dm_easy_mesh_t, get_bss_by_ref_no_bss_configured)
{
    std::cout << "Entering get_bss_by_ref_no_bss_configured test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 0;
    std::cout << "Invoking get_bss_by_ref(index = 0)" << std::endl;
    dm_bss_t& bssRef = mesh.get_bss_by_ref(0);
    (void)bssRef;
    std::cout << "NOTE: No BSS configured. Reference exists but data is invalid." << std::endl;
    std::cout << "Exiting get_bss_by_ref_no_bss_configured test" << std::endl;
}

/**
 * @brief Verify that get_bss_by_ref returns the same reference identity for identical indices.
 *
 * This test verifies that invoking get_bss_by_ref with the same index returns the same reference.
 * It checks for pointer equality between two invocations and confirms that the underlying data (vap_index) remains as set.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 197@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                       | Test Data                                                                | Expected Result                                              | Notes         |
 * | :--------------: | ------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------ | ------------- |
 * | 01               | Initialize the dm_easy_mesh_t object and set m_num_bss and vap_index of the first BSS            | mesh.m_num_bss = 1, mesh.m_bss[0].m_bss_info.vap_index = 88               | dm_easy_mesh_t object initialized correctly and BSS configured | Should be successful |
 * | 02               | Call get_bss_by_ref twice with index 0 to obtain BSS references                                    | input index = 0, output: ref1, ref2                                        | Both references refer to the same memory location             | Should Pass   |
 * | 03               | Verify that the BSS's vap_index is equal to 88                                                     | ref1.m_bss_info.vap_index = 88                                             | vap_index is 88 as set in the initialization                  | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_bss_by_ref_reference_identity)
{
    std::cout << "Entering get_bss_by_ref_reference_identity test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 1;
    mesh.m_bss[0].m_bss_info.vap_index = 88;
    dm_bss_t& ref1 = mesh.get_bss_by_ref(0);
    dm_bss_t& ref2 = mesh.get_bss_by_ref(0);
    EXPECT_EQ(&ref1, &ref2);
    EXPECT_EQ(ref1.m_bss_info.vap_index, 88);
    std::cout << "Exiting get_bss_by_ref_reference_identity test" << std::endl;
}

/**
 * @brief Verify that get_bss_info returns valid BSS information for index 0.
 *
 * This test verifies that the get_bss_info API correctly retrieves the BSS information when a valid index (0) is provided. It sets up an instance of dm_easy_mesh_t with one BSS entry and initializes its vap_index and enabled status. The test ensures that the returned pointer is not null and that the contained BSS information matches the initialized values.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 198@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | --------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object, set m_num_bss to 1, assign vap_index=1 and enabled=true to the first BSS entry; then call get_bss_info with index 0 | mesh.m_num_bss = 1, mesh.m_bss[0].m_bss_info.vap_index = 1, mesh.m_bss[0].m_bss_info.enabled = true, index = 0 | Returned pointer is not nullptr, vap_index equals 1, and enabled flag is true | Should Pass |
 */
TEST(dm_easy_mesh_t, get_bss_info_valid_index_zero)
{
    std::cout << "Entering get_bss_info_valid_index_zero test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 1;
    mesh.m_bss[0].m_bss_info.vap_index = 1;
    mesh.m_bss[0].m_bss_info.enabled = true;
    std::cout << "Invoking get_bss_info(index = 0)" << std::endl;
    em_bss_info_t* info = mesh.get_bss_info(0);
    EXPECT_NE(info, nullptr);
    EXPECT_EQ(info->vap_index, 1);
    EXPECT_TRUE(info->enabled);
    std::cout << "Exiting get_bss_info_valid_index_zero test" << std::endl;
}

/**
 * @brief Test get_bss_info API with valid last index.
 *
 * This test verifies that the get_bss_info API properly returns the BSS information when invoked with a valid last index. The test checks that the returned pointer is not null and that the BSS info attributes (vap_index and enabled) match the expected values.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 199@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Setup the mesh object with valid BSS configuration | dm_easy_mesh_t mesh, m_num_bss = 3, mesh.m_bss[2].m_bss_info.vap_index = 99, mesh.m_bss[2].m_bss_info.enabled = false | Mesh object is correctly configured with three BSS entries and proper BSS info for the last index | Should be successful |
 * | 02 | Invoke get_bss_info API and validate the returned BSS information | index = 2 | Returned pointer is not null; vap_index equals 99; enabled is false | Should Pass |
 */
TEST(dm_easy_mesh_t, get_bss_info_valid_last_index)
{
    std::cout << "Entering get_bss_info_valid_last_index test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 3;
    mesh.m_bss[2].m_bss_info.vap_index = 99;
    mesh.m_bss[2].m_bss_info.enabled = false;
    std::cout << "Invoking get_bss_info(index = 2)" << std::endl;
    em_bss_info_t* info = mesh.get_bss_info(2);
    EXPECT_NE(info, nullptr);
    EXPECT_EQ(info->vap_index, 99);
    EXPECT_FALSE(info->enabled);
    std::cout << "Exiting get_bss_info_valid_last_index test" << std::endl;
}

/**
 * @brief Test get_bss_info when no BSS is configured
 *
 * This test verifies that calling get_bss_info with index 0 returns an invalid pointer when no BSS are configured. The test is important to ensure that the function correctly handles the scenario where the internal BSS count is zero and that it does not attempt to access an uninitialized or non-existent BSS configuration.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 200@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                      | Test Data                                             | Expected Result                                                               | Notes         |
 * | :--------------: | ---------------------------------------------------------------- | ----------------------------------------------------- | ----------------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize a dm_easy_mesh_t object and set m_num_bss to 0        | m_num_bss = 0                                         | Instance is created with m_num_bss = 0                                        | Should be successful |
 * | 02               | Invoke get_bss_info with index 0 on the object                     | input index = 0, m_num_bss = 0; output pointer = info   | Returned pointer is invalid if dereferenced as m_num_bss is 0 (no BSS configured) | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_bss_info_no_bss_configured)
{
    std::cout << "Entering get_bss_info_no_bss_configured test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_bss = 0;
    std::cout << "Invoking get_bss_info(index = 0)" << std::endl;
    em_bss_info_t* info = mesh.get_bss_info(0);
    (void)info;
    std::cout << "NOTE: m_num_bss is zero. Returned pointer is invalid if dereferenced." << std::endl;
    std::cout << "Exiting get_bss_info_no_bss_configured test" << std::endl;
}

/**
 * @brief Validate that static get_bss_info retrieves correct BSS info for given mesh and index
 *
 * Validate that the static get_bss_info method of dm_easy_mesh_t correctly returns the BSS information when provided with a valid device management pointer and an index. This test confirms that the returned pointer is not null, the vap_index is 10, and the enabled flag is set to true.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 201@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize mesh object and assign BSS information | mesh, m_num_bss = 1, m_bss[0].m_bss_info.vap_index = 10, m_bss[0].m_bss_info.enabled = true | Mesh object is correctly initialized with given BSS info | Should be successful |
 * | 02 | Invoke the static get_bss_info method with a valid dm pointer and index 0 | Input: dm pointer = &mesh, index = 0 | The API returns a non-null pointer | Should Pass |
 * | 03 | Validate the returned BSS information fields against expected values | Output: info->vap_index, info->enabled; Expected: vap_index = 10, enabled = true | API returns the correct BSS information; Assertions pass: ASSERT_NE(info, nullptr), EXPECT_EQ(info->vap_index, 10), EXPECT_TRUE(info->enabled) | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_bss_info_valid_dm_and_index)
{
    std::cout << "Entering static_get_bss_info_valid_dm_and_index test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 1;
    mesh.m_bss[0].m_bss_info.vap_index = 10;
    mesh.m_bss[0].m_bss_info.enabled   = true;
    std::cout << "Invoking static get_bss_info with valid dm and index 0" << std::endl;
    em_bss_info_t* info = dm_easy_mesh_t::get_bss_info(static_cast<void*>(&mesh), 0);
    ASSERT_NE(info, nullptr);
    EXPECT_EQ(info->vap_index, 10);
    EXPECT_TRUE(info->enabled);
    std::cout << "Exiting static_get_bss_info_valid_dm_and_index test" << std::endl;
}

/**
 * @brief Verify that get_bss_info returns a valid bss_info pointer for a valid high index.
 *
 * This test verifies that when the dm_easy_mesh_t object is configured with an appropriate number
 * of BSS entries and the BSS at the highest index is set with a specific vap_index value, calling
 * dm_easy_mesh_t::get_bss_info with that valid index returns a non-null pointer with the expected
 * vap_index value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 202@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                           | Test Data                                                   | Expected Result                                                                  | Notes          |
 * | :--------------: | ----------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- | -------------------------------------------------------------------------------- | -------------- |
 * | 01               | Initialize dm_easy_mesh_t object with three BSS entries and set m_bss[2].m_bss_info.vap_index = 42    | m_num_bss = 3, m_bss[2].vap_index = 42                       | Mesh object initialized with 3 BSS entries and vAP index set for index 2        | Should be successful |
 * | 02               | Invoke static get_bss_info API with index 2 on the initialized mesh object                              | Input: mesh pointer, index = 2                                | Returned pointer should not be nullptr                                           | Should Pass    |
 * | 03               | Validate that the retrieved bss_info's vap_index equals 42                                            | Output: info->vap_index = expected value, 42                  | info->vap_index is equal to 42 as asserted by EXPECT_EQ                           | Should Pass    |
 */
TEST(dm_easy_mesh_t, static_get_bss_info_valid_high_index)
{
    std::cout << "Entering static_get_bss_info_valid_high_index test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 3;
    mesh.m_bss[2].m_bss_info.vap_index = 42;
    std::cout << "Invoking static get_bss_info with index 2" << std::endl;
    em_bss_info_t* info = dm_easy_mesh_t::get_bss_info(&mesh, 2);
    ASSERT_NE(info, nullptr);
    EXPECT_EQ(info->vap_index, 42);
    std::cout << "Exiting static_get_bss_info_valid_high_index test" << std::endl;
}

/**
 * @brief Test behavior of get_bss_info when passed a null dm pointer.
 *
 * This test confirms that the static method get_bss_info of dm_easy_mesh_t correctly handles a null dm pointer by returning a non-null info pointer. It verifies robustness by ensuring that even when an invalid dm is provided, the API handles it gracefully.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 203@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                     | Test Data                                               | Expected Result                                               | Notes       |
 * | :---------------: | --------------------------------------------------------------- | ------------------------------------------------------- | ------------------------------------------------------------- | ----------- |
 * | 01                | Set dm pointer to nullptr and invoke dm_easy_mesh_t::get_bss_info | dm = nullptr, index = 0, output: info pointer            | The returned info pointer is not null (EXPECT_NE(info, nullptr)) | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_bss_info_null_dm_pointer)
{
    std::cout << "Entering static_get_bss_info_null_dm_pointer test" << std::endl;
    void* dm = nullptr;
    std::cout << "Invoking static get_bss_info with nullptr dm" << std::endl;
    em_bss_info_t* info = dm_easy_mesh_t::get_bss_info(dm, 0);
	EXPECT_NE(info, nullptr);
    std::cout << "Exiting static_get_bss_info_null_dm_pointer test" << std::endl;
}

/**
 * @brief Verify that get_bss_info_with_mac returns the correct BSS information for a valid MAC address.
 *
 * This test validates that when a valid MAC address is provided to the get_bss_info_with_mac API of the dm_easy_mesh_t class, 
 * it appropriately returns a pointer to the corresponding BSS info structure containing the matching MAC address. This ensures the lookup 
 * functionality is working as expected for valid inputs.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 204@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                  | Test Data                                                                                                                              | Expected Result                                                                                                          | Notes       |
 * | :--------------: | -------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- | ----------- |
 * | 01               | Initialize dm_easy_mesh_t object and set two BSS entries with valid MAC addresses.           | mesh.m_num_bss = 2, mac0 = {0xAA,0xBB,0xCC,0xDD,0xEE,0x01}, mac1 = {0xAA,0xBB,0xCC,0xDD,0xEE,0x02}                                  | Mesh object is populated with two distinct BSS entries having valid MAC addresses.                                      | Should be successful |
 * | 02               | Invoke get_bss_info_with_mac using mac1 and verify that the returned BSS info has the correct MAC. | input: mac1 = {0xAA,0xBB,0xCC,0xDD,0xEE,0x02}, output: info pointer; internal check: memcmp(info->bssid.mac, mac1) should return 0 | API returns a non-null pointer and the BSS info's MAC address exactly matches the provided mac1; assertions pass.         | Should Pass |
 */
TEST(dm_easy_mesh_t, get_bss_info_with_mac_valid_mac)
{
    std::cout << "Entering get_bss_info_with_mac_valid_mac test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 2;
	unsigned char mac0[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0x01};
	unsigned char mac1[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0x02};
    memcpy(mesh.m_bss[0].m_bss_info.bssid.mac, mac0, sizeof(mac_address_t));
    memcpy(mesh.m_bss[1].m_bss_info.bssid.mac, mac1, sizeof(mac_address_t));
	std::cout << "Searching for MAC: ";
    for (int i = 0; i < 6; ++i) {
        printf("%02X", mac1[i]);
        if (i != 5) printf(":");
    }
    std::cout << std::endl;
    em_bss_info_t* info = mesh.get_bss_info_with_mac(mac1);
    ASSERT_NE(info, nullptr);
    EXPECT_EQ(memcmp(info->bssid.mac, mac1, sizeof(mac_address_t)), 0);
    std::cout << "Exiting get_bss_info_with_mac_valid_mac test" << std::endl;
}

/**
 * @brief Verify that get_bss_info_with_mac returns nullptr when provided with an invalid MAC address
 *
 * This test sets up a mesh with one BSS entry having a valid MAC address. It then attempts to retrieve 
 * the BSS information using an invalid MAC address that does not match the stored entry. This ensures 
 * that the API correctly handles cases where the requested MAC address is not present and returns a 
 * nullptr.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 205@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                                                                                                          | Expected Result                                                       | Notes             |
 * | :--------------: | --------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- | ----------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and configure it with a single BSS entry having a valid MAC   | mesh.m_num_bss = 1, existing_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0x01}                                                                  | Mesh is successfully initialized with the valid BSS entry             | Should be successful |
 * | 02               | Invoke get_bss_info_with_mac using an invalid MAC address that is not stored in the mesh           | search_mac = {0x11,0x22,0x33,0x44,0x55,0x66}                                                                                        | API returns nullptr and EXPECT_EQ(info, nullptr) assertion passes       | Should Fail       |
 */
TEST(dm_easy_mesh_t, get_bss_info_with_mac_invalid_mac)
{
    std::cout << "Entering get_bss_info_with_mac_invalid_mac test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 1;
	unsigned char existing_mac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0x01};
	unsigned char search_mac[6] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
    memcpy(mesh.m_bss[0].m_bss_info.bssid.mac, existing_mac, sizeof(mac_address_t));
    std::cout << "Searching for MAC: ";
    for (int i = 0; i < 6; ++i) {
        printf("%02X", search_mac[i]);
        if (i != 5) printf(":");
    }
    std::cout << std::endl;
    em_bss_info_t* info = mesh.get_bss_info_with_mac(search_mac);
    EXPECT_EQ(info, nullptr);
    std::cout << "Exiting get_bss_info_with_mac_invalid_mac test" << std::endl;
}

/**
 * @brief Validate that get_bss_info_with_mac returns nullptr when no BSS is configured.
 *
 * This test verifies that when the dm_easy_mesh_t instance has zero BSS configured, calling the API 
 * get_bss_info_with_mac with a valid MAC address returns a nullptr. This ensures that the function
 * correctly handles and returns a null pointer when no corresponding BSS is available.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 206@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                  | Test Data                                                              | Expected Result                                                        | Notes              |
 * | :--------------: | -------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------- | ---------------------------------------------------------------------- | ------------------ |
 * | 01               | Log the entry into the test function                                                         | None                                                                   | "Entering get_bss_info_with_mac_no_bss_configured test" message printed  | Should be successful |
 * | 02               | Initialize dm_easy_mesh_t instance and set the number of BSS to 0                              | mesh.m_num_bss = 0                                                     | dm_easy_mesh_t object created with 0 BSS configured                      | Should be successful |
 * | 03               | Prepare the search_mac array with the specified MAC address and print it                      | search_mac = 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF                         | search_mac array initialized and MAC printed in proper format            | Should be successful |
 * | 04               | Invoke get_bss_info_with_mac() using search_mac and verify the returned pointer is nullptr      | Input: search_mac = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF}, Output: expected nullptr | API returns nullptr and the assertion (EXPECT_EQ(info, nullptr)) passes    | Should Pass         |
 * | 05               | Log the exit from the test function                                                          | None                                                                   | "Exiting get_bss_info_with_mac_no_bss_configured test" message printed     | Should be successful |
 */
TEST(dm_easy_mesh_t, get_bss_info_with_mac_no_bss_configured)
{
    std::cout << "Entering get_bss_info_with_mac_no_bss_configured test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 0;
	unsigned char search_mac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    std::cout << "Searching for MAC: ";
	for (int i = 0; i < 6; ++i) {
        printf("%02X", search_mac[i]);
        if (i != 5) printf(":");
    }
    std::cout << std::endl;
    em_bss_info_t* info = mesh.get_bss_info_with_mac(search_mac);
    EXPECT_EQ(info, nullptr);
    std::cout << "Exiting get_bss_info_with_mac_no_bss_configured test" << std::endl;
}

/**
 * @brief Verify that get_bss_info_with_mac API returns correct BSS info structure when given a valid MAC address
 *
 * This test case sets up a dm_easy_mesh_t structure with two BSS entries having distinct MAC addresses. It then calls
 * get_bss_info_with_mac using a valid MAC address present in one of the BSS entries and verifies that the function returns
 * a non-null pointer along with the correct corresponding BSS info. The test ensures that the API correctly identifies and retrieves
 * the BSS info using the provided MAC address.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 207@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t with two BSS entries, set distinct MAC addresses, and invoke get_bss_info_with_mac using a valid MAC address | mesh.m_num_bss = 2, mesh.m_bss[0].m_bss_info.bssid.mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0x01}, mesh.m_bss[1].m_bss_info.bssid.mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0x02}, mac_input = {0xAA,0xBB,0xCC,0xDD,0xEE,0x02} | Non-null pointer returned; memcmp(info->bssid.mac, mac_input, sizeof(mac_address_t)) equals 0 | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_bss_info_with_mac_valid_mac)
{
    std::cout << "Entering static_get_bss_info_with_mac_valid_mac test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 2;
	unsigned char mac0[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0x01};
	unsigned char mac1[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0x02};    
    memcpy(mesh.m_bss[0].m_bss_info.bssid.mac, mac0, sizeof(mac_address_t));
    memcpy(mesh.m_bss[1].m_bss_info.bssid.mac, mac1, sizeof(mac_address_t));
    std::cout << "Searching for MAC: ";
	for (int i = 0; i < 6; ++i) {
        printf("%02X", mac1[i]);
        if (i != 5) printf(":");
    }
    std::cout << std::endl;
    em_bss_info_t* info = dm_easy_mesh_t::get_bss_info_with_mac(&mesh, mac1);
    ASSERT_NE(info, nullptr);
    EXPECT_EQ(memcmp(info->bssid.mac, mac1, sizeof(mac_address_t)), 0);
    std::cout << "Exiting static_get_bss_info_with_mac_valid_mac test" << std::endl;
}

/**
 * @brief Validate that get_bss_info_with_mac returns nullptr when provided with an invalid MAC address
 *
 * This test verifies that calling the static function get_bss_info_with_mac with a MAC address that does not match the stored BSSID
 * in the mesh object results in a nullptr being returned. This ensures that the API correctly handles cases where the target MAC address
 * is not found in the existing BSS configurations.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 208@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                             | Test Data                                                                                         | Expected Result                                                     | Notes         |
 * | :--------------: | ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize mesh instance, set number of BSS to 1, and assign a valid MAC to the first BSS entry.  | mesh.m_num_bss = 1, existing_mac = 0xAA,0xBB,0xCC,0xDD,0xEE,0x01 copied to mesh.m_bss[0].m_bss_info.bssid.mac | Mesh object is correctly initialized with one BSS having the valid MAC. | Should be successful |
 * | 02               | Call the static method get_bss_info_with_mac using an invalid MAC and verify that the function returns nullptr. | input: mesh pointer, search_mac = 0x11,0x22,0x33,0x44,0x55,0x66; output: info pointer expected as nullptr  | API returns nullptr indicating that the MAC address was not found.   | Should Fail   |
 */
TEST(dm_easy_mesh_t, static_get_bss_info_with_mac_invalid_mac)
{
    std::cout << "Entering static_get_bss_info_with_mac_invalid_mac test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 1;
	unsigned char existing_mac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0x01};
	unsigned char search_mac[6] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
    memcpy(mesh.m_bss[0].m_bss_info.bssid.mac, existing_mac, sizeof(mac_address_t));
    std::cout << "Searching for MAC: ";	
	for (int i = 0; i < 6; ++i) {
        printf("%02X", search_mac[i]);
        if (i != 5) printf(":");
    }
    std::cout << std::endl;
    em_bss_info_t* info = dm_easy_mesh_t::get_bss_info_with_mac(&mesh, search_mac);
    EXPECT_EQ(info, nullptr);
    std::cout << "Exiting static_get_bss_info_with_mac_invalid_mac test" << std::endl;
}

/**
 * @brief Tests the retrieval of BSS info when no BSS is configured in the mesh
 *
 * This test ensures that the static method get_bss_info_with_mac correctly returns a nullptr when attempting to retrieve BSS information from a mesh instance that has no BSS configured. This verifies that the API properly handles cases where there is no relevant data available.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 209@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create a dm_easy_mesh_t instance with no BSS configured | mesh object, m_num_bss = 0 | Mesh instance successfully created with m_num_bss set to 0 | Should be successful |
 * | 02 | Define a search MAC address for which no BSS is configured | search_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF} | MAC address correctly defined | Should be successful |
 * | 03 | Invoke get_bss_info_with_mac with the mesh pointer and search MAC address | input: mesh pointer, search_mac; output: info pointer expected to be nullptr | API returns nullptr, indicating no matching BSS info | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_bss_info_with_mac_no_bss_configured)
{
    std::cout << "Entering static_get_bss_info_with_mac_no_bss_configured test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 0;
	unsigned char search_mac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    std::cout << "Searching for MAC: ";	
	for (int i = 0; i < 6; ++i) {
        printf("%02X", search_mac[i]);
        if (i != 5) printf(":");
    }
    std::cout << std::endl;
    em_bss_info_t* info = dm_easy_mesh_t::get_bss_info_with_mac(&mesh, search_mac);
    EXPECT_EQ(info, nullptr);
    std::cout << "Exiting static_get_bss_info_with_mac_no_bss_configured test" << std::endl;
}

/**
 * @brief Verifies that get_bss_info_with_mac correctly handles a nullptr DM parameter.
 *
 * This test ensures that when the API function get_bss_info_with_mac is invoked with a nullptr for the DM parameter and a valid MAC address, it returns a nullptr pointer. This behavior confirms that the function properly checks for null DM inputs.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 210@n
 * **Priority:** (High) High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data |Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke get_bss_info_with_mac with dm set to nullptr and a valid MAC address | dm = nullptr, searchMac = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF} | Function returns nullptr and EXPECT_EQ(result, nullptr) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_bss_info_with_mac_null_dm)
{
    std::cout << "Entering get_bss_info_with_mac_null_dm test" << std::endl;
    unsigned char searchMac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    std::cout << "Invoking get_bss_info_with_mac with dm: nullptr and valid mac" << std::endl;
    em_bss_info_t* result = dm_easy_mesh_t::get_bss_info_with_mac(nullptr, searchMac);
    if(result) {
        std::cout << "Returned non-null pointer from get_bss_info_with_mac with nullptr dm (unexpected)." << std::endl;
    } else {
        std::cout << "Returned nullptr from get_bss_info_with_mac as expected when dm is nullptr." << std::endl;
    }
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_bss_info_with_mac_null_dm test" << std::endl;
}

/**
 * @brief Verify that get_bsta_bss_info correctly returns a valid BSS pointer for a configured backhaul STA BSS
 *
 * This test verifies that when a dm_easy_mesh_t object is properly configured with one radio and one BSS set as enabled,
 * with the BSS configured for backhaul and station mode, the get_bsta_bss_info API returns a non-null pointer. It further
 * ensures the BSS pointer contains the expected vap_mode and haul_type settings.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 211@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | ------------- | ----- |
 * | 01 | Initialize the dm_easy_mesh_t object and configure its radio with valid MAC and enable state | m_num_bss = 1, m_num_radios = 1, radio_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0x01}, radio_info.enabled = true | Mesh object is initialized with a radio configured correctly | Should be successful |
 * | 02 | Configure the BSS as a backhaul STA BSS with valid settings | bss.id.haul_type = em_haul_type_backhaul, bss.vap_mode = em_vap_mode_sta, bss.enabled = true, ruid.mac = radio_mac | BSS is correctly set to backhaul and STA mode | Should be successful |
 * | 03 | Invoke the get_bsta_bss_info() API | API call: mesh.get_bsta_bss_info() | API returns a non-null pointer to the BSS info | Should Pass |
 * | 04 | Validate the returned BSS information for vap_mode and haul_type | result->vap_mode = em_vap_mode_sta, result->id.haul_type = em_haul_type_backhaul | Returned BSS info has the expected vap_mode and haul_type | Should Pass |
 */
TEST(dm_easy_mesh_t, get_bsta_bss_info_valid_backhaul_sta_bss)
{
    std::cout << "Entering get_bsta_bss_info_valid_backhaul_sta_bss test" << std::endl;

    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 1;
    mesh.m_num_radios = 1;
    unsigned char radio_mac[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0x01};
    // Configure radio
    memcpy(mesh.m_radio[0].m_radio_info.intf.mac, radio_mac, sizeof(mac_address_t));
    mesh.m_radio[0].m_radio_info.enabled = true;
    // Configure BSS
    em_bss_info_t& bss = mesh.m_bss[0].m_bss_info;
    bss.id.haul_type = em_haul_type_backhaul;
    bss.vap_mode = em_vap_mode_sta;
    bss.enabled = true;
    memcpy(bss.ruid.mac, radio_mac, sizeof(mac_address_t));
    std::cout << "Invoking get_bsta_bss_info()" << std::endl;
    em_bss_info_t* result = mesh.get_bsta_bss_info();
    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->vap_mode, em_vap_mode_sta);
    EXPECT_EQ(result->id.haul_type, em_haul_type_backhaul);
    std::cout << "Exiting get_bsta_bss_info_valid_backhaul_sta_bss test" << std::endl;
}

/**
 * @brief Verify that get_bsta_bss_info returns nullptr when no BSS is configured.
 *
 * This test checks that when the dm_easy_mesh_t instance has its m_num_bss set to 0, the
 * get_bsta_bss_info API correctly returns a nullptr to indicate that no BSS is configured.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 212@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                         | Test Data                                                         | Expected Result                                        | Notes           |
 * | :--------------: | ------------------------------------------------------------------- | ----------------------------------------------------------------- | ------------------------------------------------------ | --------------- |
 * | 01               | Print entering test message                                         | None                                                              | "Entering get_bsta_bss_info_no_bss_configured test" printed | Should be successful |
 * | 02               | Instantiate dm_easy_mesh_t object                                   | dm_easy_mesh_t mesh{}                                             | Object instance created                                | Should be successful |
 * | 03               | Set mesh.m_num_bss to 0                                               | mesh.m_num_bss = 0                                                | m_num_bss is set to 0                                   | Should be successful |
 * | 04               | Invoke get_bsta_bss_info() method on the mesh object                  | API Call: result = mesh.get_bsta_bss_info()                         | Returns nullptr from the API                           | Should Pass     |
 * | 05               | Verify the returned value using EXPECT_EQ assertion                   | EXPECT_EQ(result, nullptr)                                        | Assertion passes confirming the API returned nullptr    | Should Pass     |
 * | 06               | Print exiting test message                                            | None                                                              | "Exiting get_bsta_bss_info_no_bss_configured test" printed | Should be successful |
 */
TEST(dm_easy_mesh_t, get_bsta_bss_info_no_bss_configured)
{
    std::cout << "Entering get_bsta_bss_info_no_bss_configured test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 0;
    em_bss_info_t* result = mesh.get_bsta_bss_info();
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_bsta_bss_info_no_bss_configured test" << std::endl;
}

/**
 * @brief Tests get_bsta_bss_info API for non-backhaul BSS configuration
 *
 * This test verifies that when a BSS is configured with fronthaul type and STA mode in the dm_easy_mesh_t instance, 
 * the get_bsta_bss_info function returns a null pointer, indicating that there is no backhaul BSS.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 213@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                 | Test Data                                                                                                                       | Expected Result                                              | Notes             |
 * | :--------------: | --------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ | ----------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and configure one BSS with fronthaul type | m_num_bss = 1, m_bss[0].m_bss_info.id.haul_type = em_haul_type_fronthaul, m_bss[0].m_bss_info.vap_mode = em_vap_mode_sta, m_bss[0].m_bss_info.enabled = true | Instance initialized with the specified BSS configuration    | Should be successful |
 * | 02               | Invoke get_bsta_bss_info API and verify that it returns nullptr              | Input: dm_easy_mesh_t instance with configured BSS; Output: result pointer expected to be nullptr                                  | result is nullptr as per EXPECT_EQ(result, nullptr)          | Should Pass       |
 */
TEST(dm_easy_mesh_t, get_bsta_bss_info_not_backhaul)
{
    std::cout << "Entering get_bsta_bss_info_not_backhaul test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 1;
    mesh.m_bss[0].m_bss_info.id.haul_type = em_haul_type_fronthaul;
    mesh.m_bss[0].m_bss_info.vap_mode = em_vap_mode_sta;
    mesh.m_bss[0].m_bss_info.enabled = true;
    em_bss_info_t* result = mesh.get_bsta_bss_info();
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_bsta_bss_info_not_backhaul test" << std::endl;
}

/**
 * @brief Test the get_bsta_bss_info API for non-STA mode BSS configuration
 *
 * This test verifies that when a BSS is configured with AP mode and backhaul settings (non-STA mode), 
 * the get_bsta_bss_info API returns a null pointer. This ensures that the API correctly identifies that 
 * there is no BSTA BSS info available for non-STA mode.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 214@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                          | Test Data                                                                                                                                                  | Expected Result                                             | Notes      |
 * | :--------------: | ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- | ---------- |
 * | 01               | Initialize the mesh with one BSS configured in AP mode and backhaul enabled, then call get_bsta_bss_info | m_num_bss = 1, m_bss[0].m_bss_info.id.haul_type = em_haul_type_backhaul, m_bss[0].m_bss_info.vap_mode = em_vap_mode_ap, m_bss[0].m_bss_info.enabled = true | Returns nullptr from get_bsta_bss_info; assertion (EXPECT_EQ(result, nullptr)) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_bsta_bss_info_not_sta_mode)
{
    std::cout << "Entering get_bsta_bss_info_not_sta_mode test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 1;
    mesh.m_bss[0].m_bss_info.id.haul_type = em_haul_type_backhaul;
    mesh.m_bss[0].m_bss_info.vap_mode = em_vap_mode_ap;
    mesh.m_bss[0].m_bss_info.enabled = true;
    em_bss_info_t* result = mesh.get_bsta_bss_info();
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_bsta_bss_info_not_sta_mode test" << std::endl;
}

/**
 * @brief Verify that get_bsta_bss_info returns nullptr when no radios are available
 *
 * This test verifies that when the dm_easy_mesh_t object is configured with one BSS and zero radios, 
 * the get_bsta_bss_info API returns a nullptr. The test sets the BSS parameters, including haul type, VAP mode, 
 * and enabled flag, then asserts that the output is nullptr because the absence of radios should prevent retrieval 
 * of the BSTA BSS info.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 215@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                  | Test Data                                                                                                              | Expected Result                                           | Notes          |
 * | :--------------: | ---------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------- | -------------- |
 * | 01               | Log the start of the test execution                                          | N/A                                                                                                                    | "Entering get_bsta_bss_info_radio_not_found test" printed  | Should be successful |
 * | 02               | Initialize dm_easy_mesh_t instance with 1 BSS and 0 Radios                     | m_num_bss = 1, m_num_radios = 0                                                                                          | Object initialized with specified configurations         | Should be successful |
 * | 03               | Configure the BSS parameters (haul_type, vap_mode, enabled)                    | haul_type = em_haul_type_backhaul, vap_mode = em_vap_mode_sta, enabled = true                                             | BSS parameters set accordingly                           | Should be successful |
 * | 04               | Invoke get_bsta_bss_info API and check the returned BSS info pointer           | API call on mesh instance; expected output: result = nullptr                                                           | API returns nullptr and assertion EXPECT_EQ(result, nullptr) passes | Should Pass    |
 * | 05               | Log the completion of the test execution                                     | N/A                                                                                                                    | "Exiting get_bsta_bss_info_radio_not_found test" printed   | Should be successful |
 */
TEST(dm_easy_mesh_t, get_bsta_bss_info_radio_not_found)
{
    std::cout << "Entering get_bsta_bss_info_radio_not_found test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 1;
    mesh.m_num_radios = 0;
    mesh.m_bss[0].m_bss_info.id.haul_type = em_haul_type_backhaul;
    mesh.m_bss[0].m_bss_info.vap_mode = em_vap_mode_sta;
    mesh.m_bss[0].m_bss_info.enabled = true;
    em_bss_info_t* result = mesh.get_bsta_bss_info();
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_bsta_bss_info_radio_not_found test" << std::endl;
}

/**
 * @brief Validate that get_bsta_bss_info returns nullptr when the radio is disabled
 *
 * This test verifies that when the radio in the mesh is marked as disabled, the get_bsta_bss_info API
 * does not return any BSS information and instead returns a nullptr. This ensures that the function
 * correctly handles the disabled state of the radio.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 216@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                                             | Test Data                                                                                                                                                      | Expected Result                                                                                  | Notes         |
 * | :--------------: | ----------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ | ------------- |
 * | 01               | Initialize the mesh object with one radio and one BSS, set radio MAC address and mark the radio as disabled.             | mesh.m_num_bss = 1, mesh.m_num_radios = 1, radio_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0x02}, mesh.m_radio[0].m_radio_info.enabled = false, etc.                | Mesh object is configured correctly with the radio disabled and BSS properly initialized.         | Should be successful  |
 * | 02               | Invoke the get_bsta_bss_info API to retrieve BSS info based on the current mesh configuration and validate response.    | API Call: result = mesh.get_bsta_bss_info(), input: mesh configuration with disabled radio; output: expected nullptr; assertion: EXPECT_EQ(result, nullptr) | The API should return nullptr since the radio is disabled and no valid BSS info should be returned. | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_bsta_bss_info_radio_disabled)
{
    std::cout << "Entering get_bsta_bss_info_radio_disabled test" << std::endl;

    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 1;
    mesh.m_num_radios = 1;
    unsigned char radio_mac[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0x02};
    memcpy(mesh.m_radio[0].m_radio_info.intf.mac, radio_mac, sizeof(mac_address_t));
    mesh.m_radio[0].m_radio_info.enabled = false;
    em_bss_info_t& bss = mesh.m_bss[0].m_bss_info;
    bss.id.haul_type = em_haul_type_backhaul;
    bss.vap_mode = em_vap_mode_sta;
    bss.enabled = true;
    memcpy(bss.ruid.mac, radio_mac, sizeof(mac_address_t));
    em_bss_info_t* result = mesh.get_bsta_bss_info();
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_bsta_bss_info_radio_disabled test" << std::endl;
}

/**
 * @brief Verify that get_bsta_bss_info returns nullptr when the BSS is disabled
 *
 * This test case verifies that when a mesh is configured with one radio and one BSS where the radio is enabled and the BSS is disabled, the API function get_bsta_bss_info returns a nullptr. This is to ensure that the function behaves correctly in a scenario where the BSS is not active.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 217@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | --------------- | ----- |
 * | 01 | Configure a mesh with one radio and one BSS. Set the radio to enabled and the BSS to disabled, then invoke get_bsta_bss_info(). | m_num_bss = 1, m_num_radios = 1, radio_mac = 0xAA,0xBB,0xCC,0xDD,0xEE,0x03, radio enabled = true, bss enabled = false | get_bsta_bss_info() returns nullptr; assertion EXPECT_EQ(result, nullptr) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_bsta_bss_info_bss_disabled)
{
    std::cout << "Entering get_bsta_bss_info_bss_disabled test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bss = 1;
    mesh.m_num_radios = 1;
    unsigned char radio_mac[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0x03};
    memcpy(mesh.m_radio[0].m_radio_info.intf.mac, radio_mac, sizeof(mac_address_t));
    mesh.m_radio[0].m_radio_info.enabled = true;
    em_bss_info_t& bss = mesh.m_bss[0].m_bss_info;
    bss.id.haul_type = em_haul_type_backhaul;
    bss.vap_mode = em_vap_mode_sta;
    bss.enabled = false;
    memcpy(bss.ruid.mac, radio_mac, sizeof(mac_address_t));
    em_bss_info_t* result = mesh.get_bsta_bss_info();
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_bsta_bss_info_bss_disabled test" << std::endl;
}

/**
 * @brief Verify correct frequency band lookup by operational class
 *
 * This test validates that the dm_easy_mesh_t::get_freq_band_by_op_class API returns the appropriate frequency band for a set of valid operational class inputs. The API is invoked with various op_class values corresponding to 2.4GHz, 5GHz, and 60GHz bands, including the last table entry to ensure boundary correctness.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 218@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                         | Test Data                                           | Expected Result                                                    | Notes       |
 * | :--------------: | --------------------------------------------------------------------------------------------------- | --------------------------------------------------- | ------------------------------------------------------------------ | ----------- |
 * | 01               | Invoke get_freq_band_by_op_class with op_class 81 for a 2.4GHz operating class                      | op_class = 81, expected_band = em_freq_band_24       | API returns em_freq_band_24                                          | Should Pass |
 * | 02               | Invoke get_freq_band_by_op_class with op_class 115 for a 5GHz operating class                       | op_class = 115, expected_band = em_freq_band_5         | API returns em_freq_band_5                                           | Should Pass |
 * | 03               | Invoke get_freq_band_by_op_class with op_class 131 for a 60GHz operating class                      | op_class = 131, expected_band = em_freq_band_60        | API returns em_freq_band_60                                          | Should Pass |
 * | 04               | Invoke get_freq_band_by_op_class with op_class 136 for the last table entry (operating class check) | op_class = 136, expected_band = em_freq_band_60        | API returns em_freq_band_60                                          | Should Pass |
 */
TEST(dm_easy_mesh_t, get_freq_band_by_op_class_all_valid_cases)
{
    const char* testName = "get_freq_band_by_op_class_all_valid_cases";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    struct test_vector_t {
        int op_class;
        em_freq_band_t expected_band;
        const char* description;
    };
    test_vector_t test_vectors[] = {
        { 81,  em_freq_band_24, "2.4GHz operating class" },
        { 115, em_freq_band_5,  "5GHz operating class" },
        { 131, em_freq_band_60, "60GHz operating class" },
        { 136, em_freq_band_60, "Last table entry operating class" }
    };
    for (const auto& tv : test_vectors) {
        std::cout << "Invoking get_freq_band_by_op_class for "
                  << tv.description
                  << " (op_class = " << tv.op_class << ")"
                  << std::endl;
        em_freq_band_t band = mesh.get_freq_band_by_op_class(tv.op_class);
        EXPECT_EQ(band, tv.expected_band);
    }
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test to verify that get_freq_band_by_op_class returns the expected unknown frequency band for an invalid operational class input.
 *
 * This test ensures that when an invalid op_class value (999) is provided to the get_freq_band_by_op_class API, the function correctly returns em_freq_band_unknown. It validates the error handling and robustness of the API with unexpected input.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 219@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                       | Test Data                                        | Expected Result                                               | Notes      |
 * | :--------------: | ----------------------------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------- | ---------- |
 * | 01               | Invoke get_freq_band_by_op_class with an invalid op_class value     | op_class = 999, expected output: em_freq_band_unknown | Function returns em_freq_band_unknown and assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_freq_band_by_op_class_invalid_value)
{
    const char* testName = "get_freq_band_by_op_class_invalid_value";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    int op_class = 999;
    std::cout << "Invoking get_freq_band_by_op_class with invalid op_class: " << op_class << std::endl;
    em_freq_band_t band = mesh.get_freq_band_by_op_class(op_class);
    EXPECT_EQ(band, em_freq_band_unknown);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Ensure get_freq_band_by_op_class handles negative op_class values correctly.
 *
 * This test verifies that when a negative value is provided as the op_class parameter, the
 * get_freq_band_by_op_class method returns em_freq_band_unknown. This behavior ensures that
 * the API handles invalid (negative) input cases appropriately.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 220@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                         | Test Data                                          | Expected Result                                                      | Notes      |
 * | :--------------: | ------------------------------------------------------------------- | -------------------------------------------------- | -------------------------------------------------------------------- | ---------- |
 * | 01               | Invoke get_freq_band_by_op_class with a negative op_class value.      | input: op_class = -1, output: band = em_freq_band_unknown | The API returns em_freq_band_unknown and the assertion EXPECT_EQ passes. | Should Pass |
 */
TEST(dm_easy_mesh_t, get_freq_band_by_op_class_negative_value)
{
    const char* testName = "get_freq_band_by_op_class_negative_value";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    int op_class = -1;
    std::cout << "Invoking get_freq_band_by_op_class with op_class: " << op_class << std::endl;
    em_freq_band_t band = mesh.get_freq_band_by_op_class(op_class);
    EXPECT_EQ(band, em_freq_band_unknown);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate that get_freq_band_by_op_class returns em_freq_band_unknown when op_class is zero.
 *
 * This test verifies that when get_freq_band_by_op_class is invoked with an op_class value of 0, it returns the expected 'em_freq_band_unknown' value. This ensures that the API correctly handles the case for an op_class of zero.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 221@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                          | Test Data                          | Expected Result                                                      | Notes      |
 * | :--------------: | -------------------------------------------------------------------- | ---------------------------------- | -------------------------------------------------------------------- | ---------- |
 * | 01               | Invoke get_freq_band_by_op_class on dm_easy_mesh instance with op_class 0 | input: op_class = 0, output: band expected = em_freq_band_unknown | Returns em_freq_band_unknown; EXPECT_EQ validates the returned value | Should Pass |
 */
TEST(dm_easy_mesh_t, get_freq_band_by_op_class_zero)
{
    const char* testName = "get_freq_band_by_op_class_zero";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    int op_class = 0;
    std::cout << "Invoking get_freq_band_by_op_class with op_class: " << op_class << std::endl;
    em_freq_band_t band = mesh.get_freq_band_by_op_class(op_class);
    EXPECT_EQ(band, em_freq_band_unknown);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validates that get_cmd_ctx() returns a valid pointer and correctly populated data.
 *
 * This test verifies that when a dm_easy_mesh_t object's command context is explicitly populated,
 * the get_cmd_ctx() method returns a non-null pointer with fields matching the expected values.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 222@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                | Test Data                                                       | Expected Result                                                          | Notes              |
 * | :--------------: | ---------------------------------------------------------- | --------------------------------------------------------------- | ------------------------------------------------------------------------ | ------------------ |
 * | 01               | Initialize dm_easy_mesh_t and populate command context     | arr_index = 42, type = dm_orch_type_bss_insert, obj_id = test-object-id | dm_easy_mesh_t object is properly set up with expected context values     | Should be successful |
 * | 02               | Invoke get_cmd_ctx() method                                | Input: mesh object with populated command context               | Returns a valid (non-null) pointer to the command context                 | Should Pass        |
 * | 03               | Verify the command context fields from the returned pointer| Expected: arr_index = 42, type = dm_orch_type_bss_insert, obj_id = test-object-id | The returned command context fields match the expected values             | Should Pass        |
 */
TEST(dm_easy_mesh_t, get_cmd_ctx_valid_pointer_and_data_access)
{
    const char* testName = "get_cmd_ctx_valid_pointer_and_data_access";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    /* Populate command context */
    mesh.m_cmd_ctx.arr_index = 42;
    mesh.m_cmd_ctx.type = dm_orch_type_bss_insert;
    strncpy(mesh.m_cmd_ctx.obj_id, "test-object-id", sizeof(mesh.m_cmd_ctx.obj_id));
    std::cout << "Invoking get_cmd_ctx()" << std::endl;
    em_cmd_ctx_t* ctx = mesh.get_cmd_ctx();
    ASSERT_NE(ctx, nullptr);
    std::cout << "Verifying returned command context fields" << std::endl;
    EXPECT_EQ(ctx->arr_index, 42);
    EXPECT_EQ(ctx->type, dm_orch_type_bss_insert);
    EXPECT_STREQ(ctx->obj_id, "test-object-id");
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that the default instance of dm_easy_mesh_t returns a valid command context
 *
 * This test checks that invoking get_cmd_ctx() on a default constructed dm_easy_mesh_t instance returns a non-null pointer and that the internal context values (arr_index, type, obj_id) are accessible. It is important to ensure that the default instance is properly initialized to support subsequent command operations.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 223@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |@n
 * | :----: | --------- | ---------- |-------------- | ----- |@n
 * | 01 | Instantiate dm_easy_mesh_t using the default constructor and invoke get_cmd_ctx() | dm_easy_mesh_t instance created with default constructor, calling get_cmd_ctx() with no additional arguments | Should return a valid (non-null) pointer to an em_cmd_ctx_t structure | Should Pass |@n
 * | 02 | Assert that the returned context pointer is not null | ASSERT_NE(ctx, nullptr) where ctx is the output from get_cmd_ctx() | The assertion passes confirming that ctx is not nullptr | Should be successful |
 */
TEST(dm_easy_mesh_t, get_cmd_ctx_default_instance)
{
    const char* testName = "get_cmd_ctx_default_instance";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh{};
    std::cout << "Invoking get_cmd_ctx() on default instance" << std::endl;
    em_cmd_ctx_t* ctx = mesh.get_cmd_ctx();
    ASSERT_NE(ctx, nullptr);
    std::cout << "Retrieved values are: " << std::endl;
    std::cout << "ctx->arr_index = " << ctx->arr_index << std::endl;
    std::cout << "ctx->type = " << ctx->type << std::endl;
    std::cout << "ctx->obj_id = " << ctx->obj_id << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verifies that get_colocated() returns true when m_colocated is set to true.
 *
 * This test confirms that when the dm_easy_mesh_t object's m_colocated attribute is set to true, the get_colocated() method correctly returns true. This is a positive scenario to ensure proper behavior of the getter method.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 224@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                           | Test Data                         | Expected Result                                               | Notes            |
 * | :--------------: | --------------------------------------------------------------------- | --------------------------------- | ------------------------------------------------------------- | ---------------- |
 * | 01               | Create dm_easy_mesh_t instance and set m_colocated to true             | m_colocated = true                | Instance attribute is set successfully                        | Should be successful  |
 * | 02               | Invoke get_colocated() method on the instance                          | input: none, output: bool result  | get_colocated() returns true                                    | Should Pass      |
 * | 03               | Verify that the returned value is true using ASSERT_TRUE                | result = true                     | ASSERT_TRUE passes confirming the returned value is true        | Should Pass      |
 */
TEST(dm_easy_mesh_t, get_colocated_returns_true)
{
    std::cout << "Entering get_colocated_returns_true test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_colocated = true;
    std::cout << "Setting m_colocated to true" << std::endl;
    std::cout << "Invoking get_colocated() method" << std::endl;
    bool result = mesh.get_colocated();
    std::cout << "get_colocated() returned: " << std::boolalpha << result << std::endl;
    ASSERT_TRUE(result);    
    std::cout << "Exiting get_colocated_returns_true test" << std::endl;
}

/**
 * @brief Verifies that the get_colocated() method returns its expected default value.
 *
 * This test checks that a default-constructed dm_easy_mesh_t object returns the correct boolean value 
 * when get_colocated() is invoked. It ensures that the object's default state is properly initialized.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 225@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                         | Test Data                                                   | Expected Result                                          | Notes       |
 * | :--------------: | ------------------------------------------------------------------- | ----------------------------------------------------------- | -------------------------------------------------------- | ----------- |
 * | 01               | Instantiate dm_easy_mesh_t and invoke get_colocated() method         | mesh = default constructed, result = output of get_colocated() | Returns default value (expected false) verifying API works | Should Pass |
 */
TEST(dm_easy_mesh_t, get_colocated_default_return)
{
    std::cout << "Entering get_colocated_default_return test" << std::endl;
    dm_easy_mesh_t mesh{};
    std::cout << "Invoking get_colocated() method" << std::endl;
    bool result = mesh.get_colocated();
    std::cout << "get_colocated() returned the default value: " << result << std::endl;
    std::cout << "Exiting get_colocated_default_return test" << std::endl;
}

/**
 * @brief Verify that get_controller_interface returns a valid interface with expected controller details
 *
 * This test populates the controller interface within a dm_easy_mesh_t instance with predefined values and then retrieves it using get_controller_interface(). The retrieved interface is checked to ensure the name, MAC address, and media type match the expected values. This ensures that the API correctly maps internal data structures to the returned interface.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 226@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Populate the dm_easy_mesh_t instance with controller interface details ("ctrl-iface", MAC: 0xAA,0xBB,0xCC,0xDD,0xEE,0xFF, media: em_media_type_ieee80211b_24) | mesh.m_network.m_net_info.ctrl_id.name = "ctrl-iface", mesh.m_network.m_net_info.ctrl_id.mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF}, mesh.m_network.m_net_info.ctrl_id.media = em_media_type_ieee80211b_24 | The internal structure is populated with the expected controller interface details | Should be successful |
 * | 02 | Invoke get_controller_interface() to retrieve the controller interface from the mesh instance | Invocation of mesh.get_controller_interface() | API returns a non-null pointer to an interface structure | Should Pass |
 * | 03 | Validate the retrieved interface attributes (name, MAC, media) | Retrieved interface: name = returned value, mac = returned value, media = returned value | Returned name equals "ctrl-iface", MAC memory comparison succeeds, media equals em_media_type_ieee80211b_24 | Should Pass |
 */
TEST(dm_easy_mesh_t, get_controller_interface_valid)
{
    const char* testName = "get_controller_interface_valid";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    /* Populate controller interface */
    strncpy(mesh.m_network.m_net_info.ctrl_id.name, "ctrl-iface", sizeof(mesh.m_network.m_net_info.ctrl_id.name));
    unsigned char mac[] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    memcpy(mesh.m_network.m_net_info.ctrl_id.mac, mac, sizeof(mac));
    mesh.m_network.m_net_info.ctrl_id.media = em_media_type_ieee80211b_24;
    std::cout << "Invoking get_controller_interface()" << std::endl;
    em_interface_t* iface = mesh.get_controller_interface();
    ASSERT_NE(iface, nullptr);
    EXPECT_STREQ(iface->name, "ctrl-iface");
    EXPECT_EQ(memcmp(iface->mac, mac, sizeof(mac)), 0);
    EXPECT_EQ(iface->media, em_media_type_ieee80211b_24);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_controller_interface returns a valid interface pointer for a default instance.
 *
 * This test case verifies that invoking get_controller_interface() on a default instantiated dm_easy_mesh_t object
 * returns a valid (non-null) pointer. The test ensures that the default configuration correctly sets up the controller interface.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 227@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                         | Test Data                                                  | Expected Result                                                 | Notes      |
 * | :--------------: | ------------------------------------------------------------------- | ---------------------------------------------------------- | --------------------------------------------------------------- | ---------- |
 * | 01               | Create a default dm_easy_mesh_t instance and invoke get_controller_interface() | mesh = default instance, iface = result of get_controller_interface() | iface is not nullptr and assertion passes                      | Should Pass |
 */
TEST(dm_easy_mesh_t, get_controller_interface_default_instance)
{
    const char* testName = "get_controller_interface_default_instance";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh{};
    std::cout << "Invoking get_controller_interface() on default instance" << std::endl;
    em_interface_t* iface = mesh.get_controller_interface();
    ASSERT_NE(iface, nullptr);
    std::cout << "Interface name: " << iface->name << std::endl;
    std::cout << "Interface media type: " << iface->media << std::endl;
    std::cout << "Interface MAC: ";
    for (size_t i = 0; i < sizeof(mac_address_t); ++i) {
        printf("%02X", iface->mac[i]);
        if (i < sizeof(mac_address_t) - 1) printf(":");
    }
    std::cout << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate the correctness of get_controller_interface_mac API.
 *
 * This test verifies that the get_controller_interface_mac method returns a valid pointer to the controller interface MAC address.
 * The test initializes a dm_easy_mesh_t object with a predefined MAC address and then ensures that the API returns a non-null pointer and
 * that the contents of the returned MAC match the expected value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 228@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | ------------- | ----- |
 * | 01 | Instantiate dm_easy_mesh_t and initialize controller MAC address | mesh instance, expected_mac = 0x10,0x20,0x30,0x40,0x50,0x60 | mesh.m_network.m_net_info.ctrl_id.mac equals expected_mac | Should be successful |
 * | 02 | Invoke get_controller_interface_mac API | method = get_controller_interface_mac(), no arguments | Returned pointer is not null | Should Pass |
 * | 03 | Verify the returned MAC against expected_mac | returned mac pointer, expected_mac = 0x10,0x20,0x30,0x40,0x50,0x60 | memcmp returns 0 indicating a match | Should Pass |
 */
TEST(dm_easy_mesh_t, get_controller_interface_mac_valid)
{
    const char* testName = "get_controller_interface_mac_valid";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    unsigned char expected_mac[] = {0x10, 0x20, 0x30, 0x40, 0x50, 0x60};
    memcpy(mesh.m_network.m_net_info.ctrl_id.mac, expected_mac, sizeof(expected_mac));
    std::cout << "Invoking get_controller_interface_mac()" << std::endl;
    unsigned char* mac = mesh.get_controller_interface_mac();
    ASSERT_NE(mac, nullptr);
    EXPECT_EQ(memcmp(mac, expected_mac, sizeof(expected_mac)), 0);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate the default instance behavior for retrieving the controller's MAC address
 *
 * This test case verifies that invoking the get_controller_interface_mac() method on a default
 * instance of dm_easy_mesh_t returns a non-null pointer and prints the valid MAC address in a
 * colon-separated hexadecimal format. This ensures that the default instance is properly initialized
 * and the API behaves as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 229@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                                  | Test Data                                                                                                          | Expected Result                                                        | Notes            |
 * | :--------------: | ------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------- | ---------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and print the entering test message                                         | testName = "get_controller_interface_mac_default_instance", instance creation of dm_easy_mesh_t                    | Mesh instance is successfully created and entering message is printed  | Should be successful |
 * | 02               | Invoke get_controller_interface_mac() on the default dm_easy_mesh_t instance                                    | No explicit input; output: pointer mac from get_controller_interface_mac()                                          | Returned pointer mac is not null                                       | Should Pass      |
 * | 03               | Assert that the returned MAC pointer is valid using ASSERT_NE                                                 | Output from API: mac pointer, ASSERT_NE(mac, nullptr)                                                                | Assertion passes confirming mac pointer is valid                       | Should Pass      |
 * | 04               | Print the Controller MAC address in a colon-separated hexadecimal format                                      | Output: MAC address bytes printed from mac pointer                                                                   | MAC address is printed in the format "%02X:%02X:...:%02X"                | Should be successful |
 */
TEST(dm_easy_mesh_t, get_controller_interface_mac_default_instance)
{
    const char* testName = "get_controller_interface_mac_default_instance";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh{};
    std::cout << "Invoking get_controller_interface_mac() on default instance" << std::endl;
    unsigned char* mac = mesh.get_controller_interface_mac();
    ASSERT_NE(mac, nullptr);
    std::cout << "Controller MAC: ";
    for (size_t i = 0; i < sizeof(mac_address_t); ++i) {
        printf("%02X", mac[i]);
        if (i < sizeof(mac_address_t) - 1) printf(":");
    }
    std::cout << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate that get_ctl_mac() returns a valid pointer from the default dm_easy_mesh_t instance
 *
 * This test creates an instance of dm_easy_mesh_t, invokes the get_ctl_mac() API, and verifies that the returned MAC pointer is not nullptr. The purpose is to ensure that the method properly returns a valid pointer for further MAC address processing.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 230@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | --------------- | ----- |
 * | 01 | Create a dm_easy_mesh_t instance, invoke get_ctl_mac() and verify the returned MAC pointer | mesh instance = default, API call: mac = get_ctl_mac() | The API returns a non-null pointer and the assertion ASSERT_NE(mac, nullptr) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ctl_mac_default_instance)
{
    const char* testName = "get_ctl_mac_default_instance";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh{};
    std::cout << "Invoking get_ctl_mac()" << std::endl;
    unsigned char* mac = mesh.get_ctl_mac();
    ASSERT_NE(mac, nullptr);
    std::cout << "Returned MAC pointer is valid: ";
    printMacAddress(mac);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_ctl_mac() returns the MAC address configured in the device's network information.
 *
 * This test sets an expected MAC address in the device's network configuration and then calls
 * the get_ctl_mac() API to retrieve the MAC address. The test ensures that the returned MAC address
 * matches the pre-configured value. This validation is critical to ensure that the module correctly
 * maintains and retrieves its network configuration.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 231@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                 | Test Data                                                                    | Expected Result                                                      | Notes          |
 * | :--------------: | --------------------------------------------------------------------------- | ---------------------------------------------------------------------------- | --------------------------------------------------------------------- | -------------- |
 * | 01               | Set the expected MAC address in the device's network configuration          | expected_mac = {0x10, 0x11, 0x22, 0x33, 0x44, 0x55}; no output                | The device's MAC address field is updated with the expected value      | Should be successful |
 * | 02               | Invoke get_ctl_mac() API and verify the returned MAC matches the expected MAC | Input: None; Output: mac pointer from get_ctl_mac()                           | API returns a non-null pointer and memcmp confirms the MAC values match | Should Pass    |
 */
TEST(dm_easy_mesh_t, get_ctl_mac_matches_configured_value)
{
    const char* testName = "get_ctl_mac_matches_configured_value";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    unsigned char expected_mac[6] = {0x10, 0x11, 0x22, 0x33, 0x44, 0x55};
    memcpy(mesh.m_network.m_net_info.ctrl_id.mac, expected_mac, 6);
    std::cout << "Invoking get_ctl_mac()" << std::endl;
    unsigned char* mac = mesh.get_ctl_mac();
    ASSERT_NE(mac, nullptr);
    EXPECT_EQ(memcmp(mac, expected_mac, 6), 0);
    std::cout << "Returned MAC matches expected: ";
    printMacAddress(mac);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_ctrl_al_interface() returns a valid control interface instance
 *
 * This test instantiates a dm_easy_mesh_t object and invokes the get_ctrl_al_interface() method.
 * It then checks that the returned interface pointer is not null and logs various interface properties,
 * ensuring that the API returns a valid control interface object as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 232@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                  | Test Data                                                        | Expected Result                                    | Notes         |
 * | :--------------: | -------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | -------------------------------------------------- | ------------- |
 * | 01               | Instantiate dm_easy_mesh_t and invoke get_ctrl_al_interface() method.                        | mesh object created, call: iface = mesh.get_ctrl_al_interface()    | iface is not nullptr                                | Should Pass   |
 * | 02               | Log and verify the interface properties (name, MAC address, and media type).                   | iface->name = actual, iface->mac = actual (6-byte MAC), iface->media = actual | Correct interface property values are printed | Should be successful |
 */
TEST(dm_easy_mesh_t, get_ctrl_al_interface_default_instance)
{
    const char* testName = "get_ctrl_al_interface_default_instance";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh{};
    std::cout << "Invoking get_ctrl_al_interface()" << std::endl;
    em_interface_t* iface = mesh.get_ctrl_al_interface();
    ASSERT_NE(iface, nullptr);
	
    std::cout << "Interface name: " << iface->name << std::endl;
    std::cout << "Interface MAC: ";
    for (int i = 0; i < 6; i++) {
        printf("%02X", iface->mac[i]);
        if (i < 5) printf(":");
    }
    std::cout << "\nMedia type: " << static_cast<int>(iface->media) << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate that the control AL interface is properly configured.
 *
 * This test verifies that when the mesh object is initialized with a specific agent name, MAC address, and media type, 
 * the control AL interface returned by get_ctrl_al_interface() reflects these settings. The test ensures that the API correctly 
 * maps the configured network information to the interface structure, and that the interface pointer returned is not null.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 233@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | --------------- | ----- |
 * | 01 | Set agent name in the mesh's network information | mesh.m_network.m_net_info.colocated_agent_id.name = "ca0" | The agent name is set to "ca0" | Should be successful |
 * | 02 | Set MAC address for the colocated agent | mac = {0x10, 0x11, 0x22, 0x33, 0x44, 0x55}; memcpy(mesh.m_network.m_net_info.colocated_agent_id.mac, mac, 6) | The MAC address in the mesh matches the provided array | Should be successful |
 * | 03 | Set media type for the colocated agent | mesh.m_network.m_net_info.colocated_agent_id.media = em_media_type_ieee80211b_24 | The media type is updated to em_media_type_ieee80211b_24 | Should be successful |
 * | 04 | Retrieve the Control AL Interface | Invocation: em_interface_t* iface = mesh.get_ctrl_al_interface() | Returned interface pointer is not null | Should Pass |
 * | 05 | Validate the interface name | Assertion: EXPECT_STREQ(iface->name, "ca0") | Interface name equals "ca0" | Should Pass |
 * | 06 | Validate the interface MAC address | Assertion: EXPECT_EQ(memcmp(iface->mac, mac, 6), 0) | Interface MAC matches the provided array | Should Pass |
 * | 07 | Validate the interface media type | Assertion: EXPECT_EQ(iface->media, em_media_type_ieee80211b_24) | Interface media type equals em_media_type_ieee80211b_24 | Should Pass |
 * | 08 | Output the interface attributes to console | Printing interface details using std::cout and printf | Console prints the correct interface name, MAC, and media type | Should be successful |
 */
TEST(dm_easy_mesh_t, get_ctrl_al_interface_configured)
{
    dm_easy_mesh_t mesh;
    strcpy(mesh.m_network.m_net_info.colocated_agent_id.name, "ca0");
    unsigned char mac[6] = {0x10, 0x11, 0x22, 0x33, 0x44, 0x55};
    memcpy(mesh.m_network.m_net_info.colocated_agent_id.mac, mac, 6);
    mesh.m_network.m_net_info.colocated_agent_id.media = em_media_type_ieee80211b_24;
    em_interface_t* iface = mesh.get_ctrl_al_interface();
    ASSERT_NE(iface, nullptr);
    EXPECT_STREQ(iface->name, "ca0");
    EXPECT_EQ(memcmp(iface->mac, mac, 6), 0);
    EXPECT_EQ(iface->media, em_media_type_ieee80211b_24);
    std::cout << "Default interface name: " << iface->name << std::endl;
    std::cout << "Default interface MAC: ";
    for(int i = 0; i < 6; i++) {
        printf("%02X", iface->mac[i]);
        if (i < 5) printf(":");
    }
    std::cout << "\nDefault media type: " << static_cast<int>(iface->media) << std::endl;
}

/**
 * @brief Test the retrieval of the control AL interface MAC address configuration.
 *
 * This test verifies that the get_ctrl_al_interface_mac() function returns a valid pointer and the expected MAC address configured in the dm_easy_mesh_t instance. It confirms that the internal MAC configuration is correctly mapped and retrievable.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 234@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data |Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Set a predefined MAC address in the dm_easy_mesh_t instance and invoke get_ctrl_al_interface_mac() | mesh.m_network.m_net_info.colocated_agent_id.mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF} | Function returns a non-null pointer and the returned MAC matches the expected MAC (memcmp returns 0) | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ctrl_al_interface_mac_configured)
{
    const char* testName = "get_ctrl_al_interface_mac_configured";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    unsigned char expected_mac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    memcpy(mesh.m_network.m_net_info.colocated_agent_id.mac, expected_mac, 6);
    std::cout << "Invoking get_ctrl_al_interface_mac()" << std::endl;
    unsigned char* mac = mesh.get_ctrl_al_interface_mac();
    ASSERT_NE(mac, nullptr);
    EXPECT_EQ(memcmp(mac, expected_mac, 6), 0);
    std::cout << "Returned AL MAC: ";
    for (int i = 0; i < 6; i++) {
        printf("%02X", mac[i]);
        if (i < 5) printf(":");
    }
    std::cout << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Tests retrieval of default control AL interface MAC address.
 *
 * This test verifies that the get_ctrl_al_interface_mac() function returns a non-null pointer and that the retrieved MAC address is formatted as expected. It ensures that the API call on an instance of dm_easy_mesh_t processes correctly and returns a valid MAC.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 235@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create an instance of dm_easy_mesh_t and initialize the test name | testName = "get_ctrl_al_interface_mac_default_instance", dm_easy_mesh_t instance created | Instance is created successfully | Should be successful |
 * | 02 | Invoke get_ctrl_al_interface_mac() method and verify the MAC pointer is not null | No input arguments; output: mac pointer expected, assertion check on non-null value | get_ctrl_al_interface_mac() returns a valid non-null MAC pointer | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ctrl_al_interface_mac_default_instance)
{
    const char* testName = "get_ctrl_al_interface_mac_default_instance";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh{};    
    std::cout << "Invoking get_ctrl_al_interface_mac()" << std::endl;
    unsigned char* mac = mesh.get_ctrl_al_interface_mac();
    ASSERT_NE(mac, nullptr);
    std::cout << "Returned default AL MAC: ";
    for (int i = 0; i < 6; i++) {
        printf("%02X", mac[i]);
        if (i < 5) printf(":");
    }
    std::cout << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_ctrl_al_interface_mac() returns a zeroed MAC when the interface MAC is explicitly set to zero.
 *
 * This test initializes the mesh object's interface MAC to a zeroed value and then calls get_ctrl_al_interface_mac() to retrieve
 * the MAC address. The test verifies that the returned pointer is not null and that the returned MAC address is indeed zeroed out.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 236@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                              | Test Data                                                                                                 | Expected Result                                                     | Notes          |
 * | :--------------: | ---------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- | -------------- |
 * | 01               | Initialize mesh object and set the interface MAC to a zeroed value using memset.         | mesh.m_network.m_net_info.colocated_agent_id.mac = [0, 0, 0, 0, 0, 0]                                     | MAC field is successfully set to zero                               | Should be successful |
 * | 02               | Invoke get_ctrl_al_interface_mac() to obtain the control AL interface MAC pointer.         | API call: get_ctrl_al_interface_mac(), mesh instance provided                                              | Return pointer is not null                                            | Should Pass    |
 * | 03               | Compare the returned MAC against a zeroed MAC using memcmp and EXPECT_EQ assertion.        | Input: Returned MAC pointer, Expected: zero MAC (00,00,00,00,00,00)                                         | memcmp returns 0 indicating the MAC is zeroed and assertion passes       | Should Pass    |
 * | 04               | Print the returned MAC in hexadecimal format for verification.                           | Output: MAC printed in hexadecimal format (e.g., "00:00:00:00:00:00")                                        | Printed output matches the zeroed MAC formatting                      | Should be successful |
 */
TEST(dm_easy_mesh_t, get_ctrl_al_interface_mac_zero_mac)
{
    const char* testName = "get_ctrl_al_interface_mac_zero_mac";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    memset(mesh.m_network.m_net_info.colocated_agent_id.mac, 0, 6);
    std::cout << "Invoking get_ctrl_al_interface_mac()" << std::endl;
    unsigned char* mac = mesh.get_ctrl_al_interface_mac();
    ASSERT_NE(mac, nullptr);
    unsigned char zero_mac[6] = {0};
    EXPECT_EQ(memcmp(mac, zero_mac, 6), 0);
    std::cout << "Returned AL MAC is zeroed: ";
    for (int i = 0; i < 6; i++) {
        printf("%02X", mac[i]);
        if (i < 5) printf(":");
    }
    std::cout << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that the get_ctrl_al_interface_name() method returns the correct configured AL interface name
 *
 * This test ensures that when the dm_easy_mesh_t object is configured with the control AL interface name "al0", 
 * the get_ctrl_al_interface_name() method retrieves and returns this name correctly. The test validates that the 
 * returned pointer is not null and compares the returned string to the expected value "al0".
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 237@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data |Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Configure the dm_easy_mesh_t object with AL interface name "al0" and invoke get_ctrl_al_interface_name() | mesh.m_network.m_net_info.colocated_agent_id.name = al0, (expected returned name = al0) | Function returns a non-null pointer and the returned name is "al0" (validated using ASSERT_NE and EXPECT_STREQ) | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ctrl_al_interface_name_configured)
{
    const char* testName = "get_ctrl_al_interface_name_configured";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    strcpy(mesh.m_network.m_net_info.colocated_agent_id.name, "al0");
    std::cout << "Invoking get_ctrl_al_interface_name()" << std::endl;
    char* name = mesh.get_ctrl_al_interface_name();
    ASSERT_NE(name, nullptr);
	std::cout << "Returned AL interface name: " << name << std::endl;
    EXPECT_STREQ(name, "al0");    
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that the default instance of dm_easy_mesh_t returns a valid control AL interface name.
 *
 * This test creates an instance of dm_easy_mesh_t and invokes the get_ctrl_al_interface_name() method.
 * It checks that the returned AL interface name is not nullptr, ensuring that the default instance is correctly initialized.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 238@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                      | Test Data                                                       | Expected Result                                                    | Notes       |
 * | :--------------: | ---------------------------------------------------------------- | --------------------------------------------------------------- | ------------------------------------------------------------------ | ----------- |
 * | 01               | Create a dm_easy_mesh_t instance, invoke get_ctrl_al_interface_name(), and perform a null check on the returned pointer. | instance = default dm_easy_mesh_t, output1 = name (expected non-null) | Return value should be a non-null pointer; ASSERT_NE(name, nullptr) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ctrl_al_interface_name_default_instance)
{
    const char* testName = "get_ctrl_al_interface_name_default_instance";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh{};
    std::cout << "Invoking get_ctrl_al_interface_name()" << std::endl;
    char* name = mesh.get_ctrl_al_interface_name();
    ASSERT_NE(name, nullptr);
	std::cout << "Returned default AL interface name: " << name << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test that get_ctrl_al_interface_name() returns an empty string when the control AL interface name is not set
 *
 * This unit test verifies that when the control AL interface name in the mesh structure is initialized to an empty string,
 * the get_ctrl_al_interface_name() method returns a non-null pointer that points to an empty string.
 * It ensures the API correctly handles cases where the agent name is missing.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 239@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                               | Test Data                                                              | Expected Result                                                 | Notes         |
 * | :--------------: | ----------------------------------------------------------------------------------------- | ---------------------------------------------------------------------- | --------------------------------------------------------------- | ------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and set control AL interface name to an empty string       | mesh.m_network.m_net_info.colocated_agent_id.name[0] = '\0'              | AL interface name is set to empty state                          | Should be successful |
 * | 02               | Invoke get_ctrl_al_interface_name() to retrieve the control AL interface name                | Input: dm_easy_mesh_t instance with empty interface name               | Returns a non-null pointer to a string                             | Should Pass   |
 * | 03               | Verify that the returned string is empty using assertions                                   | Output: name from get_ctrl_al_interface_name()                         | ASSERT_NE confirms name is not null and EXPECT_STREQ confirms it is "" | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_ctrl_al_interface_name_empty)
{
    const char* testName = "get_ctrl_al_interface_name_empty";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_network.m_net_info.colocated_agent_id.name[0] = '\0';
    std::cout << "Invoking get_ctrl_al_interface_name()" << std::endl;
    char* name = mesh.get_ctrl_al_interface_name();
    ASSERT_NE(name, nullptr);
    EXPECT_STREQ(name, "");
    std::cout << "Returned AL interface name is empty string" << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test the default behavior of get_curr_op_class API for a valid index.
 *
 * This test verifies that, when providing the default index (0), the API get_curr_op_class returns a non-null pointer
 * to a valid operational class structure. The test checks that the pointer is not null and prints the op_class details,
 * ensuring that the retrieval and basic data components of the op_class are appropriately set.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 240@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                         | Test Data                                               | Expected Result                                                   | Notes           |
 * | :--------------: | ------------------------------------------------------------------- | ------------------------------------------------------- | ----------------------------------------------------------------- | --------------- |
 * | 01               | Initialize dm_easy_mesh_t object and set index to 0                 | dm_easy_mesh_t instance, index = 0                      | Object is successfully created with a valid default state         | Should be successful |
 * | 02               | Invoke get_curr_op_class API with index 0                           | input: index = 0; output: op pointer                    | API returns a valid (non-null) pointer to dm_op_class_t structure   | Should Pass     |
 * | 03               | Assert that the returned op pointer is not nullptr                  | op pointer                                            | ASSERT_NE(op, nullptr) passes, confirming valid pointer retrieval   | Should Pass     |
 * | 04               | Retrieve and print op_class details from the op pointer               | op->m_op_class_info attributes (op_class, channel, etc.) | Printed op_class details correspond to valid operational class info | Should be successful |
 */
TEST(dm_easy_mesh_t, get_curr_op_class_valid_default)
{
	const char* testName = "get_curr_op_class_valid_default";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh{};
    unsigned int index = 0;
	std::cout << "Invoking get_curr_op_class(0)" << std::endl;
    dm_op_class_t* op = mesh.get_curr_op_class(index);
    ASSERT_NE(op, nullptr);
    std::cout << "Retrieved op_class pointer is valid" << std::endl;
    std::cout << "op_class: " << op->m_op_class_info.op_class << std::endl;
    std::cout << "channel: " << op->m_op_class_info.channel << std::endl;
    std::cout << "tx_power: " << op->m_op_class_info.tx_power << std::endl;
    std::cout << "max_tx_power: " << op->m_op_class_info.max_tx_power << std::endl;
    std::cout << "num_channels: " << op->m_op_class_info.num_channels << std::endl;
    std::cout << "channels: ";
    for(unsigned int i = 0; i < op->m_op_class_info.num_channels; i++)
        std::cout << op->m_op_class_info.channels[i] << " ";
    std::cout << std::endl;
    std::cout << "ruid MAC: ";
    for(int i=0; i<6; i++)
        printf("%02X", op->m_op_class_info.id.ruid[i]);
    std::cout << std::endl;
    std::cout << "type: " << op->m_op_class_info.id.type << std::endl;
	std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_curr_op_class returns a valid pointer for a correctly configured op class entry
 *
 * This test configures a dm_op_class_t entry within a dm_easy_mesh_t object with valid operational parameters and MAC address.
 * It then invokes the API get_curr_op_class to retrieve the configuration and verifies that the returned pointer is non-null.
 * The test ensures that the API correctly retrieves the previously configured op class entry.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 241@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:** 
 * | Variation / Step | Description                                                     | Test Data                                                                                                                                                                                                                                    | Expected Result                                                        | Notes          |
 * | :--------------: | ----------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- | -------------- |
 * | 01               | Configure op class entry directly in the mesh structure           | index = 1, op_class_info: { op_class = 116, channel = 44, tx_power = 20, max_tx_power = 30, num_channels = 3, channels = [36,40,44], mins_since_cac_comp = 5, sec_remain_non_occ_dur = 60, countdown_cac_comp = 100, ruid = {0x10,0x11,0x22,0x33,0x44,0x5E}, type = em_op_class_type_current } | Configuration is stored correctly in the mesh object                   | Should be successful |
 * | 02               | Invoke get_curr_op_class API with the configured index              | input: index = 1; output: pointer to dm_op_class_t                                                                                                                      | Returned pointer is not nullptr and references the configured entry   | Should Pass    |
 * | 03               | Validate printed output values match the configured settings        | output op_class_info values printed from the returned pointer (op_class, channel, tx_power, max_tx_power, num_channels, channels, ruid, type)                                                       | Printed values should match the values set during configuration         | Should Pass    |
 */
TEST(dm_easy_mesh_t, get_curr_op_class_valid_configured)
{
    const char* testName = "get_curr_op_class_valid_configured";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh{};
    unsigned int index = 1;
    /* Configure op class entry directly */
    dm_op_class_t &cfg_op = mesh.m_op_class[index];
    unsigned char mac[] = {0x10, 0x11, 0x22, 0x33, 0x44, 0x5E};
    memcpy(cfg_op.m_op_class_info.id.ruid, mac, sizeof(mac));
    cfg_op.m_op_class_info.id.type = em_op_class_type_current;
    cfg_op.m_op_class_info.id.op_class = 116;
    cfg_op.m_op_class_info.op_class = 116;
    cfg_op.m_op_class_info.channel = 44;
    cfg_op.m_op_class_info.tx_power = 20;
    cfg_op.m_op_class_info.max_tx_power = 30;
    cfg_op.m_op_class_info.num_channels = 3;
    cfg_op.m_op_class_info.channels[0] = 36;
    cfg_op.m_op_class_info.channels[1] = 40;
    cfg_op.m_op_class_info.channels[2] = 44;
    cfg_op.m_op_class_info.mins_since_cac_comp = 5;
    cfg_op.m_op_class_info.sec_remain_non_occ_dur = 60;
    cfg_op.m_op_class_info.countdown_cac_comp = 100;
    std::cout << "Invoking get_curr_op_class(" << index << ")" << std::endl;
    /* Retrieve via API */
    dm_op_class_t *ret_op = mesh.get_curr_op_class(index);
    ASSERT_NE(ret_op, nullptr);
    std::cout << "Retrieved op_class pointer is valid" << std::endl;
    /* Print retrieved values */
    std::cout << "op_class: " << ret_op->m_op_class_info.op_class << std::endl;
    std::cout << "channel: " << ret_op->m_op_class_info.channel << std::endl;
    std::cout << "tx_power: " << ret_op->m_op_class_info.tx_power << std::endl;
    std::cout << "max_tx_power: " << ret_op->m_op_class_info.max_tx_power << std::endl;
    std::cout << "num_channels: " << ret_op->m_op_class_info.num_channels << std::endl;
    std::cout << "channels: ";
    for (unsigned int i = 0; i < ret_op->m_op_class_info.num_channels; i++)
        std::cout << ret_op->m_op_class_info.channels[i] << " ";
    std::cout << std::endl;
    std::cout << "ruid MAC: ";
    for (int i = 0; i < 6; i++)
        printf("%02X", ret_op->m_op_class_info.id.ruid[i]);
    std::cout << std::endl;
    std::cout << "type: " << ret_op->m_op_class_info.id.type << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validates that get_curr_op_class returns a null pointer for an invalid index.
 *
 * This test case validates that when an out-of-bound index (greater than EM_MAX_OPCLASS) is provided to the get_curr_op_class API, the function returns nullptr. The test ensures that the get_curr_op_class method properly handles invalid index inputs and does not return a valid pointer.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 242@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                          | Test Data: input/output values                                     | Expected Result: return value / assertion check                           | Notes           |
 * | :--------------: | ---------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ | -------------------------------------------------------------------------- | --------------- |
 * | 01               | Initialize test environment by creating an instance of dm_easy_mesh_t and defining an invalid index  | testName = "get_curr_op_class_invalid_index", index = EM_MAX_OPCLASS + 1 | Instance created and invalid index is assigned correctly                   | Should be successful |
 * | 02               | Invoke get_curr_op_class API with the invalid index                                                   | input: index = EM_MAX_OPCLASS + 1, output: op pointer                 | API returns a nullptr and ASSERT_EQ(op, nullptr) passes                        | Should Pass     |
 * | 03               | Log the exiting message from the test                                                                 | Console output message with testName                                | Successful exit message printed                                            | Should be successful |
 */
TEST(dm_easy_mesh_t, get_curr_op_class_invalid_index)
{
	const char* testName = "get_curr_op_class_invalid_index";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    unsigned int index = EM_MAX_OPCLASS + 1; // Out of bounds
	std::cout << "Invoking get_curr_op_class(EM_MAX_OPCLASS)" << std::endl;
    dm_op_class_t* op = mesh.get_curr_op_class(index);
    ASSERT_EQ(op, nullptr);
	std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_device() returns a valid device pointer from a default dm_easy_mesh_t instance
 *
 * This test verifies that a default instance of dm_easy_mesh_t returns a valid, non-null device pointer when get_device() is invoked. It also prints the device information associated with the device to confirm that the default values are set properly.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 243@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                                                                      | Expected Result                                                    | Notes               |
 * | :--------------: | --------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- | ------------------- |
 * | 01               | Log an entry message indicating the start of the test                                         | testName = "get_device_default"                                                                | "Entering get_device_default" message printed to console            | Should be successful |
 * | 02               | Create a default instance of dm_easy_mesh_t                                                   | No input arguments (default constructor call)                                                  | dm_easy_mesh_t object instantiated successfully                     | Should be successful |
 * | 03               | Invoke the get_device() method on the default instance                                          | mesh instance; calling get_device()                                                            | Returns a non-null device pointer                                  | Should Pass         |
 * | 04               | Assert that the returned device pointer is not null                                            | device pointer obtained from get_device()                                                      | ASSERT_NE(device, nullptr) assertion passes                         | Should Pass         |
 * | 05               | Print the device information (profile, manufacturer, serial_number, manufacturer_model, software_ver) | device->m_device_info fields with default values                                               | Correct device details printed to the console                       | Should be successful |
 * | 06               | Log an exit message indicating the end of the test                                             | testName = "get_device_default"                                                                | "Exiting get_device_default" message printed to console               | Should be successful |
 */
TEST(dm_easy_mesh_t, get_device_default)
{
    const char* testName = "get_device_default";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh{};
    std::cout << "Invoking get_device() on default instance" << std::endl;
    dm_device_t* device = mesh.get_device();
    ASSERT_NE(device, nullptr);
    std::cout << "Device pointer is valid" << std::endl;
    em_device_info_t &info = device->m_device_info;
    std::cout << "profile: " << static_cast<int>(info.profile) << std::endl;
    std::cout << "manufacturer: " << info.manufacturer << std::endl;
    std::cout << "serial_number: " << info.serial_number << std::endl;
    std::cout << "manufacturer_model: " << info.manufacturer_model << std::endl;
    std::cout << "software_ver: " << info.software_ver << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate that get_device() returns a valid device pointer when the device is configured
 *
 * This test verifies that after configuring a dm_easy_mesh_t instance, the get_device() API returns a non-null pointer indicating that the device has been properly configured. The test checks that all device information fields are accessible and printed.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 244@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Configure the mesh device instance using configure_device() | mesh instance before configuration, output: configured device instance | Device is configured successfully | Should Pass |
 * | 02 | Invoke get_device() on the configured mesh instance | mesh (configured) as input; output: device pointer | Device pointer is non-null | Should Pass |
 * | 03 | Validate device information fields by printing values | device->m_device_info fields: profile, manufacturer, serial_number, manufacturer_model, software_ver | Printed values should reflect valid device configuration | Should Pass |
 */
TEST(dm_easy_mesh_t, get_device_configured)
{
    const char* testName = "get_device_configured";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    configure_device(mesh);
    std::cout << "Invoking get_device() on configured instance" << std::endl;
    dm_device_t* device = mesh.get_device();
    ASSERT_NE(device, nullptr);
    std::cout << "Device pointer is valid (configured)" << std::endl;
    em_device_info_t &info = device->m_device_info;
    std::cout << "profile: " << static_cast<int>(info.profile) << std::endl;
    std::cout << "manufacturer: " << info.manufacturer << std::endl;
    std::cout << "serial_number: " << info.serial_number << std::endl;
    std::cout << "manufacturer_model: " << info.manufacturer_model << std::endl;
    std::cout << "software_ver: " << info.software_ver << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate the default behavior of get_device_by_ref() API
 *
 * This test verifies that when a dm_easy_mesh_t instance is created with default settings, 
 * invoking the get_device_by_ref() method returns a valid device reference, and the associated 
 * device information (em_device_info_t) is accessible. The test prints various device fields to 
 * the console to ensure that the data structure is properly initialized.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 245@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                     | Test Data                                                                                  | Expected Result                                                                | Notes            |
 * | :--------------: | ------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------ | ---------------- |
 * | 01               | Initialize a dm_easy_mesh_t instance with default values                        | dm_easy_mesh_t instance created with default constructor                                   | Instance is successfully created                                               | Should be successful |
 * | 02               | Invoke get_device_by_ref() to retrieve a reference to the device                  | input: mesh instance default; output: valid dm_device_t reference                            | Returns a valid device reference                                               | Should Pass      |
 * | 03               | Access and print device information (dm_device_t and its em_device_info_t fields) | input: device reference from get_device_by_ref(); output: printed device info details          | Device info fields are accessible and printed correctly                        | Should be successful |
 */
TEST(dm_easy_mesh_t, get_device_by_ref_default)
{
    const char* testName = "get_device_by_ref_default";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh{};
    std::cout << "Invoking get_device_by_ref() on default instance" << std::endl;
    dm_device_t &device = mesh.get_device_by_ref();
    std::cout << "Device reference is valid" << std::endl;
    em_device_info_t &info = device.m_device_info;
    std::cout << "info->id: ";
	std::cout << "info->id.dev_mac: ";
    for (size_t i = 0; i < sizeof(info.id.dev_mac); ++i) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(info.id.dev_mac[i]) << " ";
    }
    std::cout << std::endl;
    std::cout << std::endl;
    std::cout << "profile: " << static_cast<int>(info.profile) << std::endl;
    std::cout << "manufacturer: " << info.manufacturer << std::endl;
    std::cout << "serial_number: " << info.serial_number << std::endl;
    std::cout << "manufacturer_model: " << info.manufacturer_model << std::endl;
    std::cout << "software_ver: " << info.software_ver << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate retrieval of a configured device reference from a mesh instance
 *
 * This test verifies that the get_device_by_ref() method returns a valid device reference from a configured dm_easy_mesh_t instance.
 * It configures the mesh device using configure_device, then retrieves the device reference to ensure that the device's MAC address and other properties are correctly accessible.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 246@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                               | Test Data                                                              | Expected Result                                                      | Notes              |@n
 * | :--------------: | ------------------------------------------------------------------------- | ---------------------------------------------------------------------- | -------------------------------------------------------------------- | ------------------ |@n
 * | 01               | Create a dm_easy_mesh_t instance and configure it using configure_device    | mesh instance (unconfigured)                                           | Mesh instance is configured successfully                             | Should Pass        |@n
 * | 02               | Invoke get_device_by_ref() on the configured instance                     | Input: Configured mesh instance; Output: device reference from method    | Valid device reference is returned with proper device information      | Should Pass        |@n
 * | 03               | Print device details including MAC address, profile, manufacturer, etc.   | Device info fields: dev_mac, profile, manufacturer, serial_number, manufacturer_model, software_ver | Correct device details are printed to the console                        | Should be successful |
 */
TEST(dm_easy_mesh_t, get_device_by_ref_configured)
{
    const char* testName = "get_device_by_ref_configured";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t mesh;
    configure_device(mesh);
    std::cout << "Invoking get_device_by_ref() on configured instance" << std::endl;
    dm_device_t &device = mesh.get_device_by_ref();
    std::cout << "Device reference is valid (configured)" << std::endl;
    em_device_info_t &info = device.m_device_info;
    // Print the MAC address instead of non-existent ruid
    std::cout << "info->id.dev_mac: ";
    for (size_t i = 0; i < sizeof(info.id.dev_mac); ++i) {
        std::cout << std::hex << std::setw(2) << std::setfill('0')
                  << static_cast<int>(info.id.dev_mac[i]) << " ";
    }
    std::cout << std::endl;
    std::cout << "profile: " << static_cast<int>(info.profile) << std::endl;
    std::cout << "manufacturer: " << info.manufacturer << std::endl;
    std::cout << "serial_number: " << info.serial_number << std::endl;
    std::cout << "manufacturer_model: " << info.manufacturer_model << std::endl;
    std::cout << "software_ver: " << info.software_ver << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verifies that the get_device_info() method returns a valid, non-null device info pointer.
 *
 * This test case instantiates a dm_easy_mesh_t object and invokes its get_device_info() method.
 * It verifies that the returned pointer is not null and logs the device information including manufacturer,
 * serial number, model, and software version to the console. This ensures that the API correctly retrieves device information
 * in its default instance configuration.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 247@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**  
 * | Variation / Step | Description                                                              | Test Data                                                       | Expected Result                                    | Notes              |
 * | :--------------: | ------------------------------------------------------------------------ | --------------------------------------------------------------- | -------------------------------------------------- | ------------------ |
 * | 01               | Instantiate dm_easy_mesh_t and log entry information                     | Object creation: dm_easy_mesh_t dm{}                             | Instance is created successfully                   | Should be successful |
 * | 02               | Invoke get_device_info() on the dm_easy_mesh_t instance and verify output   | Invocation: dm.get_device_info(), Output: device_info pointer     | device_info pointer is not nullptr (ASSERT_NE check)| Should Pass       |
 * | 03               | Log device information (manufacturer, serial number, model, software version) | Output parameters: manufacturer, serial_number, manufacturer_model, software_ver from device_info | Device information is printed correctly             | Should be successful |
 * | 04               | Log exit information indicating the end of the test                      | N/A                                                              | Exit log message is printed                        | Should be successful |
 */
TEST(dm_easy_mesh_t, get_device_info_instance_default) {
    std::cout << "Entering get_device_info_instance_default test" << std::endl;
    dm_easy_mesh_t dm{};
    std::cout << "Invoking instance method get_device_info()" << std::endl;
    em_device_info_t* device_info = dm.get_device_info();    
    ASSERT_NE(device_info, nullptr);      
    std::cout << "Device Manufacturer: " << device_info->manufacturer << std::endl;
    std::cout << "Device Serial Number: " << device_info->serial_number << std::endl;
    std::cout << "Device Model: " << device_info->manufacturer_model << std::endl;
    std::cout << "Software Version: " << device_info->software_ver << std::endl;   
    std::cout << "Exiting get_device_info_instance_default test" << std::endl;
}

/**
 * @brief Verify that get_device_info() method returns the correct device information configured in the dm_easy_mesh_t instance
 *
 * This test sets specific device information values (manufacturer, software version, serial number, and manufacturer model) 
 * in a dm_easy_mesh_t instance. It then retrieves the device information using get_device_info() and asserts that the returned 
 * data matches the configured values. This ensures that the API correctly reflects the internal state of the device.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 248@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                               | Test Data                                                                                                            | Expected Result                                                       | Notes            |
 * | :--------------: | ----------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- | ---------------- |
 * | 01               | Configure the dm instance with device information using memcpy calls                      | manufacturer = TestManufacturer, software_ver = 1.0.0, serial_number = 123456789, manufacturer_model = Model123       | Device info fields are populated with the configured values           | Should be successful |
 * | 02               | Call get_device_info() method to retrieve the device information from the configured instance | No input; output pointer = device_info                                                                               | Returned pointer should not be nullptr                                | Should Pass      |
 * | 03               | Validate the retrieved device information fields using EXPECT_STREQ assertions               | manufacturer expected = TestManufacturer, software_ver expected = 1.0.0, serial_number expected = 123456789, manufacturer_model expected = Model123 | EXPECT_STREQ assertions pass confirming all data fields match           | Should Pass      |
 */
TEST(dm_easy_mesh_t, get_device_info_instance_configured) {
    std::cout << "Entering get_device_info_instance_configured test" << std::endl;
    dm_easy_mesh_t dm;
	//configure the values
	memcpy(dm.m_device.m_device_info.manufacturer, "TestManufacturer", strlen("TestManufacturer") + 1);
    memcpy(dm.m_device.m_device_info.software_ver, "1.0.0", strlen("1.0.0") + 1);
    memcpy(dm.m_device.m_device_info.serial_number, "123456789", strlen("123456789") + 1);
	memcpy(dm.m_device.m_device_info.manufacturer_model, "Model123", strlen("Model123") + 1);	
    std::cout << "Invoking instance method get_device_info() with configured values" << std::endl;
    em_device_info_t* device_info = dm.get_device_info();    
    ASSERT_NE(device_info, nullptr);      
    std::cout << "Device Manufacturer: " << device_info->manufacturer << std::endl;
    std::cout << "Device Serial Number: " << device_info->serial_number << std::endl;
    std::cout << "Device Model: " << device_info->manufacturer_model << std::endl;
    std::cout << "Software Version: " << device_info->software_ver << std::endl;
	EXPECT_STREQ(device_info->manufacturer, "TestManufacturer");
    EXPECT_STREQ(device_info->serial_number, "123456789");
    EXPECT_STREQ(device_info->manufacturer_model, "Model123");
    EXPECT_STREQ(device_info->software_ver, "1.0.0");
    std::cout << "Exiting get_device_info_instance_configured test" << std::endl;
}

/**
 * @brief Verify that get_device_info() returns valid device information for a default instance of dm_easy_mesh_t
 *
 * This test validates that invoking the static method get_device_info() on a default instance of dm_easy_mesh_t returns a non-null pointer. It also prints the device information details to the console to confirm that each field is accessible.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 249@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                       | Test Data                                                                          | Expected Result                              | Notes         |
 * | :--------------: | ----------------------------------------------------------------- | ---------------------------------------------------------------------------------- | -------------------------------------------- | ------------- |
 * | 01               | Create a default instance of dm_easy_mesh_t                       | dm instance created with default constructor                                       | Instance is successfully created             | Should be successful |
 * | 02               | Invoke dm_easy_mesh_t::get_device_info() with the default instance  | input: pointer to dm = &dm, output: device_info pointer                              | device_info is not nullptr                    | Should Pass   |
 * | 03               | Print device information details to the console                   | output fields: manufacturer, serial_number, manufacturer_model, software_ver values   | Device information details are displayed      | Should be successful |
 */
TEST(dm_easy_mesh_t, get_device_info_1_instance_default) {
    std::cout << "Entering get_device_info_1_instance_default test" << std::endl;
    dm_easy_mesh_t dm{};
    std::cout << "Invoking static get_device_info() on default instance" << std::endl;
    em_device_info_t* device_info = dm_easy_mesh_t::get_device_info(&dm);    
    ASSERT_NE(device_info, nullptr);
    std::cout << "Device Manufacturer: " << device_info->manufacturer << std::endl;
    std::cout << "Device Serial Number: " << device_info->serial_number << std::endl;
    std::cout << "Device Model: " << device_info->manufacturer_model << std::endl;
    std::cout << "Software Version: " << device_info->software_ver << std::endl;
    std::cout << "Exiting get_device_info_1_instance_default test" << std::endl;
}

/**
 * @brief Validate that get_device_info() returns correct device information for a configured instance
 *
 * This test verifies that when a dm_easy_mesh_t object is configured with specific device information, the static
 * method get_device_info() returns a non-null pointer to an em_device_info_t structure containing the expected values.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 250@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                                                                           | Expected Result                                                             | Notes         |
 * | :--------------: | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- | ------------- |
 * | 01               | Set up dm_easy_mesh_t instance and configure device information with values    | manufacturer = TestManufacturer, software_ver = 1.0.0, serial_number = 123456789, manufacturer_model = Model123 | dm.m_device.m_device_info configured with the provided values                | Should be successful |
 * | 02               | Invoke the static get_device_info() API using the configured dm instance       | input: pointer to dm_easy_mesh_t instance                                                                            | Function returns a non-null pointer                                          | Should Pass   |
 * | 03               | Validate the returned device information against the configured values         | output: device_info->manufacturer, device_info->serial_number, device_info->manufacturer_model, device_info->software_ver; expected: TestManufacturer, 123456789, Model123, 1.0.0 | All fields in the returned device_info match the configured values           | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_device_info_1_instance_configured) {
    std::cout << "Entering get_device_info_1_instance_configured test" << std::endl;
    dm_easy_mesh_t dm;
    // Configure the values
    memcpy(dm.m_device.m_device_info.manufacturer, "TestManufacturer", strlen("TestManufacturer") + 1);
    memcpy(dm.m_device.m_device_info.software_ver, "1.0.0", strlen("1.0.0") + 1);
    memcpy(dm.m_device.m_device_info.serial_number, "123456789", strlen("123456789") + 1);
    memcpy(dm.m_device.m_device_info.manufacturer_model, "Model123", strlen("Model123") + 1);
    std::cout << "Invoking static get_device_info() with configured values" << std::endl;
    em_device_info_t* device_info = dm_easy_mesh_t::get_device_info(&dm);    
    ASSERT_NE(device_info, nullptr);
    std::cout << "Device Manufacturer: " << device_info->manufacturer << std::endl;
    std::cout << "Device Serial Number: " << device_info->serial_number << std::endl;
    std::cout << "Device Model: " << device_info->manufacturer_model << std::endl;
    std::cout << "Software Version: " << device_info->software_ver << std::endl;
    EXPECT_STREQ(device_info->manufacturer, "TestManufacturer");
    EXPECT_STREQ(device_info->serial_number, "123456789");
    EXPECT_STREQ(device_info->manufacturer_model, "Model123");
    EXPECT_STREQ(device_info->software_ver, "1.0.0");
    std::cout << "Exiting get_device_info_1_instance_configured test" << std::endl;
}

/**
 * @brief Test to ensure get_device_info returns nullptr when provided a null device manager pointer
 *
 * This test verifies that when the get_device_info API is called with a nullptr as the device manager,
 * it correctly returns a nullptr. The objectives of this test are to check the robustness of the API in handling
 * null inputs and to ensure that no invalid memory access occurs.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 251@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                               | Test Data                                           | Expected Result                                             | Notes            |
 * | :---------------:| ------------------------------------------------------------------------- | --------------------------------------------------- | ------------------------------------------------------------| -----------------|
 * | 01               | Log the beginning of the test                                             | None                                                | Entering test message printed                               | Should be successful |
 * | 02               | Invoke get_device_info with a nullptr for the device manager pointer        | dm = nullptr                                        | API returns a nullptr                                         | Should Pass      |
 * | 03               | Assert that the retrieved device_info is nullptr using EXPECT_EQ            | API invocation: get_device_info(nullptr)            | Assertion passes confirming that deviceInfo is nullptr       | Should Pass      |
 * | 04               | Log the output based on the null check of device_info                       | Based on returned deviceInfo                        | Correct log message printed based on device_info validation   | Should be successful |
 * | 05               | Log the exiting of the test                                               | None                                                | Exiting test message printed                                  | Should be successful |
 */
TEST(dm_easy_mesh_t, get_device_info_null_dm_returns_nullptr) {
    std::cout << "Entering get_device_info_null_dm_returns_nullptr test" << std::endl;
    std::cout << "Invoking get_device_info with dm pointer: nullptr" << std::endl;
    em_device_info_t* deviceInfo = dm_easy_mesh_t::get_device_info(nullptr);
    EXPECT_EQ(deviceInfo, nullptr);    
    if (deviceInfo == nullptr) {
        std::cout << "Retrieved device_info is nullptr as expected" << std::endl;
    } else {
        std::cout << "Unexpected non-null device_info retrieved" << std::endl;
    }   
    std::cout << "Exiting get_device_info_null_dm_returns_nullptr test" << std::endl;
}

/**
 * @brief Verify that get_dpp() returns a valid pointer for a default dm_easy_mesh_t instance
 *
 * This test creates a default instance of dm_easy_mesh_t, invokes the get_dpp() method, and validates that the returned pointer is not null. It confirms that the default instance correctly initializes its DPP data structure.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 252@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                 | Test Data                                                          | Expected Result                                                                  | Notes       |
 * | :--------------: | --------------------------------------------------------------------------- | ------------------------------------------------------------------ | -------------------------------------------------------------------------------- | ----------- |
 * | 01               | Create a default instance of dm_easy_mesh_t and invoke the get_dpp() method  | dm_easy_mesh_t instance (default constructor), no parameters         | get_dpp() should return a valid (non-null) pointer and pass the ASSERT_NE check   | Should Pass |
 */
TEST(dm_easy_mesh_t, get_dpp_default_instance)
{
    const char* testName = "get_dpp_default_instance";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm{};
    std::cout << "Invoking get_dpp() on default instance" << std::endl;
    dm_dpp_t* dpp = dm.get_dpp();
    ASSERT_NE(dpp, nullptr);
    std::cout << "DPP pointer is valid" << std::endl;
    print_dpp_info(dpp->m_dpp_info);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_dpp() returns the correctly configured DPP instance
 *
 * This test verifies that the get_dpp() method of dm_easy_mesh_t returns a non-null pointer to a dm_dpp_t instance whose DPP configuration values (version, frequency channels, MAC address, and session type) correctly reflect the values that were set prior to the call. It ensures that the DPP configuration is stored and retrieved reliably.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 253@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t instance and configure DPP parameters | version=2, ec_freqs[0]=2412, ec_freqs[1]=2437, ec_freqs[2]=2462, ec_freqs[3]=5180, mac_addr=00:11:22:33:44:55, type=ec_session_type_recfg | Instance is configured with the specified DPP values | Should be successful |
 * | 02 | Invoke get_dpp() method and verify that the returned pointer is not nullptr | Call: dm.get_dpp() | Non-null pointer is returned | Should Pass |
 * | 03 | Validate that the returned instance's DPP configuration values match the configured values | version=2, ec_freqs[0]=2412, ec_freqs[3]=5180, mac_addr=00:11:22:33:44:55, type=ec_session_type_recfg | All configuration values match the expected values | Should Pass |
 */
TEST(dm_easy_mesh_t, get_dpp_configured_instance)
{
    const char* testName = "get_dpp_configured_instance";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm{};
    // Configure DPP values
    dm.m_dpp.m_dpp_info.version = 2;
    dm.m_dpp.m_dpp_info.ec_freqs[0] = 2412;
    dm.m_dpp.m_dpp_info.ec_freqs[1] = 2437;
    dm.m_dpp.m_dpp_info.ec_freqs[2] = 2462;
    dm.m_dpp.m_dpp_info.ec_freqs[3] = 5180;
    unsigned char mac[6] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
    memcpy(dm.m_dpp.m_dpp_info.mac_addr, mac, sizeof(mac));
    dm.m_dpp.m_dpp_info.type = ec_session_type_recfg;
    std::cout << "Invoking get_dpp() with configured values" << std::endl;
    dm_dpp_t* dpp = dm.get_dpp();
    ASSERT_NE(dpp, nullptr);
    print_dpp_info(dpp->m_dpp_info);
    // Assertions
    EXPECT_EQ(dpp->m_dpp_info.version, 2u);
    EXPECT_EQ(dpp->m_dpp_info.ec_freqs[0], 2412u);
    EXPECT_EQ(dpp->m_dpp_info.ec_freqs[3], 5180u);
    EXPECT_EQ(dpp->m_dpp_info.type, ec_session_type_recfg);
    EXPECT_EQ(memcmp(dpp->m_dpp_info.mac_addr, mac, sizeof(mac)), 0);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_first_sta returns the expected station info when STA is present.
 *
 * This test adds a station (STA) to the consolidated station map using put_sta_info and then invokes get_first_sta to verify that
 * the correct station is returned. The test validates that the returned pointer is not null and that the station's ID matches the
 * expected MAC address.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 254@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object and call init() | None | dm object is created and initialized successfully | Should be successful |
 * | 02 | Set up MAC addresses and populate em_sta_info_t structure | sta_mac = 00:11:22:33:44:55, bssid = 10:20:30:40:50:60, radio = AA:BB:CC:DD:EE:FF | em_sta_info_t structure is correctly populated with given MAC addresses | Should be successful |
 * | 03 | Add STA info to consolidated station map using put_sta_info() | input: sta_info pointer, em_target_sta_map_consolidated | STA is added to the consolidated STA map without errors | Should Pass |
 * | 04 | Invoke get_first_sta() with sta_mac | input: sta_mac = 00:11:22:33:44:55 | Function returns a valid pointer to the STA (not nullptr) | Should Pass |
 * | 05 | Validate station information using memcmp on STA id | input: sta->m_sta_info.id, expected sta_mac = 00:11:22:33:44:55 | memcmp returns 0 confirming the IDs match | Should Pass |
 */
TEST(dm_easy_mesh_t, get_first_sta_found)
{
    const char* testName = "get_first_sta_found";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_sta_info_t sta_info{};
    mac_address_t sta_mac = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
    mac_address_t bssid   = {0x10, 0x20, 0x30, 0x40, 0x50, 0x60};
    mac_address_t radio   = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    memcpy(sta_info.id, sta_mac, sizeof(mac_address_t));
    memcpy(sta_info.bssid, bssid, sizeof(mac_address_t));
    memcpy(sta_info.radiomac, radio, sizeof(mac_address_t));
    std::cout << "Adding STA to consolidated STA map" << std::endl;
    dm.put_sta_info(&sta_info, em_target_sta_map_consolidated);
    std::cout << "Invoking get_first_sta()" << std::endl;
    dm_sta_t* sta = dm.get_first_sta(sta_mac);
    ASSERT_NE(sta, nullptr);
    std::cout << "STA found successfully" << std::endl;
    print_sta_info(sta);
    EXPECT_EQ(memcmp(sta->m_sta_info.id, sta_mac, sizeof(mac_address_t)), 0);
    dm.deinit();
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_first_sta returns nullptr when the STA map is empty
 *
 * This test ensures that when invoking get_first_sta() on an empty STA map, the function correctly returns a nullptr, confirming proper handling of queries for non-existent STA entries.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 255@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                              | Test Data                                                  | Expected Result                                             | Notes          |
 * | :--------------: | -------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ----------------------------------------------------------- | -------------- |
 * | 01               | Create an instance of dm_easy_mesh_t and initialize it by calling init()                                  | N/A                                                        | Object should be initialized successfully                   | Should be successful |
 * | 02               | Invoke get_first_sta() on the empty STA map with the provided mac address and verify the return value      | sta_mac = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55}              | Return value should be nullptr and assertion check should pass | Should Pass    |
 */
TEST(dm_easy_mesh_t, get_first_sta_empty_map)
{
    const char* testName = "get_first_sta_empty_map";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    mac_address_t sta_mac = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
    std::cout << "Invoking get_first_sta() on empty STA map" << std::endl;
    dm_sta_t* sta = dm.get_first_sta(sta_mac);
    EXPECT_EQ(sta, nullptr);
    std::cout << "STA not found as expected (empty map)" << std::endl;
    dm.deinit();
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test get_first_sta() returns nullptr when queried with a non-existing MAC
 *
 * This test verifies that the API get_first_sta() returns a null pointer when invoked with a MAC address that does not match any stored station information in the dm_easy_mesh_t object. It ensures that the module correctly handles cases where the requested station is not present.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 256@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                                                                  | Expected Result                                          | Notes          |
 * | :--------------: | --------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | -------------------------------------------------------- | -------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and call init()                         | dm_easy_mesh_t instance created; method: init()                                                            | dm object is successfully initialized                   | Should be successful |
 * | 02               | Set up station information with a stored MAC value and insert it via put_sta_info() | sta_info.id = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF}, target = em_target_sta_map_consolidated                          | Station info inserted into the map successfully          | Should Pass    |
 * | 03               | Invoke get_first_sta() with a query MAC that does not match any stored station | query_mac = {0x11,0x22,0x33,0x44,0x55,0x66}                                                                   | Return value is nullptr, indicating station not found    | Should Pass    |
 * | 04               | Validate that the API response (nullptr) matches the expected result         | output: sta pointer return value = nullptr                                                                  | Assertion passes confirming that no matching station found | Should Pass    |
 */
TEST(dm_easy_mesh_t, get_first_sta_mac_not_found)
{
    const char* testName = "get_first_sta_mac_not_found";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_sta_info_t sta_info{};
    mac_address_t stored_mac = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    mac_address_t query_mac  = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
    memcpy(sta_info.id, stored_mac, sizeof(mac_address_t));
    dm.put_sta_info(&sta_info, em_target_sta_map_consolidated);
    std::cout << "Invoking get_first_sta() with non-existing MAC" << std::endl;
    dm_sta_t* sta = dm.get_first_sta(query_mac);
    EXPECT_EQ(sta, nullptr);
    dm.deinit();
    std::cout << "STA not found as expected (MAC mismatch)" << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test to verify that get_first_sta() returns nullptr when the station is only present in the association map.
 *
 * This test verifies that when a station (STA) is added only to the association map (and not to the main STA list), 
 * the get_first_sta() API correctly returns a nullptr indicating that the STA is not present in the primary search map.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 257@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                       | Test Data                                                                              | Expected Result                                            | Notes         |
 * | :--------------: | ----------------------------------------------------------------- | -------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ------------- |
 * | 01               | Initialize dm_easy_mesh_t object and call init()                    | dm_easy_mesh_t instance                                                                | dm_easy_mesh_t initialized successfully                  | Should be successful |
 * | 02               | Create STA info with MAC address and add it to the association map  | sta_info.id = {0x01,0x02,0x03,0x04,0x05,0x06}, target = em_target_sta_map_assoc            | STA info added to association map successfully             | Should Pass   |
 * | 03               | Invoke get_first_sta() with the given MAC address                   | input: sta_mac = {0x01,0x02,0x03,0x04,0x05,0x06}                                         | API returns nullptr since STA is only in assoc map         | Should Fail   |
 * | 04               | Verify that the returned STA pointer is nullptr                     | output: sta pointer expected = nullptr                                                 | Assertion passes confirming STA is not found               | Should be successful |
 */
TEST(dm_easy_mesh_t, get_first_sta_present_only_in_assoc_map)
{
    const char* testName = "get_first_sta_present_only_in_assoc_map";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_sta_info_t sta_info{};
    mac_address_t sta_mac = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06};
    memcpy(sta_info.id, sta_mac, sizeof(mac_address_t));
    std::cout << "Adding STA only to ASSOC map" << std::endl;
    dm.put_sta_info(&sta_info, em_target_sta_map_assoc);
    std::cout << "Invoking get_first_sta()" << std::endl;
    dm_sta_t* sta = dm.get_first_sta(sta_mac);
    EXPECT_EQ(sta, nullptr);
    std::cout << "STA correctly not found (assoc map ignored)" << std::endl;
    dm.deinit();
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Tests the positive flow for retrieving the first station info from the consolidated map.
 *
 * This test verifies that after adding a station info entry into the consolidated map, the get_first_sta_info API returns a valid pointer. It then compares the returned station's MAC address with the expected MAC address to ensure the correct entry is retrieved.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 258@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                         | Test Data                                                                                                | Expected Result                                                                                 | Notes         |
 * | :--------------: | ------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize dm object and station info structure                     | dm_easy_mesh_t dm;, sta_info = {}, sta_mac = {0x00,0x11,0x22,0x33,0x44,0x55}, bssid = {0x10,0x20,0x30,0x40,0x50,0x60}, radio = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF} | dm object is initialized and sta_info is prepared                                               | Should Pass   |
 * | 02               | Add STA info to the consolidated map via put_sta_info                | put_sta_info(&sta_info, em_target_sta_map_consolidated)                                                  | STA info is successfully added to the consolidated map                                          | Should Pass   |
 * | 03               | Retrieve the first STA info from consolidated map via get_first_sta_info| get_first_sta_info(em_target_sta_map_consolidated)                                                       | Returns a non-null pointer to the first STA info                                                  | Should Pass   |
 * | 04               | Verify retrieved STA info by comparing MAC address                    | memcmp(info->id, sta_mac, sizeof(mac_address_t))                                                         | memcmp returns 0 indicating the retrieved STA info matches the expected MAC address              | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_first_sta_info_consolidated_positive)
{
    const char* testName = "get_first_sta_info_consolidated_positive";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_sta_info_t sta_info{};
    mac_address_t sta_mac = {0x00,0x11,0x22,0x33,0x44,0x55};
    mac_address_t bssid   = {0x10,0x20,0x30,0x40,0x50,0x60};
    mac_address_t radio   = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    memcpy(sta_info.id, sta_mac, sizeof(mac_address_t));
    memcpy(sta_info.bssid, bssid, sizeof(mac_address_t));
    memcpy(sta_info.radiomac, radio, sizeof(mac_address_t));
    std::cout << "Adding STA to consolidated map" << std::endl;
    dm.put_sta_info(&sta_info, em_target_sta_map_consolidated);
    std::cout << "Invoking get_first_sta_info(consolidated)" << std::endl;
    em_sta_info_t* info = dm.get_first_sta_info(em_target_sta_map_consolidated);
    ASSERT_NE(info, nullptr);
    std::cout << "STA info retrieved successfully" << std::endl;
    print_sta_info(info);
    EXPECT_EQ(memcmp(info->id, sta_mac, sizeof(mac_address_t)), 0);
    dm.deinit();
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_first_sta_info returns the first associated station's information correctly
 *
 * This test verifies that after initializing the dm_easy_mesh_t object and adding a station's information
 * to the association map, the get_first_sta_info function returns a non-null pointer with the correct station MAC address.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 259@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize the dm_easy_mesh_t object and call init() | testName = "get_first_sta_info_assoc_positive", dm.init() | dm_easy_mesh_t object is successfully initialized | Should be successful |
 * | 02 | Populate the station information structure with a MAC address | sta_mac = {0x01,0x02,0x03,0x04,0x05,0x06}, sta_info.id set from sta_mac | Station info structure is correctly populated with the given MAC address | Should be successful |
 * | 03 | Add the station info to the association map using put_sta_info | &sta_info, em_target_sta_map_assoc | Station info is added to the association map | Should Pass |
 * | 04 | Invoke get_first_sta_info on the association map | em_target_sta_map_assoc | Function returns a non-null pointer | Should Pass |
 * | 05 | Verify that the retrieved station info's MAC address matches the input MAC address | info->id compared against sta_mac, using memcmp | memcmp returns 0 indicating a match, and assertion checks pass | Should Pass |
 */
TEST(dm_easy_mesh_t, get_first_sta_info_assoc_positive)
{
    const char* testName = "get_first_sta_info_assoc_positive";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_sta_info_t sta_info{};
    mac_address_t sta_mac = {0x01,0x02,0x03,0x04,0x05,0x06};
    memcpy(sta_info.id, sta_mac, sizeof(mac_address_t));
    std::cout << "Adding STA to assoc map" << std::endl;
    dm.put_sta_info(&sta_info, em_target_sta_map_assoc);
    std::cout << "Invoking get_first_sta_info(assoc)" << std::endl;
    em_sta_info_t* info = dm.get_first_sta_info(em_target_sta_map_assoc);
    ASSERT_NE(info, nullptr);
    print_sta_info(info);
    EXPECT_EQ(memcmp(info->id, sta_mac, sizeof(mac_address_t)), 0);
    dm.deinit();
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_first_sta_info correctly retrieves the first STA info from the disassociation map.
 *
 * This test checks that when a valid STA info is inserted into the disassociation map using put_sta_info, the function get_first_sta_info returns a non-null pointer and the retrieved STA info matches the provided MAC address. It ensures that the retrieval functionality works as expected when dealing with disassociated stations.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 260@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                                                              | Expected Result                                                                  | Notes          |
 * | :--------------: | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------- | -------------- |
 * | 01               | Initialize dm_easy_mesh instance and invoke init()                         | dm instance created, init() called without parameters                                                  | dm object is successfully initialized                                          | Should be successful |
 * | 02               | Prepare sta_info structure with a predefined MAC address                    | sta_info.id = {0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F}                                                       | sta_info structure is populated with the correct MAC address                    | Should be successful |
 * | 03               | Add the STA info to the disassociation map using put_sta_info               | Input: pointer to sta_info, map identifier: em_target_sta_map_disassoc                                   | STA info is successfully added to the disassociation map                        | Should Pass    |
 * | 04               | Invoke get_first_sta_info to retrieve the STA info from the disassociation map | Input: map identifier: em_target_sta_map_disassoc; Output: pointer info variable                         | Function returns a non-null pointer to valid STA info                          | Should Pass    |
 * | 05               | Assert that the returned STA info pointer is not nullptr                     | info != nullptr                                                                                        | Assertion passes ensuring info is not null                                      | Should Pass    |
 * | 06               | Verify that the retrieved STA info MAC address matches the expected value    | Input: memcmp(info->id, sta_mac, sizeof(mac_address_t)); Expected output: 0                             | EXPECT_EQ returns 0, indicating that the MAC addresses match                    | Should Pass    |
 * | 07               | Print the STA info and conclude the test                                    | Function call: print_sta_info(info)                                                                    | STA info is printed, and test concludes successfully                           | Should be successful |
 */
TEST(dm_easy_mesh_t, get_first_sta_info_disassoc_positive)
{
    const char* testName = "get_first_sta_info_disassoc_positive";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_sta_info_t sta_info{};
    mac_address_t sta_mac = {0x0A,0x0B,0x0C,0x0D,0x0E,0x0F};
    memcpy(sta_info.id, sta_mac, sizeof(mac_address_t));
    std::cout << "Adding STA to disassoc map" << std::endl;
    dm.put_sta_info(&sta_info, em_target_sta_map_disassoc);
    std::cout << "Invoking get_first_sta_info(disassoc)" << std::endl;
    em_sta_info_t* info = dm.get_first_sta_info(em_target_sta_map_disassoc);
    ASSERT_NE(info, nullptr);
    print_sta_info(info);
    EXPECT_EQ(memcmp(info->id, sta_mac, sizeof(mac_address_t)), 0);
    dm.deinit();
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_first_sta_info returns nullptr when the consolidated map is empty
 *
 * This test case validates that when the consolidated STA map is empty, the get_first_sta_info() method returns a nullptr.
 * The test is designed to ensure that the function handles an empty internal data structure correctly without causing any unexpected behavior.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 261@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Set the test name and print the entering message | testName = "get_first_sta_info_empty_map" | "Entering get_first_sta_info_empty_map" printed to stdout | Should be successful |
 * | 02 | Initialize the dm_easy_mesh_t instance by invoking init() | dm instance; no additional inputs | dm instance is properly initialized | Should be successful |
 * | 03 | Invoke get_first_sta_info() on an empty consolidated STA map | input: consolidated map = em_target_sta_map_consolidated; output: info variable | Returns nullptr assigned to info | Should Pass |
 * | 04 | Validate the returned value is nullptr using an assertion check | output: info should be nullptr | EXPECT_EQ(info, nullptr) passes | Should Pass |
 * | 05 | Print the exit message indicating the end of the test | message "Exiting get_first_sta_info_empty_map" | "Exiting get_first_sta_info_empty_map" printed to stdout | Should be successful |
 */
TEST(dm_easy_mesh_t, get_first_sta_info_empty_map)
{
    const char* testName = "get_first_sta_info_empty_map";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    std::cout << "Invoking get_first_sta_info() on empty consolidated map" << std::endl;
    em_sta_info_t* info = dm.get_first_sta_info(em_target_sta_map_consolidated);
    EXPECT_EQ(info, nullptr);
    std::cout << "No STA found as expected" << std::endl;
    dm.deinit();
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate that get_first_sta_info returns nullptr when a wrong target map is used.
 *
 * This test verifies that when a STA info is inserted into the assoc map, invoking get_first_sta_info using the consolidated target map returns nullptr. It ensures that the API differentiates between maps correctly.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 262@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                        | Test Data                                                                               | Expected Result                                     | Notes          |
 * | :--------------: | ------------------------------------------------------------------ | --------------------------------------------------------------------------------------- | --------------------------------------------------- | -------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and create a STA info structure   | dm_easy_mesh_t instance created, call dm.init(), sta_info with MAC = AA,BB,CC,DD,EE,FF  | Instance initialized and structure created          | Should be successful |
 * | 02               | Insert the STA info into the assoc map                              | sta_info with id = [AA,BB,CC,DD,EE,FF], target = em_target_sta_map_assoc                 | STA info added into assoc map                         | Should be successful |
 * | 03               | Invoke get_first_sta_info with the consolidated target map          | target = em_target_sta_map_consolidated                                                 | Expected return is nullptr as the STA is not in this map  | Should Pass    |
 */
TEST(dm_easy_mesh_t, get_first_sta_info_wrong_target)
{
    const char* testName = "get_first_sta_info_wrong_target";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_sta_info_t sta_info{};
    mac_address_t sta_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    memcpy(sta_info.id, sta_mac, sizeof(mac_address_t));
    std::cout << "Adding STA only to assoc map" << std::endl;
    dm.put_sta_info(&sta_info, em_target_sta_map_assoc);
    std::cout << "Invoking get_first_sta_info(consolidated)" << std::endl;
    em_sta_info_t* info = dm.get_first_sta_info(em_target_sta_map_consolidated);
    EXPECT_EQ(info, nullptr);
    std::cout << "STA not found as expected (wrong target map)" << std::endl;
    dm.deinit();
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate the correct retrieval of the first STA info from the consolidated map
 *
 * This test verifies that after initializing a mesh instance and adding a STA information record
 * to the consolidated map, the static method get_first_sta_info returns a valid STA info pointer.
 * It checks that the returned STA info pointer is not null and that its STA id matches the expected MAC address.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 263@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                              | Test Data                                                                                                                                                                              | Expected Result                                                                                                                | Notes       |
 * | :--------------: | -------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ | ----------- |
 * | 01               | Initialize the mesh instance and the STA info structure, including setting MAC addresses               | dm: instance of dm_easy_mesh_t (after dm.init()), sta: id = [0x00,0x11,0x22,0x33,0x44,0x55], bssid = [0x10,0x20,0x30,0x40,0x50,0x60], radiomac = [0xAA,0xBB,0xCC,0xDD,0xEE,0xFF], map = em_target_sta_map_consolidated | Mesh instance and STA info structure prepared with correct values                                                                 | Should be successful |
 * | 02               | Add the STA info to the consolidated map using put_sta_info                                               | Call: dm.put_sta_info(&sta, em_target_sta_map_consolidated)                                                                                                                           | STA info is successfully added to the consolidated map                                                                          | Should be successful |
 * | 03               | Invoke static_get_first_sta_info with the consolidated map and verify the returned STA info pointer and MAC match | Call: info = dm_easy_mesh_t::get_first_sta_info(static_cast<void*>(&dm), em_target_sta_map_consolidated), Input STA id expected = [0x00,0x11,0x22,0x33,0x44,0x55]                     | API returns a non-null pointer and memcmp(info->id, sta_mac) == 0 indicating a correct match                                     | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_first_sta_info_consolidated_positive)
{
    const char* testName = "static_get_first_sta_info_consolidated_positive";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_sta_info_t sta{};
    mac_address_t sta_mac   = {0x00,0x11,0x22,0x33,0x44,0x55};
    mac_address_t bssid     = {0x10,0x20,0x30,0x40,0x50,0x60};
    mac_address_t radiomac  = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    memcpy(sta.id, sta_mac, sizeof(mac_address_t));
    memcpy(sta.bssid, bssid, sizeof(mac_address_t));
    memcpy(sta.radiomac, radiomac, sizeof(mac_address_t));
    std::cout << "Adding STA to consolidated map" << std::endl;
    dm.put_sta_info(&sta, em_target_sta_map_consolidated);
    std::cout << "Invoking static get_first_sta_info(consolidated)" << std::endl;
    em_sta_info_t* info = dm_easy_mesh_t::get_first_sta_info(static_cast<void*>(&dm), em_target_sta_map_consolidated);
    ASSERT_NE(info, nullptr);
    std::cout << "STA info retrieved successfully" << std::endl;
    print_sta_info(info);
    EXPECT_EQ(memcmp(info->id, sta_mac, sizeof(mac_address_t)), 0);
    dm.deinit();
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that the first STA info is correctly retrieved from the association map.
 *
 * This test confirms that when a STA is added to the association map, the static method get_first_sta_info
 * successfully retrieves the first STA info entry. It checks that the returned pointer is not null and that
 * the MAC address of the returned STA info matches the expected value. This ensures the proper functionality
 * of the association path in the dm_easy_mesh_t class.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 264@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create dm_easy_mesh_t instance and output test entry message | testName = "static_get_first_sta_info_assoc_positive" | Console outputs "Entering static_get_first_sta_info_assoc_positive" | Should be successful |
 * | 02 | Initialize the dm_easy_mesh_t instance by calling init() | No input | dm instance is successfully initialized | Should be successful |
 * | 03 | Prepare STA info data structure and set MAC address | sta_mac = [0x01,0x02,0x03,0x04,0x05,0x06], sta initialized with zeros | sta.id is set with the provided MAC address | Should be successful |
 * | 04 | Add STA info to the association map via put_sta_info() | Input: &sta, em_target_sta_map_assoc | STA info is stored in the association map | Should be successful |
 * | 05 | Invoke static get_first_sta_info() with dm instance and target mapping | Input: pointer to dm (cast to void*), em_target_sta_map_assoc | Returns a non-null pointer to the first STA info entry | Should Pass |
 * | 06 | Verify the retrieved STA info matches the expected MAC address | Input: info pointer, expected MAC = [0x01,0x02,0x03,0x04,0x05,0x06] | memcmp returns 0 and the assertion check passes | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_first_sta_info_assoc_positive)
{
    const char* testName = "static_get_first_sta_info_assoc_positive";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_sta_info_t sta{};
    mac_address_t sta_mac = {0x01,0x02,0x03,0x04,0x05,0x06};
    memcpy(sta.id, sta_mac, sizeof(mac_address_t));
    std::cout << "Adding STA to assoc map" << std::endl;
    dm.put_sta_info(&sta, em_target_sta_map_assoc);
    std::cout << "Invoking static get_first_sta_info(assoc)" << std::endl;
    em_sta_info_t* info = dm_easy_mesh_t::get_first_sta_info(static_cast<void*>(&dm), em_target_sta_map_assoc);
    ASSERT_NE(info, nullptr);
    print_sta_info(info);
    EXPECT_EQ(memcmp(info->id, sta_mac, sizeof(mac_address_t)), 0);
    dm.deinit();
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate that the static get_first_sta_info API correctly returns the first station info from the disassoc map.
 *
 * This test verifies the positive scenario where a station is added to the disassoc map and then retrieved using the static get_first_sta_info API.
 * It confirms that the returned pointer is not null and that the station information matches the expected value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 265@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                     | Test Data                                                                                         | Expected Result                                                                              | Notes          |
 * | :----:           | ----------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- | -------------- |
 * | 01               | Initialize dm instance, setup sta info, and add it to the disassoc map using dm.put_sta_info      | testName = "static_get_first_sta_info_disassoc_positive", sta.id = {0x0A,0x0B,0x0C,0x0D,0x0E,0x0F} | STA info is added to the disassociation map successfully                                      | Should be successful |
 * | 02               | Invoke static get_first_sta_info to retrieve the first station info from the disassoc map         | input: dm pointer (void*), map type = em_target_sta_map_disassoc                                    | Return pointer is non-null; memcmp result equals 0 confirming that the returned sta info matches | Should Pass    |
 */
TEST(dm_easy_mesh_t, static_get_first_sta_info_disassoc_positive)
{
    const char* testName = "static_get_first_sta_info_disassoc_positive";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_sta_info_t sta{};
    mac_address_t sta_mac = {0x0A,0x0B,0x0C,0x0D,0x0E,0x0F};
    memcpy(sta.id, sta_mac, sizeof(mac_address_t));
    std::cout << "Adding STA to disassoc map" << std::endl;
    dm.put_sta_info(&sta, em_target_sta_map_disassoc);
    std::cout << "Invoking static get_first_sta_info(disassoc)" << std::endl;
    em_sta_info_t* info = dm_easy_mesh_t::get_first_sta_info(static_cast<void*>(&dm), em_target_sta_map_disassoc);
    ASSERT_NE(info, nullptr);
    print_sta_info(info);
    EXPECT_EQ(memcmp(info->id, sta_mac, sizeof(mac_address_t)), 0);
    dm.deinit();
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate that get_first_sta_info returns nullptr when no STA exists in the map.
 *
 * This test verifies that invoking the static method get_first_sta_info on a dm_easy_mesh_t instance with
 * an empty station map correctly returns a nullptr. This ensures that the API handles empty datasets as expected.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 266@n
 * **Priority:** High
 * 
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                | Test Data                                                                                          | Expected Result                                               | Notes        |
 * | :--------------: | -------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | ------------------------------------------------------------- | ------------ |
 * | 01               | Create an instance of dm_easy_mesh_t and initialize it using init()         | dm_easy_mesh_t instance created, then init() invoked                                               | Instance is properly initialized without errors               | Should be successful |
 * | 02               | Invoke get_first_sta_info on the empty STA map                             | input: pointer = address of dm instance, map target = em_target_sta_map_consolidated; output: info = nullptr | Method returns nullptr and assertion EXPECT_EQ(info, nullptr) passes | Should Pass  |
 */
TEST(dm_easy_mesh_t, static_get_first_sta_info_empty_map)
{
    const char* testName = "static_get_first_sta_info_empty_map";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    std::cout << "Invoking static get_first_sta_info() on empty map" << std::endl;
    em_sta_info_t* info = dm_easy_mesh_t::get_first_sta_info(static_cast<void*>(&dm), em_target_sta_map_consolidated);
    EXPECT_EQ(info, nullptr);
    std::cout << "Returned nullptr as expected (no STA present)" << std::endl;
    dm.deinit();
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate that get_first_sta_info returns nullptr when an incorrect target map is used
 *
 * This test validates that when a STA info is added to the association map and then the static 
 * method get_first_sta_info is invoked with the consolidated map target, the function correctly 
 * returns a nullptr as the STA is not present in that map.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 267@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                        | Test Data                                                                                     | Expected Result                           | Notes           |
 * | :--------------: | ------------------------------------------------------------------ | --------------------------------------------------------------------------------------------- | ----------------------------------------- | --------------- |
 * | 01               | Initialize the dm_easy_mesh_t instance by invoking dm.init()        | dm instance before initialization                                                             | dm instance is properly initialized       | Should Pass     |
 * | 02               | Populate em_sta_info_t structure with a valid STA MAC address        | sta.id = 0xAA,0xBB,0xCC,0xDD,0xEE,0xFF                                                         | STA info structure is correctly populated | Should be successful |
 * | 03               | Add STA info into the association map using put_sta_info API         | input: sta pointer, target = em_target_sta_map_assoc                                            | STA info is added to the association map  | Should Pass     |
 * | 04               | Invoke static get_first_sta_info with wrong target map (consolidated)  | input: pointer to dm instance, target = em_target_sta_map_consolidated                            | Function returns nullptr                  | Should Fail     |
 * | 05               | Verify that the returned STA info is nullptr via EXPECT_EQ           | input: info = result from get_first_sta_info                                                     | Assertion passes (returned info is nullptr) | Should be successful |
 */
TEST(dm_easy_mesh_t, static_get_first_sta_info_wrong_target)
{
    const char* testName = "static_get_first_sta_info_wrong_target";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_sta_info_t sta{};
    mac_address_t sta_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    memcpy(sta.id, sta_mac, sizeof(mac_address_t));
    std::cout << "Adding STA only to assoc map" << std::endl;
    dm.put_sta_info(&sta, em_target_sta_map_assoc);
    std::cout << "Invoking static get_first_sta_info(consolidated)" << std::endl;
    em_sta_info_t* info = dm_easy_mesh_t::get_first_sta_info(static_cast<void*>(&dm), em_target_sta_map_consolidated);
    EXPECT_EQ(info, nullptr);
    std::cout << "STA not found as expected (wrong target map)" << std::endl;
    dm.deinit();
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test case to verify the behavior of get_first_sta_info when provided with a NULL dm pointer
 *
 * This test checks that calling get_first_sta_info with a NULL dm pointer and a specific target (em_target_sta_map_assoc)
 * returns a NULL pointer, ensuring that the API correctly handles null input parameters.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 268@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                         | Test Data                                                        | Expected Result                                                                                   | Notes      |
 * | :--------------: | --------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- | ---------- |
 * | 01               | Invoke get_first_sta_info with dm pointer set as NULL and target as em_target_sta_map_assoc         | dm pointer = nullptr, target = em_target_sta_map_assoc             | Return value: nullptr; Assertion: EXPECT_EQ(result, nullptr)                                       | Should Pass |
 */
TEST(dm_easy_mesh_t, get_first_sta_info_null_dm) {
    std::cout << "Entering get_first_sta_info_null_dm test" << std::endl;
    std::cout << "Invoking get_first_sta_info with dm pointer as NULL and target: em_target_sta_map_assoc" << std::endl;
    em_sta_info_t* result = dm_easy_mesh_t::get_first_sta_info(nullptr, em_target_sta_map_assoc);
    std::cout << "Returned pointer: " << result << std::endl;
    EXPECT_EQ(result, nullptr);
    std::cout << "Exiting get_first_sta_info_null_dm test" << std::endl;
}

/**
 * @brief Test the default retrieval of IEEE 1905 security capabilities
 *
 * This test verifies that the dm_easy_mesh_t API correctly returns a non-null pointer for the IEEE 1905 security capabilities. It ensures that the default security capability of the device is properly set and retrievable through the get_ieee_1905_security_cap method.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 269@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                              | Test Data                                          | Expected Result                            | Notes      |
 * | :--------------: | ------------------------------------------------------------------------ | -------------------------------------------------- | ------------------------------------------ | ---------- |
 * | 01               | Invoke get_ieee_1905_security_cap() and assert that the returned pointer is not null | input: none, output: cap (pointer returned by get_ieee_1905_security_cap()) | The returned pointer should not be nullptr   | Should Pass |
 */
TEST(dm_easy_mesh_t, get_ieee_1905_security_cap_default)
{
    const char* testName = "get_ieee_1905_security_cap_default";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm{};
    std::cout << "Invoking get_ieee_1905_security_cap()" << std::endl;
    em_ieee_1905_security_cap_t* cap = dm.get_ieee_1905_security_cap();
    ASSERT_NE(cap, nullptr);
    std::cout << "Returned security cap pointer is valid" << std::endl;
    print_ieee_1905_security_cap(cap);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test to verify retrieval of IEEE 1905 security capabilities in dm_easy_mesh_t.
 *
 * This test configures the security capability values within a dm_easy_mesh_t instance, invokes the
 * get_ieee_1905_security_cap() API, and verifies that the returned pointer is not null and that the
 * capability values (onboarding_proto, integrity_algo, and encryption_algo) match the configured values.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 270@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                                                                                                                                                                        | Expected Result                                                     | Notes           |
 * | :--------------: | --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------- | --------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and configure security capabilities.                       | dm.m_ieee_1905_security.m_ieee_1905_security_info.sec_cap.onboarding_proto = 1, dm.m_ieee_1905_security.m_ieee_1905_security_info.sec_cap.integrity_algo = 2, dm.m_ieee_1905_security.m_ieee_1905_security_info.sec_cap.encryption_algo = 3 | Security capability values are correctly configured in the instance. | Should be successful |
 * | 02               | Invoke get_ieee_1905_security_cap() to retrieve the security capabilities pointer.            | Input: dm instance                                                                                                                                                                               | Non-null pointer returned from the API.                             | Should Pass     |
 * | 03               | Verify that the retrieved security capability values match the configured values.             | Expected output: onboarding_proto = 1, integrity_algo = 2, encryption_algo = 3                                                                                                                     | API returns a pointer with the correct capability values.             | Should Pass     |
 * | 04               | Print the retrieved security capability values for manual verification.                       | Output: Printed values from print_ieee_1905_security_cap(cap)                                                                                                                                       | Printed values reflect the expected configuration.                  | Should be successful |
 */
TEST(dm_easy_mesh_t, get_ieee_1905_security_cap_configured)
{
    const char* testName = "get_ieee_1905_security_cap_configured";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    // Configure security capability values
    dm.m_ieee_1905_security.m_ieee_1905_security_info.sec_cap.onboarding_proto = 1;
    dm.m_ieee_1905_security.m_ieee_1905_security_info.sec_cap.integrity_algo   = 2;
    dm.m_ieee_1905_security.m_ieee_1905_security_info.sec_cap.encryption_algo  = 3;
    std::cout << "Invoking get_ieee_1905_security_cap() with configured values" << std::endl;
    em_ieee_1905_security_cap_t* cap = dm.get_ieee_1905_security_cap();
    ASSERT_NE(cap, nullptr);
    print_ieee_1905_security_cap(cap);
    EXPECT_EQ(cap->onboarding_proto, 1);
    EXPECT_EQ(cap->integrity_algo, 2);
    EXPECT_EQ(cap->encryption_algo, 3);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that dm_easy_mesh_t::get_ieee_1905_security_info returns a valid pointer.
 *
 * This test verifies that the get_ieee_1905_security_info method of dm_easy_mesh_t properly initializes and returns a non-null pointer to an instance of em_ieee_1905_security_info_t. It ensures that the default configuration is correctly set up for further operations.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 271@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                               | Test Data                                                                      | Expected Result                      | Notes              |
 * | :--------------: | ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | ------------------------------------ | ------------------ |
 * | 01               | Log entry and instantiate dm_easy_mesh_t                                                  | testName = "get_ieee_1905_security_info_instance_default", instance = default   | Instance created and entry logged    | Should be successful |
 * | 02               | Invoke get_ieee_1905_security_info() and assert the returned pointer is not null            | input: dm_easy_mesh_t instance; output: info pointer                           | info is not nullptr                  | Should Pass        |
 * | 03               | Print the security info and log test exit                                                 | output: info pointer value                                                     | Security info printed and exit logged | Should be successful |
 */
TEST(dm_easy_mesh_t, get_ieee_1905_security_info_instance_default)
{
    const char* testName = "get_ieee_1905_security_info_instance_default";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm{};
    std::cout << "Invoking instance get_ieee_1905_security_info()" << std::endl;
    em_ieee_1905_security_info_t* info = dm.get_ieee_1905_security_info();
    ASSERT_NE(info, nullptr);
    std::cout << "Returned security info pointer is valid" << std::endl;
    print_ieee_1905_security_info(info);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test to verify that get_ieee_1905_security_info returns correct security information when configured
 *
 * This test verifies that after configuring the MAC ID and security capabilities in the dm_easy_mesh_t instance,
 * the get_ieee_1905_security_info method returns a non-null pointer and the returned security information correctly 
 * reflects the configured MAC and capabilities (onboarding_proto, integrity_algo, encryption_algo). This is critical 
 * to ensure the underlying configuration mechanism is functioning properly.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 272@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                 | Test Data                                                            | Expected Result                                                                     | Notes         |
 * | :--------------: | --------------------------------------------------------------------------- | -------------------------------------------------------------------- | ----------------------------------------------------------------------------------- | ------------- |
 * | 01               | Configure instance: Set MAC ID and security capabilities in dm_easy_mesh_t instance. | input: mac = 0xAA,0xBB,0xCC,0xDD,0xEE,0xFF; sec_cap.onboarding_proto = 1, sec_cap.integrity_algo = 2, sec_cap.encryption_algo = 3 | Instance configured with provided MAC and security capabilities.                     | Should be successful |
 * | 02               | Invoke get_ieee_1905_security_info() on the configured instance.            | input: dm_easy_mesh_t instance with configured security info         | Returns non-null pointer to a structure containing the security configuration.     | Should Pass   |
 * | 03               | Validate the returned security info: Compare MAC and security capability values.   | input: output from get_ieee_1905_security_info; expected: MAC and sec_cap values as configured | Returned structure contains MAC identical to the configured MAC and matching security capabilities. | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_ieee_1905_security_info_instance_configured)
{
    const char* testName = "get_ieee_1905_security_info_instance_configured";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    // Configure MAC ID
    unsigned char mac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    memcpy(dm.m_ieee_1905_security.m_ieee_1905_security_info.id, mac, 6);
    // Configure security capabilities
    auto& sec_cap = dm.m_ieee_1905_security.m_ieee_1905_security_info.sec_cap;
    sec_cap.onboarding_proto = 1;
    sec_cap.integrity_algo   = 2;
    sec_cap.encryption_algo  = 3;
    std::cout << "Invoking instance get_ieee_1905_security_info() "
                 "with configured values"
              << std::endl;
    em_ieee_1905_security_info_t* info = dm.get_ieee_1905_security_info();
    ASSERT_NE(info, nullptr);
    print_ieee_1905_security_info(info);
    EXPECT_EQ(memcmp(info->id, mac, 6), 0);
    EXPECT_EQ(info->sec_cap.onboarding_proto, 1);
    EXPECT_EQ(info->sec_cap.integrity_algo, 2);
    EXPECT_EQ(info->sec_cap.encryption_algo, 3);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test the get_interface_by_index API with the default index 0 to ensure it returns a valid interface pointer
 *
 * This test creates an instance of dm_easy_mesh_t and calls the get_interface_by_index API using index 0. It verifies that the returned interface pointer is not a nullptr, indicating the proper initialization and retrieval of the interface. The test outputs log messages indicating entry, invocation, and exit of the test function.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 273@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                         | Test Data                                    | Expected Result                                     | Notes        |
 * | :--------------: | ------------------------------------------------------------------- | -------------------------------------------- | --------------------------------------------------- | ------------ |
 * | 01               | Invoke get_interface_by_index with index 0 on dm_easy_mesh_t instance | index = 0                                    | Returns a valid (non-null) interface pointer; ASSERT_NE(iface, nullptr) is satisfied | Should Pass  |
 */
TEST(dm_easy_mesh_t, get_interface_by_index_default_index0)
{
    const char* testName = "get_interface_by_index_default_index0";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm{};
    std::cout << "Invoking get_interface_by_index(0)" << std::endl;
    em_interface_t* iface = dm.get_interface_by_index(0);
    ASSERT_NE(iface, nullptr);
    std::cout << "Returned interface pointer is valid" << std::endl;
    print_interface(iface);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Tests retrieval of a configured interface by its index.
 *
 * This test verifies that when an interface is configured with a specific name, MAC address, and media type in the dm_easy_mesh_t object,
 * calling get_interface_by_index with the corresponding index returns the correct interface pointer with the expected properties.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 274@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Configure the interface in the dm_easy_mesh_t object at index 1 with predefined parameters | index = 1, name = eth0, mac = 0x10,0x22,0x33,0x44,0x55,0x66, media = em_media_type_ieee8023ab | Interface fields are correctly set in the dm object | Should be successful |
 * | 02 | Call the API get_interface_by_index with index 1 | input: index = 1 | Returns a non-null interface pointer | Should Pass |
 * | 03 | Validate that the returned interface has the expected name, MAC address, and media type | output: name = eth0, mac = 0x10,0x22,0x33,0x44,0x55,0x66, media = em_media_type_ieee8023ab | The interface properties match the configured values (EXPECT_STREQ and memcmp assertions pass) | Should Pass |
 */
TEST(dm_easy_mesh_t, get_interface_by_index_configured)
{
    const char* testName = "get_interface_by_index_configured";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm{};
    unsigned int index = 1;
    // Configure interface
    strncpy(dm.m_interfaces[index].name, "eth0", sizeof(dm.m_interfaces[index].name) - 1);
    unsigned char mac[6] = {0x10, 0x22, 0x33, 0x44, 0x55, 0x66};
    memcpy(dm.m_interfaces[index].mac, mac, sizeof(mac));
    dm.m_interfaces[index].media = em_media_type_ieee8023ab;
    std::cout << "Invoking get_interface_by_index(" << index << ")" << std::endl;
    em_interface_t* iface = dm.get_interface_by_index(index);
    ASSERT_NE(iface, nullptr);
    print_interface(iface);
    EXPECT_STREQ(iface->name, "eth0");
    EXPECT_EQ(memcmp(iface->mac, mac, 6), 0);
    EXPECT_EQ(iface->media, em_media_type_ieee8023ab);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test for validated retrieval of an interface at the maximum boundary index.
 *
 * This test verifies that the get_interface_by_index function correctly returns a pointer
 * to the interface when invoked with the highest valid index (EM_MAX_INTERFACES - 1). The test
 * sets up an interface with known values (name, MAC address, and media type) to ensure that the
 * function retrieves the correct interface data for further processing.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 275@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t and set the interface at the maximum index with known values | index = EM_MAX_INTERFACES - 1, interface name = "eth0", MAC = "0x10,0x22,0x33,0x44,0x55,0x66", media = em_media_type_ieee8023ab | The interface structure at the maximum index is correctly initialized with the provided values | Should be successful |
 * | 02 | Invoke get_interface_by_index with the maximum boundary index and verify the returned pointer is not null | input: index = EM_MAX_INTERFACES - 1, expected output: valid interface pointer (non-null) | Returns a non-null pointer corresponding to the initialized interface | Should Pass |
 * | 03 | Print the interface details to ensure correct data is fetched | output: console output showing interface details (name, MAC, media) | Console output displays the expected interface details | Should be successful |
 */
TEST(dm_easy_mesh_t, get_interface_by_index_max_boundary)
{
    const char* testName = "get_interface_by_index_max_boundary";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm{};
    unsigned int index = EM_MAX_INTERFACES - 1;
    strncpy(dm.m_interfaces[index].name, "eth0", sizeof(dm.m_interfaces[index].name) - 1);
    unsigned char mac[6] = {0x10, 0x22, 0x33, 0x44, 0x55, 0x66};
    memcpy(dm.m_interfaces[index].mac, mac, sizeof(mac));
    dm.m_interfaces[index].media = em_media_type_ieee8023ab;
    std::cout << "Invoking get_interface_by_index(" << index << ")" << std::endl;
    em_interface_t* iface = dm.get_interface_by_index(index);
    ASSERT_NE(iface, nullptr);
    print_interface(iface);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test retrieval of an interface using an index beyond the maximum allowed boundary
 *
 * This test verifies that the dm_easy_mesh_t::get_interface_by_index API returns a nullptr when supplied
 * with an index value that exceeds the maximum number of allowed interfaces (EM_MAX_INTERFACES). The objective
 * is to ensure that the function safely handles out-of-bound interface requests without causing memory access errors.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 276@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t instance and define an index beyond the maximum boundary | dm: default constructed instance, index = EM_MAX_INTERFACES + 1 | dm instance is created successfully and index is set to EM_MAX_INTERFACES + 1 | Should be successful |
 * | 02 | Invoke get_interface_by_index with the out-of-bound index | input1 = index, value = EM_MAX_INTERFACES + 1; output1 = iface | API returns a nullptr indicating no valid interface for the provided index | Should Pass |
 */
TEST(dm_easy_mesh_t, get_interface_by_index_beyond_max_boundary)
{
    const char* testName = "get_interface_by_index_beyond_max_boundary";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm{};
    unsigned int index = EM_MAX_INTERFACES + 1;
    std::cout << "Invoking get_interface_by_index(" << index << ")" << std::endl;
    em_interface_t* iface = dm.get_interface_by_index(index);
    ASSERT_EQ(iface, nullptr);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate successful retrieval of interface list using get_interfaces_list API.
 *
 * This test verifies that the get_interfaces_list API returns a success code (0) and that the number of interfaces returned is greater than zero.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 277@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                | Test Data                                                          | Expected Result                                             | Notes          |
 * | :--------------: | -------------------------------------------------------------------------- | ------------------------------------------------------------------ | ------------------------------------------------------------ | -------------- |
 * | 01               | Initialize the interfaces array and num_interfaces variable                | interfaces = array of size EM_MAX_INTERFACES, num_interfaces = EM_MAX_INTERFACES | Variables initialized correctly                              | Should be successful |
 * | 02               | Invoke the get_interfaces_list API                                         | input: interfaces, num_interfaces pointer                          | Returns 0                                        | Should Pass    |
 * | 03               | Verify that the returned number of interfaces is greater than zero         | output: num_interfaces (updated value)                              | num_interfaces > 0                                             | Should Pass    |
 * | 04               | Print details of each interface returned by the API                        | Iterating variable i: 0 to num_interfaces-1 with each interface data | Interface details printed for each valid interface            | Should be successful |
 * | 05               | Exit the test after completing the validations                             | N/A                                                                 | Test completed without errors                                  | Should be successful |
 */
TEST(dm_easy_mesh_t, get_interfaces_list_success)
{
    const char* testName = "get_interfaces_list_success";
    std::cout << "Entering " << testName << std::endl;
    em_interface_t interfaces[EM_MAX_INTERFACES]{};
    unsigned int num_interfaces = EM_MAX_INTERFACES;
    std::cout << "Invoking get_interfaces_list()" << std::endl;
    int ret = dm_easy_mesh_t::get_interfaces_list(interfaces, &num_interfaces);
    EXPECT_EQ(ret, 0);
    EXPECT_GT(num_interfaces, 0u);
    std::cout << "Number of interfaces returned: " << num_interfaces << std::endl;
    for (unsigned int i = 0; i < num_interfaces; ++i) {
        std::cout << "--- Interface [" << i << "] ---" << std::endl;
        print_interface(interfaces[i]);
    }
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test the retrieval of a limited number of interfaces using dm_easy_mesh_t::get_interfaces_list()
 *
 * This test verifies that the get_interfaces_list() function correctly honors the provided limit on the number of interfaces to retrieve.
 * It checks that the function returns a success code and that the number of returned interfaces does not exceed the limit.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 278@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | ------------- | ----- |
 * | 01 | Initialize test parameters; set test name and prepare interfaces array with capacity of 2, and initialize num_interfaces to 2 | testName = "get_interfaces_list_limited_count", interfaces = array of size 2 (uninitialized), num_interfaces = 2 | Test parameters are properly initialized | Should be successful |
 * | 02 | Invoke dm_easy_mesh_t::get_interfaces_list() with the interfaces array and pointer to num_interfaces | input: interfaces pointer, pointer to num_interfaces (value = 2) | Return value equals 0 indicating a successful call | Should Pass |
 * | 03 | Validate that the number of returned interfaces does not exceed the limit provided (2) | output: num_interfaces (expected value <= 2) | num_interfaces is less than or equal to 2 | Should Pass |
 * | 04 | Iterate through the returned interfaces and print each interface details | iteration: for each element in interfaces up to num_interfaces | Interfaces are printed accordingly | Should be successful |
 */
TEST(dm_easy_mesh_t, get_interfaces_list_limited_count)
{
    const char* testName = "get_interfaces_list_limited_count";
    std::cout << "Entering " << testName << std::endl;
    em_interface_t interfaces[2]{};
    unsigned int num_interfaces = 2;
    std::cout << "Invoking get_interfaces_list() with limit = 2" << std::endl;
    int ret = dm_easy_mesh_t::get_interfaces_list(interfaces, &num_interfaces);
    EXPECT_EQ(ret, 0);
    EXPECT_LE(num_interfaces, 2u);
    std::cout << "Interfaces returned (limited): " << num_interfaces << std::endl;
    for (unsigned int i = 0; i < num_interfaces; ++i) {
        print_interface(interfaces[i]);
    }
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate that get_interfaces_list returns an error when passed a NULL interfaces pointer.
 *
 * This test verifies that when a NULL pointer is provided as the interfaces argument to
 * dm_easy_mesh_t::get_interfaces_list, the function returns an error (-1). This behavior is
 * critical for ensuring that the API handles invalid pointer inputs appropriately.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 279@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                              | Test Data                                           | Expected Result                                                         | Notes       |
 * | :--------------: | -------------------------------------------------------- | --------------------------------------------------- | ----------------------------------------------------------------------- | ----------- |
 * | 01               | Call get_interfaces_list with a NULL interfaces pointer  | interfaces = NULL, capacity = 5                     | API returns -1 and assertion EXPECT_EQ(ret, -1) is satisfied              | Should Fail |
 */
TEST(dm_easy_mesh_t, get_interfaces_list_invalid_null_interfaces_pointer) {
    std::cout << "Entering get_interfaces_list_invalid_null_interfaces_pointer test" << std::endl;
    dm_easy_mesh_t mesh;
    unsigned int capacity = 5;   
    std::cout << "Invoking get_interfaces_list with NULL interfaces pointer" << std::endl;
    std::cout << "Initial num_interfaces value: " << capacity << std::endl;    
    int ret = dm_easy_mesh_t::get_interfaces_list(NULL, &capacity);   
    std::cout << "Method returned: " << ret << std::endl;
    EXPECT_EQ(ret, -1);    
    std::cout << "Exiting get_interfaces_list_invalid_null_interfaces_pointer test" << std::endl;
}

/**
 * @brief Verifies that get_interfaces_list returns an error when provided with a NULL num_interfaces pointer
 *
 * This test checks that the get_interfaces_list API correctly handles the scenario when the num_interfaces pointer is NULL,
 * ensuring that the function returns the expected error code (-1). This is critical for proper error handling 
 * within the API to prevent invalid memory access.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 280@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                       | Test Data                                                             | Expected Result                                         | Notes      |
 * | :--------------: | ----------------------------------------------------------------- | --------------------------------------------------------------------- | ------------------------------------------------------- | ---------- |
 * | 01               | Invoke get_interfaces_list with a NULL num_interfaces pointer       | interfaces = array of 5 elements, num_interfaces pointer = NULL        | Return value = -1; Assertion EXPECT_EQ(ret, -1)         | Should Fail |
 */
TEST(dm_easy_mesh_t, get_interfaces_list_invalid_null_num_interfaces_pointer) {
    std::cout << "Entering get_interfaces_list_invalid_null_num_interfaces_pointer test" << std::endl;
    dm_easy_mesh_t mesh;
    const unsigned int capacity = 5;
    em_interface_t interfaces[capacity];    
    std::cout << "Invoking get_interfaces_list with NULL num_interfaces pointer" << std::endl;
    std::cout << "Array capacity provided: " << capacity << std::endl;    
    int ret = dm_easy_mesh_t::get_interfaces_list(interfaces, NULL);    
    std::cout << "Method returned: " << ret << std::endl;
    EXPECT_EQ(ret, -1);   
    std::cout << "Exiting get_interfaces_list_invalid_null_num_interfaces_pointer test" << std::endl;
}

/**
 * @brief Test get_manufacturer API returns a valid non-empty manufacturer name
 *
 * This test verifies that the get_manufacturer function returns a valid, non-null pointer when the manufacturer's string is set. It further confirms that the string value returned matches the expected "ValidManufacturerName". This is critical for ensuring that the device's manufacturer information is correctly handled.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 281@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                              | Test Data                                                       | Expected Result                                                                   | Notes       |
 * | :--------------: | ------------------------------------------------------------------------ | --------------------------------------------------------------- | --------------------------------------------------------------------------------- | ----------- |
 * | 01               | Set manufacturer field to "ValidManufacturerName" then invoke get_manufacturer() | manufacturer input = ValidManufacturerName, expected output = ValidManufacturerName | Return value is not nullptr and string equals "ValidManufacturerName" | Should Pass |
 */
TEST(dm_easy_mesh_t, get_manufacturer_valid_non_empty) {
    std::cout << "Entering get_manufacturer_valid_non_empty test" << std::endl;
    dm_easy_mesh_t device;
    memcpy(device.m_device.m_device_info.manufacturer, "ValidManufacturerName", strlen("ValidManufacturerName")+1);
    std::cout << "Invoking method get_manufacturer()" << std::endl;
    char *manufacturer = device.get_manufacturer();
    std::cout << "Returned manufacturer: " << (manufacturer ? manufacturer : "NULL") << std::endl;
    EXPECT_NE(manufacturer, nullptr);
    EXPECT_STREQ(manufacturer, "ValidManufacturerName");
    std::cout << "Exiting get_manufacturer_valid_non_empty test" << std::endl;
}

/**
 * @brief Validate that get_manufacturer() returns an empty string when the manufacturer field is empty
 *
 * This test sets the device manufacturer's field to an empty string and then invokes the get_manufacturer() method.
 * It verifies that the method returns a valid pointer that points to an empty string.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 282@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                         | Test Data                                                        | Expected Result                                                                     | Notes            |
 * | :--------------: | ------------------------------------------------------------------- | ---------------------------------------------------------------- | ----------------------------------------------------------------------------------- | ---------------- |
 * | 01               | Initialize the device manufacturer field to empty string            | device.m_device.m_device_info.manufacturer = ""                   | Manufacturer field is set to an empty string                                          | Should be successful |
 * | 02               | Invoke get_manufacturer() method on the device                      | Input: device object, Output: manufacturer pointer                | Returns a non-null pointer to the manufacturer string                                 | Should Pass      |
 * | 03               | Validate the returned manufacturer value is empty and not null      | Output: manufacturer pointer, Expected: manufacturer = "", not NULL | EXPECT_NE(manufacturer, nullptr) and EXPECT_STREQ(manufacturer, "") checks pass         | Should Pass      |
 */
TEST(dm_easy_mesh_t, get_manufacturer_valid_empty) {
    std::cout << "Entering get_manufacturer_valid_empty test" << std::endl;   
    dm_easy_mesh_t device;
    memcpy(device.m_device.m_device_info.manufacturer, "", strlen("")+1);     
    std::cout << "Invoking method get_manufacturer()" << std::endl;
    char *manufacturer = device.get_manufacturer();
    std::cout << "Returned manufacturer: "  << (manufacturer ? manufacturer : "NULL") << std::endl;    
    EXPECT_NE(manufacturer, nullptr);
    EXPECT_STREQ(manufacturer, "");    
    std::cout << "Exiting get_manufacturer_valid_empty test" << std::endl;
}

/**
 * @brief Validate that get_manufacturer_model() returns the correct manufacturer model when set to a valid value.
 *
 * This test case initializes a dm_easy_mesh_t device with a valid manufacturer model "AcmeModelX". It then calls the get_manufacturer_model() API and verifies that the returned pointer is not NULL and that the string matches "AcmeModelX". This ensures that the manufacturer model retrieval functionality works as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 283@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                 | Test Data                                                  | Expected Result                                                                                                           | Notes         |
 * | :--------------: | ------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize dm_easy_mesh_t device and set manufacturer_model to "AcmeModelX".                  | manufacturer_model = AcmeModelX                            | The device's manufacturer_model field is set to "AcmeModelX".                                                             | Should be successful |
 * | 02               | Invoke get_manufacturer_model() on the device.                                              | No input arguments, output variable model                    | A non-null pointer is returned that points to the manufacturer model string.                                            | Should Pass   |
 * | 03               | Validate that the returned manufacturer model is "AcmeModelX" and not NULL.                   | Returned model pointer, expected string = AcmeModelX         | ASSERT_NE(model, nullptr) and ASSERT_STREQ(model, "AcmeModelX") are successful.                                           | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_manufacturer_model_valid_model) {
    std::cout << "Entering get_manufacturer_model_valid_model test" << std::endl;
    dm_easy_mesh_t device;
    memcpy(device.m_device.m_device_info.manufacturer_model, "AcmeModelX", strlen("AcmeModelX") + 1);    
    std::cout << "Invoking get_manufacturer_model()" << std::endl;
    char *model = device.get_manufacturer_model();
    std::cout << "Returned manufacturer model: " << (model != nullptr ? model : "nullptr") << std::endl;
    ASSERT_NE(model, nullptr);
    ASSERT_STREQ(model, "AcmeModelX");
    std::cout << "Exiting get_manufacturer_model_valid_model test" << std::endl;
}

/**
 * @brief Verify get_manufacturer_model() returns an empty string when manufacturer_model is empty
 *
 * This test validates that the get_manufacturer_model() function correctly returns an empty string when the manufacturer's model string in the device is empty. It ensures that even with an empty manufacturer_model, the function does not return a nullptr and passes the string comparison check.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 284@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                            | Test Data                                                                                              | Expected Result                                                                  | Notes         |
 * | :--------------: | -------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and set manufacturer_model to empty string            | device.m_device.m_device_info.manufacturer_model = ""                                                 | manufacturer_model field is set to an empty string                               | Should be successful |
 * | 02               | Invoke get_manufacturer_model() and validate output                                    | Call: model = device.get_manufacturer_model(), assertion: model != nullptr, model equals ""            | Returns a non-null pointer and the string is empty ("")                          | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_manufacturer_model_empty_model) {
    std::cout << "Entering get_manufacturer_model_empty_model test" << std::endl;
    dm_easy_mesh_t device;
    memcpy(device.m_device.m_device_info.manufacturer_model, "", strlen("") + 1); 
    std::cout << "Invoking get_manufacturer_model()" << std::endl;
    char *model = device.get_manufacturer_model();
    std::cout << "Returned manufacturer model: " << (model != nullptr ? ("\"" + std::string(model) + "\"") : "nullptr") << std::endl;
    ASSERT_NE(model, nullptr);
    ASSERT_STREQ(model, "");
    std::cout << "Exiting get_manufacturer_model_empty_model test" << std::endl;
}

/**
 * @brief Test that get_manufacturer_model handles special characters correctly
 *
 * This test case checks that the get_manufacturer_model function returns a valid pointer and that the manufacturer model string,
 * which includes special characters, is properly stored and retrieved. The test ensures that the API handles special character values as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 285@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                                       | Expected Result                                                                                      | Notes         |
 * | :--------------: | --------------------------------------------------------------------------------------------- | --------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | ------------- |
 * | 01               | Create a dm_easy_mesh_t object and set the manufacturer model with special characters           | manufacturer_model = "Acme-Model@#1"                             | The device object's manufacturer model field is set to "Acme-Model@#1"                               | Should be successful |
 * | 02               | Invoke get_manufacturer_model() and validate that it returns a non-null pointer and the correct string | Input: device instance; Expected output: manufacturer model "Acme-Model@#1" | The API returns a non-null pointer and the retrieved string exactly matches "Acme-Model@#1"; Assertions pass | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_manufacturer_model_special_characters) {
    std::cout << "Entering get_manufacturer_model_special_characters test" << std::endl;
    dm_easy_mesh_t device;
    memcpy(device.m_device.m_device_info.manufacturer_model, "Acme-Model@#1", strlen("Acme-Model@#1") + 1);   
    std::cout << "Invoking get_manufacturer_model()" << std::endl;
    char *model = device.get_manufacturer_model();
    std::cout << "Returned manufacturer model: " << (model != nullptr ? model : "nullptr") << std::endl;
    ASSERT_NE(model, nullptr);
    ASSERT_STREQ(model, "Acme-Model@#1");
    std::cout << "Exiting get_manufacturer_model_special_characters test" << std::endl;
}

/**
 * @brief Verify that the default message ID is properly returned by get_msg_id().
 *
 * This test case verifies that when a dm_easy_mesh_t object is instantiated and its get_msg_id() method is invoked,
 * the returned message ID matches the predefined default value. This ensures that the default initialization of the message ID
 * is correctly implemented.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 286@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                                  | Expected Result                                                                      | Notes        |
 * | :--------------: | --------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------------------------------------------ | ------------ |
 * | 01               | Instantiate dm_easy_mesh_t, invoke get_msg_id() and capture its default value                   | dm_easy_mesh_t instance = default, method call: get_msg_id() | Returned msg_id equals the default value as defined in the implementation            | Should Pass  |
 */
TEST(dm_easy_mesh_t, get_msg_id_default_value)
{
    const char* testName = "get_msg_id_default_value";
    std::cout << "Entering " << testName << std::endl;
    std::cout << "Invoking get_msg_id()" << std::endl;
    dm_easy_mesh_t dm{};
    unsigned short msg_id = dm.get_msg_id();
    std::cout << "Retrieved msg_id: " << msg_id << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate that get_msg_id() returns the correct message id from dm_easy_mesh_t.
 *
 * This test verifies that setting a valid msg_id value in a dm_easy_mesh_t object results in retrieving the same value via get_msg_id(). It ensures that the message id is correctly stored and accessed.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 287@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create an instance of dm_easy_mesh_t, set msg_id to 100, call get_msg_id(), and verify the returned msg_id | dm.msg_id = 100, call get_msg_id(), returned value = msg_id, expected value = 100 | Returned msg_id equals 100 and EXPECT_EQ assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_msg_id_valid_value)
{
    const char* testName = "get_msg_id_valid_value";
    std::cout << "Entering " << testName << std::endl;
	dm_easy_mesh_t dm;
    dm.msg_id = 100;
    std::cout << "Invoking get_msg_id()" << std::endl;
    unsigned short msg_id = dm.get_msg_id();
    std::cout << "Retrieved msg_id: " << msg_id << std::endl;
    EXPECT_EQ(msg_id, 100);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test default network retrieval using get_network() API.
 *
 * This test verifies that the dm_easy_mesh_t instance returns a valid non-null dm_network_t pointer from the get_network() method and that the network information is printed successfully.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 288@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Instantiate dm_easy_mesh_t and invoke get_network() method | dm object = default constructor, call to get_network(), output pointer = uninitialized | Returns a non-null network pointer | Should Pass |
 * | 02 | Validate that the network pointer is not null using an assertion | output pointer from get_network() | ASSERT_NE(network, nullptr) passes | Should Pass |
 * | 03 | Call print_network_info with network's m_net_info pointer | input: network->m_net_info pointer passed to print_network_info() | Network information is printed to console | Should Pass |
 */
TEST(dm_easy_mesh_t, get_network_default)
{
    const char *testName = "get_network_default";
    std::cout << "Entering " << testName << std::endl;
    std::cout << "Invoking get_network()" << std::endl;
    dm_easy_mesh_t dm{};
    dm_network_t *network = dm.get_network();
    ASSERT_NE(network, nullptr);
    // Pass pointer to network info
    print_network_info(&network->m_net_info);
    std::cout << "Retrieved network pointer: " << network << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate network configuration retrieval
 *
 * This test verifies that the get_network() function returns a non-null pointer after the network has been properly configured with valid parameters. The test sets up a dm_easy_mesh_t instance with a specific number of devices, media type, and MAC address, then asserts that the network pointer received is not null.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 289@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Set network parameters and invoke get_network() | dm.m_network.m_net_info.num_of_devices=2, dm.m_network.m_net_info.ctrl_id.media=em_media_type_ieee80211b_24, dm.m_network.m_net_info.ctrl_id.mac={0x11,0x12,0x13,0x15,0x14,0x15} | get_network() returns a valid (non-null) network pointer and ASSERT_NE passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_network_configured)
{
    const char *testName = "get_network_configured";
    std::cout << "Entering " << testName << std::endl;
    std::cout << "Invoking get_network()" << std::endl;
    unsigned char mac[] = {0x11, 0x12, 0x13, 0x15, 0x14, 0x15};
    dm_easy_mesh_t dm;
    dm.m_network.m_net_info.num_of_devices = 2;
    dm.m_network.m_net_info.ctrl_id.media = em_media_type_ieee80211b_24;
    memcpy(dm.m_network.m_net_info.ctrl_id.mac, mac, sizeof(mac));
    dm_network_t *network = dm.get_network();
    ASSERT_NE(network, nullptr);
    // Pass pointer to network info
    print_network_info(&network->m_net_info);
    std::cout << "Retrieved network pointer: " << network << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test to verify the default behavior of get_network_by_ref API.
 *
 * This test verifies that the dm_easy_mesh_t instance returns a valid network reference
 * when get_network_by_ref is invoked. It checks that the API is correctly called and that
 * the associated network information is printed without errors.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 290@n
 * **Priority:** (High) This test is critical to ensure that the network reference retrieval
 * functions as expected in the default configuration@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Print entering test message | testName = "get_network_by_ref_default" | Logs "Entering get_network_by_ref_default" printed | Should be successful |
 * | 02 | Print the API invocation message | No input, just std::cout message "Invoking get_network_by_ref()" | Logs API invocation message printed | Should be successful |
 * | 03 | Instantiate dm_easy_mesh_t object | Creation of dm_easy_mesh_t using default constructor | Instance created successfully | Should be successful |
 * | 04 | Invoke get_network_by_ref API to retrieve network reference | Call: dm.get_network_by_ref() | Returns a valid network reference | Should Pass |
 * | 05 | Print retrieved network reference address | network_ref address obtained from API call | Address printed correctly | Should be successful |
 * | 06 | Call print_network_info with the m_net_info member | Call: print_network_info(&network_ref.m_net_info) | Network information printed without error | Should be successful |
 * | 07 | Print exiting test message | testName = "get_network_by_ref_default" printed with exit message | Logs "Exiting get_network_by_ref_default" printed | Should be successful |
 */
TEST(dm_easy_mesh_t, get_network_by_ref_default)
{
    const char *testName = "get_network_by_ref_default";
    std::cout << "Entering " << testName << std::endl;
    std::cout << "Invoking get_network_by_ref()" << std::endl;
	dm_easy_mesh_t dm{};
    dm_network_t &network_ref = dm.get_network_by_ref();
    std::cout << "Retrieved network reference address: " << &network_ref << std::endl;
    print_network_info(&network_ref.m_net_info);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate that dm.get_network_by_ref() returns a reference to the internal network object.
 *
 * This test verifies that the get_network_by_ref() method of the dm_easy_mesh_t class correctly returns
 * a reference to its internal network (dm.m_network) after proper initialization. This ensures that the
 * internal network structure is accessible for further operations.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 291@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                  | Test Data                                                                                                                                                        | Expected Result                                                                                               | Notes           |
 * | :--------------: | -------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | --------------- |
 * | 01               | Initialize the test by setting the test name and logging the entry message.                  | testName = "get_network_by_ref_configured"                                                                                                                       | "Entering get_network_by_ref_configured" is printed in the console.                                             | Should be successful |
 * | 02               | Setup the dm_easy_mesh_t object with network parameters and log the action of invoking the API.| dm.m_network.m_net_info.num_of_devices = 2, ctrl_id.media = em_media_type_ieee80211b_24, ctrl_id.mac = {0x11,0x12,0x13,0x15,0x14,0x15}                        | dm object is correctly initialized.                                                                          | Should be successful |
 * | 03               | Invoke get_network_by_ref() to retrieve the network reference.                               | API Call: network_ref = dm.get_network_by_ref()                                                                                                                  | Returns the reference of dm.m_network.                                                                      | Should Pass     |
 * | 04               | Log the retrieved network reference address.                                                 | network_ref address printed through std::cout                                                                                                                    | The network reference address is printed.                                                                    | Should be successful |
 * | 05               | Call print_network_info() to print the network configuration details.                        | API Call: print_network_info(&network_ref.m_net_info)                                                                                                              | The network information is printed correctly.                                                                | Should be successful |
 * | 06               | Validate that the returned network reference matches the internal network object using EXPECT_EQ.| EXPECT_EQ(&network_ref, &dm.m_network)                                                                                                                             | EXPECT_EQ passes confirming both addresses are identical.                                                     | Should Pass     |
 * | 07               | Log the exit message for the test.                                                           | testName = "get_network_by_ref_configured" printed as "Exiting get_network_by_ref_configured"                                                                       | "Exiting get_network_by_ref_configured" is printed in the console.                                              | Should be successful |
 */
TEST(dm_easy_mesh_t, get_network_by_ref_configured)
{
    const char *testName = "get_network_by_ref_configured";
    std::cout << "Entering " << testName << std::endl;
    std::cout << "Invoking get_network_by_ref()" << std::endl;
	unsigned char mac[] = {0x11, 0x12, 0x13, 0x15, 0x14, 0x15};
	dm_easy_mesh_t dm;
	dm.m_network.m_net_info.num_of_devices = 2;
	dm.m_network.m_net_info.ctrl_id.media = em_media_type_ieee80211b_24;	
	memcpy(dm.m_network.m_net_info.ctrl_id.mac, mac, sizeof(mac));
    dm_network_t &network_ref = dm.get_network_by_ref();
    std::cout << "Retrieved network reference address: " << &network_ref << std::endl;
	print_network_info(&network_ref.m_net_info);
    EXPECT_EQ(&network_ref, &dm.m_network);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test to verify that get_network_info() returns a valid network info pointer.
 *
 * This test invokes the get_network_info() API, checks that the returned pointer is not nullptr, and prints
 * the network information. It ensures that the API correctly initializes and returns the network info structure.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 292@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                      | Test Data                                                           | Expected Result                                             | Notes            |
 * | :--------------: | ---------------------------------------------------------------- | --------------------------------------------------------------------| ------------------------------------------------------------| ---------------- |
 * | 01               | Log entry into the test function with test name                  | testName = "get_network_info_default"                               | "Entering get_network_info_default" is printed              | Should be successful |
 * | 02               | Log the invocation of get_network_info() API                     | None                                                                | "Invoking get_network_info()" is printed                    | Should be successful |
 * | 03               | Invoke get_network_info() and store the returned pointer         | input: none; output: info pointer expected to be non-null             | info pointer is not nullptr                                  | Should Pass      |
 * | 04               | Assert that the returned pointer is not null                     | Assertion: info != nullptr                                          | Assertion passes confirming info is valid                   | Should Pass      |
 * | 05               | Call print_network_info(info) to print network details             | input: info pointer                                                 | Network information is printed successfully                | Should Pass      |
 * | 06               | Log exit from the test function                                  | testName = "get_network_info_default"                               | "Exiting get_network_info_default" is printed               | Should be successful |
 */
TEST(dm_easy_mesh_t, get_network_info_default)
{
    const char *testName = "get_network_info_default";
    std::cout << "Entering " << testName << std::endl;
    std::cout << "Invoking get_network_info()" << std::endl;
	dm_easy_mesh_t dm{};
    em_network_info_t *info = dm.get_network_info();
    ASSERT_NE(info, nullptr);
    print_network_info(info);    
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Test to verify that get_network_info correctly retrieves the configured network information.
 *
 * This test initializes the network configuration of a dm_easy_mesh_t object with predefined test values,
 * invokes the get_network_info method, and validates that the retrieved network information matches the set values.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 293@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                          | Test Data                                                                                                                                                                | Expected Result                                                 | Notes            |
 * | :--------------: | ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------- | ---------------- |
 * | 01               | Initialize a dm_easy_mesh_t object and configure its network information with predefined test data.   | Create dm_easy_mesh_t object, set cfg.id = "TestNetworkID", cfg.num_of_devices = 5, cfg.timestamp = "2025-01-01T10:00:00Z", set cfg.ctrl_id.name = "eth0", cfg.ctrl_id.media = em_media_type_ieee8023ab, set cfg.media = em_media_type_ieee80211ac_5 | Network configuration is set successfully.                      | Should be successful |
 * | 02               | Invoke the get_network_info API method on the configured object.                                      | Call dm.get_network_info(), no additional input parameters                                                                                                             | Returns a non-null pointer to the network info.                 | Should Pass      |
 * | 03               | Validate the retrieved network info against the configured values using assertions.                   | Compare info->id with "TestNetworkID", info->num_of_devices with 5, and info->media with em_media_type_ieee80211ac_5                                                          | Retrieved network info matches the configured test data.        | Should Pass      |
 */
TEST(dm_easy_mesh_t, get_network_info_configured)
{
    const char *testName = "get_network_info_configured";
    std::cout << "Entering " << testName << std::endl;
	dm_easy_mesh_t dm;
    em_network_info_t &cfg = dm.m_network.m_net_info;
    strncpy(cfg.id, "TestNetworkID", sizeof(cfg.id));
    cfg.num_of_devices = 5;
    strncpy(cfg.timestamp, "2025-01-01T10:00:00Z", sizeof(cfg.timestamp));
    strncpy(cfg.ctrl_id.name, "eth0", sizeof(cfg.ctrl_id.name));
    cfg.ctrl_id.media = em_media_type_ieee8023ab;
    cfg.media = em_media_type_ieee80211ac_5;
    std::cout << "Invoking get_network_info()" << std::endl;
    em_network_info_t *info = dm.get_network_info();
    ASSERT_NE(info, nullptr);
    print_network_info(info);
    EXPECT_STREQ(info->id, "TestNetworkID");
    EXPECT_EQ(info->num_of_devices, 5);
    EXPECT_EQ(info->media, em_media_type_ieee80211ac_5);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verifies that get_network_info returns a valid network information pointer when invoked statically.
 *
 * This test ensures that the static function get_network_info, when provided with a valid dm_easy_mesh_t object, returns a non-null pointer. It validates that the network information is correctly fetched and ready for further processing.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 294@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object | None, dm instance created | dm object is instantiated successfully | Should be successful |
 * | 02 | Invoke get_network_info static method with dm pointer | input: dm_ptr = address of dm; output: info = uninitialized pointer | API returns a valid non-null pointer | Should Pass |
 * | 03 | Validate returned network info pointer | input: info pointer; expected: non-null | ASSERT_NE(info, nullptr) passes confirming valid network info | Should Pass |
 * | 04 | Print the network information to console | input: info pointer; output: printed network info | Network information is printed to standard output | Should be successful |
 */
TEST(dm_easy_mesh_t, get_network_info_static_default)
{
    const char *testName = "get_network_info_static_default";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm;
    std::cout << "Invoking static get_network_info(void*)" << std::endl;
    em_network_info_t *info = dm_easy_mesh_t::get_network_info(&dm);
    ASSERT_NE(info, nullptr);
    print_network_info(info);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_network_info correctly retrieves a static network configuration.
 *
 * This test ensures that the get_network_info API returns a non-null pointer to an em_network_info_t structure,
 * which has been set with a pre-defined static configuration. It sets specific values for network ID, number of devices,
 * timestamp, control interface name, and media types, and then confirms that the retrieval function returns the expected data.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 295
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | ------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t instance and configure network info with static values. | dm.m_network.m_net_info.id = "TestNetworkID", dm.m_network.m_net_info.num_of_devices = 5, dm.m_network.m_net_info.timestamp = "2025-01-01T10:00:00Z", dm.m_network.m_net_info.ctrl_id.name = "eth0", dm.m_network.m_net_info.ctrl_id.media = em_media_type_ieee8023ab, dm.m_network.m_net_info.media = em_media_type_ieee80211ac_5 | dm instance is configured with the static network information. | Should be successful |
 * | 02 | Invoke get_network_info function using the dm instance pointer and validate the result. | input: dm pointer = &dm, output: info pointer expected to be non-null | API returns a non-null pointer and ASSERT_NE(info, nullptr) passes. | Should Pass |
 * | 03 | Call print_network_info to output the network configuration details to the console. | input: info pointer from get_network_info | Network information is printed to the console. | Should be successful |
 */
TEST(dm_easy_mesh_t, get_network_info_static_configured)
{
    const char *testName = "get_network_info_static_configured";
    std::cout << "Entering " << testName << std::endl;
    std::cout << "Invoking static get_network_info(void*)" << std::endl;
	dm_easy_mesh_t dm;
    em_network_info_t &cfg = dm.m_network.m_net_info;
    strncpy(cfg.id, "TestNetworkID", sizeof(cfg.id));
    cfg.num_of_devices = 5;
    strncpy(cfg.timestamp, "2025-01-01T10:00:00Z", sizeof(cfg.timestamp));
    strncpy(cfg.ctrl_id.name, "eth0", sizeof(cfg.ctrl_id.name));
    cfg.ctrl_id.media = em_media_type_ieee8023ab;
    cfg.media = em_media_type_ieee80211ac_5;
    em_network_info_t *info = dm_easy_mesh_t::get_network_info(&dm);
    ASSERT_NE(info, nullptr);
    print_network_info(info);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_network_info returns nullptr when provided with a null input.
 *
 * This test checks that the static method get_network_info correctly handles a null parameter by returning a nullptr.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 296@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                     | Test Data: input = nullptr, output = nullptr; testName = "get_network_info_static_null_dm" | Expected Result: API returns nullptr as asserted by ASSERT_EQ | Notes           |
 * | :--------------: | ---------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | ------------------------------------------------------------- | --------------- |
 * | 01               | Log entering the test case "get_network_info_static_null_dm"      | testName = "get_network_info_static_null_dm"                                              | Expected log message printed                                  | Should be successful |
 * | 02               | Invoke dm_easy_mesh_t::get_network_info with nullptr and assert result | input = nullptr, output = nullptr                                                         | get_network_info returns nullptr; ASSERT_EQ confirms the result | Should Pass     |
 * | 03               | Log exiting the test case "get_network_info_static_null_dm"       | testName = "get_network_info_static_null_dm"                                              | Expected log message printed                                  | Should be successful |
 */
TEST(dm_easy_mesh_t, get_network_info_static_null_dm)
{
    const char *testName = "get_network_info_static_null_dm";
    std::cout << "Entering " << testName << std::endl;
    std::cout << "Invoking static get_network_info(NULL)" << std::endl;
    em_network_info_t *info = dm_easy_mesh_t::get_network_info(nullptr);
    ASSERT_EQ(info, nullptr);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate that the get_network_ssid API returns a valid default SSID structure.
 *
 * This test verifies that invoking get_network_ssid with an index value zero returns 
 * a non-null pointer, ensuring that the default SSID is properly instantiated and can be processed.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 297@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- | -------------- | ----- |
 * | 01 | Log entry message to indicate the start of the test execution | testName = "get_network_ssid_default" | "Entering get_network_ssid_default" message printed to console | Should be successful |
 * | 02 | Log the API invocation message for get_network_ssid | None | "Invoking get_network_ssid(0)" message printed to console | Should be successful |
 * | 03 | Invoke the get_network_ssid API with index 0 to retrieve the default SSID | input: index = 0; output: dm_network_ssid_t pointer | Returns a non-null pointer to the SSID structure | Should Pass |
 * | 04 | Verify that the returned SSID pointer is not null using an assertion check | output: pointer returned from get_network_ssid | Assertion passes confirming the pointer is valid | Should be successful |
 * | 05 | Print the SSID information using the print_ssid_info helper function | input: ssid->m_network_ssid_info | SSID information is printed to the console | Should be successful |
 * | 06 | Log exit message to indicate the end of the test execution | testName = "get_network_ssid_default" | "Exiting get_network_ssid_default" message printed to console | Should be successful |
 */
TEST(dm_easy_mesh_t, get_network_ssid_default)
{
    const char *testName = "get_network_ssid_default";
    std::cout << "Entering " << testName << std::endl;
    std::cout << "Invoking get_network_ssid(0)" << std::endl;
	dm_easy_mesh_t dm;
    dm_network_ssid_t *ssid = dm.get_network_ssid(0);
    ASSERT_NE(ssid, nullptr);
    print_ssid_info(&ssid->m_network_ssid_info);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Tests the get_network_ssid API for out-of-range SSID index.
 *
 * This test verifies that calling get_network_ssid with an index beyond the maximum allowed (EM_MAX_NET_SSIDS + 1) properly returns a null pointer. It ensures that the API handles invalid index scenarios by not providing an access to an unallocated SSID.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 298@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke get_network_ssid with an index beyond the valid range | input: invalid_index = EM_MAX_NET_SSIDS+1, output: ssid pointer | API returns nullptr and the assertion verifies the null pointer | Should Fail |
 */
TEST(dm_easy_mesh_t, get_network_ssid_out_of_range_negative)
{
    const char *testName = "get_network_ssid_out_of_range_negative";
    std::cout << "Entering " << testName << std::endl;
    unsigned int invalid_index = EM_MAX_NET_SSIDS + 1;
    dm_easy_mesh_t dm;
    std::cout << "Invoking get_network_ssid(" << invalid_index << ")" << std::endl;
    dm_network_ssid_t *ssid = dm.get_network_ssid(invalid_index);   
    EXPECT_EQ(ssid, nullptr);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_network_ssid_configured retrieves the correct SSID configuration from the dm_easy_mesh_t instance
 *
 * This test validates that when a dm_easy_mesh_t object is configured with a specific network SSID configuration, 
 * the get_network_ssid function returns the correct network SSID parameters. The test ensures that the SSID string,
 * enable flag, and number of hauls are correctly retrieved, assuring the functionality works as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 299@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                  | Test Data                                                                                                                                                                                                                                                                                       | Expected Result                                                                                                                 | Notes        |
 * | :--------------: | -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------- | ------------ |
 * | 01               | Configure the dm_easy_mesh_t instance with valid SSID configuration parameters                 | dm.m_num_net_ssids = 1, cfg.id = "ssid-001", cfg.ssid = "TestSSID", cfg.pass_phrase = "TestPassword", cfg.enable = true, cfg.advertisement = true, cfg.num_bands = 2, cfg.band[0] = "2.4G", cfg.band[1] = "5G", cfg.num_akms = 1, cfg.akm[0] = "WPA2-PSK", cfg.num_hauls = 2, cfg.haul_type[0] = em_haul_type_fronthaul, cfg.haul_type[1] = em_haul_type_backhaul | Instance configured successfully; configuration values set as specified                          | Should be successful |
 * | 02               | Invoke get_network_ssid with index 0 and validate the returned SSID configuration against expected values | API Call: dm.get_network_ssid(0); Expected output: ssid->m_network_ssid_info.ssid = "TestSSID", ssid->m_network_ssid_info.enable = true, ssid->m_network_ssid_info.num_hauls = 2                                                                                                               | API returns a non-null pointer with correct SSID ("TestSSID"), enable flag as true, and num_hauls equal to 2 | Should Pass  |
 */
TEST(dm_easy_mesh_t, get_network_ssid_configured)
{
    const char *testName = "get_network_ssid_configured";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm{};
    dm.m_num_net_ssids = 1;
    // Configure SSID[0]
    em_network_ssid_info_t &cfg = dm.m_network_ssid[0].m_network_ssid_info;
    strncpy(cfg.id, "ssid-001", sizeof(cfg.id));
    strncpy(cfg.ssid, "TestSSID", sizeof(cfg.ssid));
    strncpy(cfg.pass_phrase, "TestPassword", sizeof(cfg.pass_phrase));
    cfg.enable = true;
    cfg.advertisement = true;
    cfg.num_bands = 2;
    strncpy(cfg.band[0], "2.4G", sizeof(cfg.band[0]));
    strncpy(cfg.band[1], "5G", sizeof(cfg.band[1]));
    cfg.num_akms = 1;
    strncpy(cfg.akm[0], "WPA2-PSK", sizeof(cfg.akm[0]));
    cfg.num_hauls = 2;
    cfg.haul_type[0] = em_haul_type_fronthaul;
    cfg.haul_type[1] = em_haul_type_backhaul;
    std::cout << "Invoking get_network_ssid(0)" << std::endl;
    dm_network_ssid_t *ssid = dm.get_network_ssid(0);
    ASSERT_NE(ssid, nullptr);
    print_ssid_info(&ssid->m_network_ssid_info);
    EXPECT_STREQ(ssid->m_network_ssid_info.ssid, "TestSSID");
    EXPECT_EQ(ssid->m_network_ssid_info.enable, true);
    EXPECT_EQ(ssid->m_network_ssid_info.num_hauls, 2);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_network_ssid_by_ref returns a valid reference for the default SSID.
 *
 * This test case validates that invoking get_network_ssid_by_ref with index 0 on a dm_easy_mesh_t instance
 * returns a reference that correctly corresponds to the first element in the dm.m_network_ssid array.
 * Additionally, the test prints the SSID information using the print_ssid_info helper function to ensure that
 * the related SSID info structure is properly populated.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 300@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                 | Test Data                                                   | Expected Result                                                         | Notes         |
 * | :--------------: | ------------------------------------------------------------------------------------------- | ----------------------------------------------------------- | ----------------------------------------------------------------------- | ------------- |
 * | 01               | Invoke get_network_ssid_by_ref with index=0 on a dm_easy_mesh_t instance                      | input: index = 0                                            | Returns a valid reference to the SSID at dm.m_network_ssid[0]             | Should Pass   |
 * | 02               | Validate that the returned reference's address matches dm.m_network_ssid[0]                   | input: address of returned reference, dm.m_network_ssid[0] address | Addresses match, confirming correct reference retrieval                | Should Pass   |
 * | 03               | Call print_ssid_info to display SSID information from the returned reference                | input: ssid_ref.m_network_ssid_info                           | SSID information printed successfully to stdout                          | Should be successful |
 */
TEST(dm_easy_mesh_t, get_network_ssid_by_ref_default)
{
    const char *testName = "get_network_ssid_by_ref_default";
    std::cout << "Entering " << testName << std::endl;
    std::cout << "Invoking get_network_ssid_by_ref(0)" << std::endl;
    dm_easy_mesh_t dm;
    dm_network_ssid_t &ssid_ref = dm.get_network_ssid_by_ref(0);
    std::cout << "SSID ref address: " << &ssid_ref << std::endl;
    EXPECT_EQ(&ssid_ref, &dm.m_network_ssid[0]);
    print_ssid_info(&ssid_ref.m_network_ssid_info);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate the retrieval of network SSID configuration via get_network_ssid_by_ref
 *
 * This test verifies that get_network_ssid_by_ref correctly returns the network SSID reference from a properly configured instance of dm_easy_mesh_t. It confirms that the returned SSID and haul type match the expected values as set in the test configuration.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 301@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | ------------- | ----- |
 * | 01 | Configure dm_easy_mesh_t with valid network SSID information and invoke get_network_ssid_by_ref(0) | index = 0, m_num_net_ssids = 1, id = "ssid-002", ssid = "BackhaulSSID", pass_phrase = "BackhaulPass", enable = true, advertisement = false, num_bands = 1, band[0] = "5G", num_akms = 1, akm[0] = "WPA3-SAE", num_hauls = 1, haul_type[0] = em_haul_type_backhaul | Returns a valid reference with ssid equal to "BackhaulSSID" and haul_type equal to em_haul_type_backhaul | Should Pass |
 */
TEST(dm_easy_mesh_t, get_network_ssid_by_ref_configured)
{
    const char *testName = "get_network_ssid_by_ref_configured";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm{};
    dm.m_num_net_ssids = 1;
    em_network_ssid_info_t &cfg = dm.m_network_ssid[0].m_network_ssid_info;
    strncpy(cfg.id, "ssid-002", sizeof(cfg.id));
    strncpy(cfg.ssid, "BackhaulSSID", sizeof(cfg.ssid));
    strncpy(cfg.pass_phrase, "BackhaulPass", sizeof(cfg.pass_phrase));
    cfg.enable = true;
    cfg.advertisement = false;
    cfg.num_bands = 1;
    strncpy(cfg.band[0], "5G", sizeof(cfg.band[0]));
    cfg.num_akms = 1;
    strncpy(cfg.akm[0], "WPA3-SAE", sizeof(cfg.akm[0]));
    cfg.num_hauls = 1;
    cfg.haul_type[0] = em_haul_type_backhaul;
    std::cout << "Invoking get_network_ssid_by_ref(0)" << std::endl;
    dm_network_ssid_t &ssid_ref = dm.get_network_ssid_by_ref(0);
    // Pass pointer
    print_ssid_info(&ssid_ref.m_network_ssid_info);
    EXPECT_STREQ(ssid_ref.m_network_ssid_info.ssid, "BackhaulSSID");
    EXPECT_EQ(ssid_ref.m_network_ssid_info.haul_type[0], em_haul_type_backhaul);
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate that get_network_ssid_info_by_haul_type returns the correct network SSID info for a given haul type.
 *
 * This test verifies that the API get_network_ssid_info_by_haul_type correctly identifies and returns the network SSID information corresponding to the specified haul type (backhaul in this case). The test sets up two network SSIDs with different haul types, invokes the API with the backhaul parameter, and checks that the returned pointer is not null and the SSID string matches the expected "BackHaulSSID".
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 302@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                                                                                                                                               | Expected Result                                                                     | Notes         |
 * | :--------------: | --------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ | ------------- |
 * | 01               | Initialize dm_easy_mesh_t object.                                                             | None                                                                                                                                                                    | dm_easy_mesh_t object is created successfully.                                      | Should be successful |
 * | 02               | Set the number of network SSIDs to 2.                                                         | m_num_net_ssids = 2                                                                                                                                                     | m_num_net_ssids is correctly set to 2.                                               | Should be successful |
 * | 03               | Configure the first SSID entry for front-haul.                                                | Index 0: ssid = "FrontHaulSSID", enable = true, num_hauls = 1, haul_type[0] = em_haul_type_fronthaul                                                                   | Front-haul SSID details are set correctly in dm.m_network_ssid[0].                     | Should be successful |
 * | 04               | Configure the second SSID entry for back-haul.                                                | Index 1: ssid = "BackHaulSSID", enable = true, num_hauls = 1, haul_type[0] = em_haul_type_backhaul                                                                   | Back-haul SSID details are set correctly in dm.m_network_ssid[1].                      | Should be successful |
 * | 05               | Invoke get_network_ssid_info_by_haul_type with backhaul parameter to get corresponding SSID info.| Input: haul_type = em_haul_type_backhaul                                                                                                                                | API returns a non-null pointer to the back-haul SSID information.                      | Should Pass  |
 * | 06               | Verify that the returned network SSID info has the expected SSID string "BackHaulSSID".         | Output from API: info->ssid, Expected: "BackHaulSSID"                                                                                                                  | info->ssid is "BackHaulSSID" and assertion passes.                                   | Should Pass  |
 */
TEST(dm_easy_mesh_t, get_network_ssid_info_by_haul_type_positive)
{
    const char *testName = "get_network_ssid_info_by_haul_type_positive";
    std::cout << "Entering " << testName << std::endl;
	dm_easy_mesh_t dm{};
    dm.m_num_net_ssids = 2;
    em_network_ssid_info_t &info0 = dm.m_network_ssid[0].m_network_ssid_info;
    strncpy(info0.ssid, "FrontHaulSSID", sizeof(info0.ssid));
    info0.enable = true;
    info0.num_hauls = 1;
    info0.haul_type[0] = em_haul_type_fronthaul;
    em_network_ssid_info_t &info1 = dm.m_network_ssid[1].m_network_ssid_info;
    strncpy(info1.ssid, "BackHaulSSID", sizeof(info1.ssid));
    info1.enable = true;
    info1.num_hauls = 1;
    info1.haul_type[0] = em_haul_type_backhaul;
    std::cout << "Invoking get_network_ssid_info_by_haul_type(backhaul)" << std::endl;
    em_network_ssid_info_t *info = dm.get_network_ssid_info_by_haul_type(em_haul_type_backhaul);
    ASSERT_NE(info, nullptr);
    print_ssid_info(info);
    EXPECT_STREQ(info->ssid, "BackHaulSSID");
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Verify that get_network_ssid_info_by_haul_type returns nullptr when no network SSIDs are available
 *
 * This test initializes a dm_easy_mesh_t instance with zero network SSIDs and calls get_network_ssid_info_by_haul_type with the fronthaul parameter.
 * It verifies that, in the absence of network SSIDs, the API returns a nullptr.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 303@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                | Test Data                                                        | Expected Result                                                           | Notes               |
 * | :--------------: | -------------------------------------------------------------------------- | ---------------------------------------------------------------- | ------------------------------------------------------------------------- | ------------------- |
 * | 01               | Create dm_easy_mesh_t instance and set m_num_net_ssids to 0                | dm.m_num_net_ssids = 0                                             | Instance created with m_num_net_ssids set to 0                            | Should be successful|
 * | 02               | Invoke get_network_ssid_info_by_haul_type with em_haul_type_fronthaul         | input: haulType = em_haul_type_fronthaul, object: dm, output: info   | API returns a nullptr indicating no network SSIDs available               | Should Fail         |
 * | 03               | Validate that the returned pointer is nullptr using EXPECT_EQ              | output: info = nullptr, assertion: EXPECT_EQ(info, nullptr)         | The returned pointer is nullptr as expected                               | Should be successful|
 */
TEST(dm_easy_mesh_t, get_network_ssid_info_no_ssids_negative)
{
    const char *testName = "get_network_ssid_info_no_ssids_negative";
    std::cout << "Entering " << testName << std::endl;
    dm_easy_mesh_t dm{};
    dm.m_num_net_ssids = 0;
    std::cout << "Invoking get_network_ssid_info_by_haul_type(fronthaul)" << std::endl;
    em_network_ssid_info_t *info = dm.get_network_ssid_info_by_haul_type(em_haul_type_fronthaul);
    EXPECT_EQ(info, nullptr);
    std::cout << "Returned NULL as expected" << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate that get_network_ssid_info_by_haul_type returns NULL when an invalid haul type is provided
 *
 * This test verifies that calling get_network_ssid_info_by_haul_type with an invalid haul type (an out of range value)
 * returns a null pointer. This ensures that the method correctly handles invalid input, thereby preventing potential misuse.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 304@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                              | Test Data                                                                                                                                                              | Expected Result                                          | Notes        |
 * | :--------------: | ------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------- | ------------ |
 * | 01               | Invoke get_network_ssid_info_by_haul_type() with an invalid haul type       | dm.m_num_net_ssids = 1, ssid = "TestSSID", info.num_hauls = 1, info.haul_type[0] = em_haul_type_fronthaul, invalid haul type = 999, expected output = nullptr       | API returns nullptr; assertion EXPECT_EQ(ret, nullptr)   | Should Pass  |
 */
TEST(dm_easy_mesh_t, get_network_ssid_info_invalid_haul_type)
{
    const char *testName = "get_network_ssid_info_invalid_haul_type";
    std::cout << "Entering " << testName << std::endl;
	dm_easy_mesh_t dm{};
    dm.m_num_net_ssids = 1;
    em_network_ssid_info_t &info = dm.m_network_ssid[0].m_network_ssid_info;
    strncpy(info.ssid, "TestSSID", sizeof(info.ssid));
    info.num_hauls = 1;
    info.haul_type[0] = em_haul_type_fronthaul;
    em_haul_type_t invalid = static_cast<em_haul_type_t>(999);
    std::cout << "Invoking get_network_ssid_info_by_haul_type(invalid)" << std::endl;
    em_network_ssid_info_t *ret = dm.get_network_ssid_info_by_haul_type(invalid);
    EXPECT_EQ(ret, nullptr);
    std::cout << "Returned NULL for invalid haul type" << std::endl;
    std::cout << "Exiting " << testName << std::endl;
}

/**
 * @brief Validate retrieval of next station information for stations with identical STA MAC
 *
 * This test verifies that when multiple station entries with the same STA MAC address but different BSSID values are added, the get_next_sta API correctly returns the subsequent station after the first one retrieved. It ensures that the returned next station is not the same as the first one and that it contains the correct STA MAC address.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 305@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize mesh, add two station info with same STA MAC but different BSSIDs, and retrieve first and next station info | input: sta = {0x00,0x11,0x22,0x33,0x44,0x01}, bssid1 = {0xaa,0xbb,0xcc,0xdd,0xee,0x01}, bssid2 = {0xaa,0xbb,0xcc,0xdd,0xee,0x02}, radio = {0xaa,0xbb,0xcc,0xdd,0xee,0x03} | get_first_sta returns non-null; get_next_sta returns non-null; first and next stations are distinct; next station's id equals the input sta MAC | Should Pass |
 */
TEST(dm_easy_mesh_t, get_next_sta_ValidNextSta)
{
    std::cout << "Entering get_next_sta_ValidNextSta test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    // SAME STA MAC
    mac_address_t sta   = {0x00,0x11,0x22,0x33,0x44,0x01};
    // Different BSSIDs (or radios)
    mac_address_t bssid1 = {0xaa,0xbb,0xcc,0xdd,0xee,0x01};
    mac_address_t bssid2 = {0xaa,0xbb,0xcc,0xdd,0xee,0x02};
    mac_address_t radio  = {0xaa,0xbb,0xcc,0xdd,0xee,0x03};
    em_sta_info_t info1 = create_sta_info(sta, bssid1, radio);
    em_sta_info_t info2 = create_sta_info(sta, bssid2, radio);
    mesh.put_sta_info(&info1, em_target_sta_map_consolidated);
    mesh.put_sta_info(&info2, em_target_sta_map_consolidated);
    dm_sta_t *first = mesh.get_first_sta(sta);
    ASSERT_NE(first, nullptr);
    dm_sta_t *next = mesh.get_next_sta(sta, first);
    ASSERT_NE(next, nullptr);
    EXPECT_NE(first, next);
    EXPECT_EQ(memcmp(next->m_sta_info.id, sta, sizeof(mac_address_t)), 0);
    mesh.deinit();
    std::cout << "Exiting get_next_sta_ValidNextSta test" << std::endl;
}

/**
 * @brief Verifies that get_next_sta returns the next valid station for a given STA MAC when multiple matching MAC entries are present.
 *
 * This test case checks the correct functionality of the get_next_sta API by inserting two station records with the same STA MAC address but with different BSSID and radio values. It first retrieves the initial station record using get_first_sta and then calls get_next_sta to verify that it returns the second distinct station record corresponding to the same STA MAC.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 306@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize mesh and insert two STA information records with same STA MAC but different BSSID and radio values. | sta = {0x00,0x11,0x22,0x33,0x44,0x01}, bssid1 = {0xaa,0xbb,0xcc,0xdd,0xee,0x01}, radio1 = {0xaa,0xbb,0xcc,0xdd,0xee,0x02}, bssid2 = {0xaa,0xbb,0xcc,0xdd,0xee,0x02}, radio2 = {0xaa,0xbb,0xcc,0xdd,0xee,0x03} | Mesh initialized and both STA records successfully inserted. | Should be successful |
 * | 02 | Retrieve the first STA record using get_first_sta API. | Input: sta = {0x00,0x11,0x22,0x33,0x44,0x01} | Returns a non-null pointer representing the first STA record. | Should Pass |
 * | 03 | Retrieve the next STA record using get_next_sta API and validate it is different from the first record. | Inputs: sta = {0x00,0x11,0x22,0x33,0x44,0x01}, first pointer returned from get_first_sta | Returns a non-null pointer that is different from the first record and has a matching STA MAC. | Should Pass |
 */
TEST(dm_easy_mesh_t, get_next_sta_MultipleMatchingMacs)
{
    std::cout << "Entering get_next_sta_MultipleMatchingMacs test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    // Same STA MAC
    mac_address_t sta   = {0x00,0x11,0x22,0x33,0x44,0x01};
    // Different BSSID / Radio
    mac_address_t bssid1 = {0xaa,0xbb,0xcc,0xdd,0xee,0x01};
    mac_address_t bssid2 = {0xaa,0xbb,0xcc,0xdd,0xee,0x02};
    mac_address_t radio1 = {0xaa,0xbb,0xcc,0xdd,0xee,0x02};
    mac_address_t radio2 = {0xaa,0xbb,0xcc,0xdd,0xee,0x03};
    em_sta_info_t info1 = create_sta_info(sta, bssid1, radio1);
    em_sta_info_t info2 = create_sta_info(sta, bssid2, radio2);
    mesh.put_sta_info(&info1, em_target_sta_map_consolidated);
    mesh.put_sta_info(&info2, em_target_sta_map_consolidated);
    dm_sta_t *first = mesh.get_first_sta(sta);
    print_sta("First", first);
    ASSERT_NE(first, nullptr);
    std::cout << "Invoking get_next_sta(sta, first)" << std::endl;
    dm_sta_t *next = mesh.get_next_sta(sta, first);
    print_sta("Next", next);
    ASSERT_NE(next, nullptr);
    EXPECT_NE(first, next);
    EXPECT_EQ(memcmp(next->m_sta_info.id, sta, sizeof(mac_address_t)), 0);
    mesh.deinit();
    std::cout << "Exiting get_next_sta_MultipleMatchingMacs test" << std::endl;
}

/**
 * @brief Verify that get_next_sta returns a nullptr when provided a valid station address and a null pointer as the second argument.
 *
 * This test initializes an instance of dm_easy_mesh_t, adds a station information structure to the internal mapping using put_sta_info, and then invokes get_next_sta with a valid station (sta) and a nullptr for the second parameter. The objective is to ensure the API gracefully handles a null pointer for the second argument by returning a nullptr. This behavior is critical for robust API handling in cases where optional output parameters are not provided.@n
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 307@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- | -------------- | ----- |
 * | 01 | Initialize the mesh instance and add station information. | mesh.init(), sta = {0x00,0x11,0x22,0x33,0x44,0x01}, bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0x01}, radio = {0xaa,0xbb,0xcc,0xdd,0xee,0x02}; API: put_sta_info(&info, em_target_sta_map_disassoc) | The station info is successfully added to the mesh and the internal mapping is updated. | Should be successful |
 * | 02 | Invoke get_next_sta with a valid station and a nullptr for the pointer argument. | input: sta = {0x00,0x11,0x22,0x33,0x44,0x01}, second parameter = nullptr; API: get_next_sta(sta, nullptr); output: dm_sta_t* next | The API returns a nullptr, and the assertion EXPECT_EQ(next, nullptr) passes. | Should Pass |
 */
TEST(dm_easy_mesh_t, get_next_sta_NullPsta)
{
    std::cout << "Entering get_next_sta_NullPsta test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t sta   = {0x00,0x11,0x22,0x33,0x44,0x01};
    mac_address_t bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0x01};
    mac_address_t radio = {0xaa,0xbb,0xcc,0xdd,0xee,0x02};
    em_sta_info_t info = create_sta_info(sta, bssid, radio);
    mesh.put_sta_info(&info, em_target_sta_map_disassoc);
    std::cout << "Invoking get_next_sta(sta, NULL)" << std::endl;
    dm_sta_t *next = mesh.get_next_sta(sta, nullptr);
    print_sta("Next", next);
    EXPECT_EQ(next, nullptr);
    mesh.deinit();
    std::cout << "Exiting get_next_sta_NullPsta test" << std::endl;
}

/**
 * @brief Verify that get_next_sta returns nullptr when there is no next station after the last station
 *
 * This test case verifies that when only one station exists in the mesh, invoking get_next_sta with that station
 * (acting as both the station and the first station) returns nullptr, ensuring the API correctly handles the end-of-list scenario.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 308@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize mesh and station details, then create station info. | mesh.init(), sta = {0x00,0x11,0x22,0x33,0x44,0x01}, bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0x01}, radio = {0xaa,0xbb,0xcc,0xdd,0xee,0x02} | Mesh object initialized and station info created. | Should be successful |
 * | 02 | Insert station info into the mesh using put_sta_info API. | info pointer, target = em_target_sta_map_disassoc | Station info inserted successfully. | Should Pass |
 * | 03 | Retrieve the first station using get_first_sta API. | sta = {0x00,0x11,0x22,0x33,0x44,0x01} | Returns pointer to the first station record. | Should Pass |
 * | 04 | Invoke get_next_sta API to get the next station after the first station. | station: {0x00,0x11,0x22,0x33,0x44,0x01}, first pointer from previous step | Returns nullptr since there is no next station. | Should Pass |
 */
TEST(dm_easy_mesh_t, get_next_sta_LastSta)
{
    std::cout << "Entering get_next_sta_LastSta test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t sta   = {0x00,0x11,0x22,0x33,0x44,0x01};
    mac_address_t bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0x01};
    mac_address_t radio = {0xaa,0xbb,0xcc,0xdd,0xee,0x02};
    em_sta_info_t info = create_sta_info(sta, bssid, radio);
    mesh.put_sta_info(&info, em_target_sta_map_disassoc);
    dm_sta_t *first = mesh.get_first_sta(sta);
    print_sta("Only STA", first);
    std::cout << "Invoking get_next_sta(sta, first)" << std::endl;
    dm_sta_t *next = mesh.get_next_sta(sta, first);
    print_sta("Next", next);
    EXPECT_EQ(next, nullptr);
    mesh.deinit();
    std::cout << "Exiting get_next_sta_LastSta test" << std::endl;
}

/**
 * @brief Verify that get_next_sta returns nullptr when the specified station MAC is not found.
 *
 * This test creates a dm_easy_mesh_t instance and adds a station with MAC address sta1. It then attempts to retrieve the next station for a non-existent MAC address sta2 starting from the first station in the list. The expected behavior is that get_next_sta returns a nullptr since the station with MAC sta2 does not exist in the mesh.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 309@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t instance, create sta1 info, and insert it into the mesh | mesh.init(), sta1 = {0x00,0x11,0x22,0x33,0x44,0x01}, bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0x01}, radio = {0xaa,0xbb,0xcc,0xdd,0xee,0x02}, info created using create_sta_info | Station information for sta1 is added successfully | Should be successful |
 * | 02 | Retrieve the first station using get_first_sta with sta1 as input | input: sta1 = {0x00,0x11,0x22,0x33,0x44,0x01} | Returns a valid dm_sta_t pointer (first) | Should Pass |
 * | 03 | Invoke get_next_sta with sta2 (non-existent) and the first station pointer | input: sta2 = {0x00,0x11,0x22,0x33,0x44,0x99}, first = pointer returned from get_first_sta | Returns nullptr as the requested station MAC is not found | Should Pass |
 */
TEST(dm_easy_mesh_t, get_next_sta_MacNotFound)
{
    std::cout << "Entering get_next_sta_MacNotFound test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t sta1  = {0x00,0x11,0x22,0x33,0x44,0x01};
    mac_address_t sta2  = {0x00,0x11,0x22,0x33,0x44,0x99};
    mac_address_t bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0x01};
    mac_address_t radio = {0xaa,0xbb,0xcc,0xdd,0xee,0x02};
    em_sta_info_t info = create_sta_info(sta1, bssid, radio);
    mesh.put_sta_info(&info, em_target_sta_map_disassoc);
    dm_sta_t *first = mesh.get_first_sta(sta1);
    std::cout << "Invoking get_next_sta(sta2, first)" << std::endl;
    dm_sta_t *next = mesh.get_next_sta(sta2, first);
    print_sta("Next", next);
    EXPECT_EQ(next, nullptr);
    mesh.deinit();
    std::cout << "Exiting get_next_sta_MacNotFound test" << std::endl;
}

/**
 * @brief Validate that get_next_sta returns nullptr when the STA map is empty
 *
 * This test verifies that when the get_next_sta function is called with a valid STA and a NULL pointer for the STA map,
 * the function correctly returns a nullptr indicating that no valid next STA is available. It ensures that the API behaves
 * as expected in scenarios where no STA is present in the mesh.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 310@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize the dm_easy_mesh_t object by calling init() | mesh object: instance of dm_easy_mesh_t, no input parameters for init() | Mesh initialized successfully | Should be successful |
 * | 02 | Setup the STA address for testing | sta = 0x00,0x11,0x22,0x33,0x44,0x01 | STA address is configured | Should be successful |
 * | 03 | Invoke get_next_sta with the configured STA and a NULL STA map | call: get_next_sta(sta, NULL), input: sta = 0x00,0x11,0x22,0x33,0x44,0x01, second parameter = nullptr | API returns nullptr indicating no next STA | Should Pass |
 * | 04 | Verify the result using EXPECT_EQ to compare the returned pointer with nullptr | output: next pointer returned by get_next_sta | The pointer next is nullptr and assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_next_sta_EmptyStaMap)
{
    std::cout << "Entering get_next_sta_EmptyStaMap test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t sta = {0x00,0x11,0x22,0x33,0x44,0x01};
    std::cout << "Invoking get_next_sta(sta, NULL)" << std::endl;
    dm_sta_t *next = mesh.get_next_sta(sta, nullptr);
    print_sta("Next", next);
    EXPECT_EQ(next, nullptr);
    mesh.deinit();
    std::cout << "Exiting get_next_sta_EmptyStaMap test" << std::endl;
}

/**
 * @brief Verifies proper functionality of the assignment operator for dm_easy_mesh_t objects
 *
 * This test creates two dm_easy_mesh_t objects (source and destination) and initializes them. It sets specific member values in the
 * source object and invokes the put_sta_info method to add station information. The assignment operator is then used to copy
 * the state from the source object to the destination object. Finally, the test asserts that the destination object's state matches
 * the source object's state.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 311@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t objects and set member values for source object. | src.m_num_radios = 1, src.m_num_bss = 1, src.m_bss[0].m_bss_info.vap_index = 42 | Source object is initialized with expected values; destination object is also initialized. | Should be successful |
 * | 02 | Invoke put_sta_info to add station information to the source object. | Call: src.put_sta_info(&sta, em_target_sta_map_consolidated), where sta is set with memset(&sta, 0x11, sizeof(sta)) | Station information is added to the source object; internal station map updated. | Should be successful |
 * | 03 | Invoke the assignment operator to copy state from source to destination. | Operation: dst = src | Destination object becomes a copy of source object with matching values. | Should Pass |
 * | 04 | Assert that the copied values match between source and destination objects. | Validations: dst.m_num_radios equals src.m_num_radios, dst.m_num_bss equals src.m_num_bss, dst.m_bss[0].m_bss_info.vap_index equals 42, hash_map_get_first(dst.m_sta_map) is not nullptr | EXPECT_EQ and EXPECT_NE assertions pass confirming proper copy of state. | Should Pass |
 */
TEST(dm_easy_mesh_t, Positive_AssignmentOperator) {
    std::cout << "Entering Positive_AssignmentOperator test\n";
    dm_easy_mesh_t src{}, dst{};
    src.init();
    dst.init();
    src.m_num_radios = 1;
    src.m_num_bss = 1;
    src.m_bss[0].m_bss_info.vap_index = 42;
    em_sta_info_t sta{};
    memset(&sta, 0x11, sizeof(sta));
    src.put_sta_info(&sta, em_target_sta_map_consolidated);
    std::cout << "Invoking operator=\n";
    dst = src;
    std::cout << "Source m_num_radios=" << src.m_num_radios << "\n";
    std::cout << "Dest   m_num_radios=" << dst.m_num_radios << "\n";
    std::cout << "Source vap_index=" << src.m_bss[0].m_bss_info.vap_index << "\n";
    std::cout << "Dest   vap_index=" << dst.m_bss[0].m_bss_info.vap_index << "\n";
    EXPECT_EQ(dst.m_num_radios, src.m_num_radios);
    EXPECT_EQ(dst.m_num_bss, src.m_num_bss);
    EXPECT_EQ(dst.m_bss[0].m_bss_info.vap_index, 42);
    EXPECT_NE(hash_map_get_first(dst.m_sta_map), nullptr);
    src.deinit();
    dst.deinit();
    std::cout << "Exiting Positive_AssignmentOperator test\n";
}

/**
 * @brief Validate that the assignment operator creates unique DM state objects.
 *
 * This test verifies that when one dm_easy_mesh_t object (source) containing a station entry is assigned to another (destination),
 * the copied station information in the destination is a separate instance from the source's station entry. This ensures that no shared
 * state exists between the objects after assignment.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 312@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize source and destination dm_easy_mesh_t objects and call init() on both | No input parameters; src and dst objects are default constructed and initialized | Both src and dst are properly initialized with valid internal states | Should be successful |
 * | 02 | Populate source object with a station info by invoking put_sta_info with a filled em_sta_info_t structure | Input: sta structure (filled using memset with 0x22), target = em_target_sta_map_consolidated; Output: source object's m_sta_map updated | The source object should have the station info correctly added to its m_sta_map | Should Pass |
 * | 03 | Invoke the assignment operator to assign source object to destination object | Input: src (with populated station info); Operation: dst = src; Output: dst updated with a copy of srcs state | The destination object should contain a station info copied from src but in a separate memory instance | Should Pass |
 * | 04 | Retrieve station pointers from source and destination objects using hash_map_get_first | Input: m_sta_map from src and dst; Output: pointers src_sta and dst_sta retrieved respectively | Both pointers (src_sta, dst_sta) must be non-null and should not reference the same memory location | Should Pass |
 * | 05 | Assert that the retrieved station pointers are valid and unique using EXPECT_NE macros | Input: src_sta, dst_sta; Output: Verification using EXPECT_NE for non-null and distinct pointers | Both pointers must be non-null and distinct, confirming that assignment did not share the station object | Should Pass |
 */
TEST(dm_easy_mesh_t, Negative_Assignment_NoSharedStaObjects) {
    std::cout << "Entering Negative_Assignment_NoSharedStaObjects test\n";
    dm_easy_mesh_t src{}, dst{};
    src.init();
    dst.init();
    em_sta_info_t sta{};
    memset(&sta, 0x22, sizeof(sta));
    src.put_sta_info(&sta, em_target_sta_map_consolidated);
    std::cout << "Invoking operator=\n";
    dst = src;
    dm_sta_t *src_sta =
        static_cast<dm_sta_t*>(hash_map_get_first(src.m_sta_map));
    dm_sta_t *dst_sta =
        static_cast<dm_sta_t*>(hash_map_get_first(dst.m_sta_map));
    std::cout << "Source STA present=" << (src_sta != nullptr) << "\n";
    std::cout << "Dest   STA present=" << (dst_sta != nullptr) << "\n";
    EXPECT_NE(src_sta, nullptr);
    EXPECT_NE(dst_sta, nullptr);
    EXPECT_NE(src_sta, dst_sta);
    src.deinit();
    dst.deinit();
    std::cout << "Exiting Negative_Assignment_NoSharedStaObjects test\n";
}

/**
 * @brief Verify that get_next_sta_info returns nullptr when the station information is not found.
 *
 * This test verifies that when a station information object that does not exist in the mesh is provided,
 * the get_next_sta_info API returns a nullptr. It ensures that the API correctly handles cases where the
 * requested station information is absent.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 313@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize mesh, create station information using specified MAC addresses, invoke get_next_sta_info with association target, and verify the response. | input: sta = {0x20,0x11,0x22,0x33,0x44,0x01}, bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0x01}, radio = {0xaa,0xbb,0xcc,0xdd,0xee,0x02}, target = em_target_sta_map_assoc; output: next pointer = ? | The API should return nullptr, confirmed by EXPECT_EQ(next, nullptr) | Should Pass |
 */
TEST(dm_easy_mesh_t, InfoNotFound)
{
    std::cout << "Entering InfoNotFound test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t sta   = {0x20,0x11,0x22,0x33,0x44,0x01};
    mac_address_t bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0x01};
    mac_address_t radio = {0xaa,0xbb,0xcc,0xdd,0xee,0x02};
    em_sta_info_t info = create_sta_info(sta, bssid, radio);
    std::cout << "Invoking get_next_sta_info(&info, em_target_sta_map_assoc)" << std::endl;
    em_sta_info_t *next = mesh.get_next_sta_info(&info, em_target_sta_map_assoc);
    print_sta_info("Next", next);
    EXPECT_EQ(next, nullptr);
    mesh.deinit();
    std::cout << "Exiting InfoNotFound test" << std::endl;
}

/**
 * @brief Validate get_next_sta_info behavior for last station info retrieval
 *
 * This test verifies that when the last station information is processed using get_next_sta_info, the API correctly returns a nullptr. It ensures that the mesh instance handles the end-of-list scenario properly by returning a null pointer after the last inserted station info.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 314@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize mesh and station info data including station, BSSID, and radio addresses; create the sta_info structure | mesh = dm_easy_mesh_t instance, sta = {0x30,0x11,0x22,0x33,0x44,0x01}, bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0x30}, radio = {0xaa,0xbb,0xcc,0xdd,0xee,0x40} | All variables and data structures are properly initialized | Should be successful |
 * | 02 | Insert the created station info into the mesh using put_sta_info | input: info = created sta_info, mode = em_target_sta_map_assoc | Station info is inserted into the mesh without error | Should Pass |
 * | 03 | Retrieve the next station info by invoking get_next_sta_info with the inserted info | input: pointer to info, mapping = em_target_sta_map_assoc; output: next pointer | The API returns a nullptr indicating no further station info after the last entry | Should Pass |
 * | 04 | Validate returned pointer using EXPECT_EQ assertion | input: expected next = nullptr, actual next = value returned by get_next_sta_info | EXPECT_EQ confirms that the returned value is nullptr | Should Pass |
 */
TEST(dm_easy_mesh_t, LastStaInfo)
{
    std::cout << "Entering LastStaInfo test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t sta   = {0x30,0x11,0x22,0x33,0x44,0x01};
    mac_address_t bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0x30};
    mac_address_t radio = {0xaa,0xbb,0xcc,0xdd,0xee,0x40};
    em_sta_info_t info = create_sta_info(sta, bssid, radio);
    mesh.put_sta_info(&info, em_target_sta_map_assoc);
    std::cout << "Invoking get_next_sta_info(&info, em_target_sta_map_assoc)" << std::endl;
    em_sta_info_t *next = mesh.get_next_sta_info(&info, em_target_sta_map_assoc);
    print_sta_info("Next", next);
    EXPECT_EQ(next, nullptr);
    mesh.deinit();
    std::cout << "Exiting LastStaInfo test" << std::endl;
}

/**
 * @brief Test to verify that get_next_sta_info returns a null pointer when a null info pointer is passed.
 *
 * This test creates an instance of dm_easy_mesh_t, initializes it, and then invokes the get_next_sta_info API using a null pointer for the info parameter while supplying a valid target map value (em_target_sta_map_assoc). The expected behavior is that the API returns a null pointer, indicating that it correctly handles invalid input.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 315@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | -------------- | ----- |
 * | 01 | Create an instance of dm_easy_mesh_t and initialize it by calling init() | input: mesh object instantiation; method: init(); no output parameter | Instance is initialized successfully | Should be successful |
 * | 02 | Invoke get_next_sta_info using a null pointer and target map 'em_target_sta_map_assoc' | input1 = nullptr, input2 = em_target_sta_map_assoc; output: next pointer | API returns nullptr confirming correct handling of null input | Should Pass |
 * | 03 | Validate the returned pointer using EXPECT_EQ and print_sta_info for logging | output from get_next_sta_info compared to expected nullptr | EXPECT_EQ confirms the returned pointer is nullptr | Should be successful |
 */
TEST(dm_easy_mesh_t, NullInfoPointer)
{
    std::cout << "Entering NullInfoPointer test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    std::cout << "Invoking get_next_sta_info(NULL, em_target_sta_map_all)" << std::endl;
    em_sta_info_t *next = mesh.get_next_sta_info(nullptr, em_target_sta_map_assoc);
    print_sta_info("Next", next);
    EXPECT_EQ(next, nullptr);
    mesh.deinit();
    std::cout << "Exiting NullInfoPointer test" << std::endl;
}

/**
 * @brief Verify that get_next_sta_info returns a null pointer when there are no associated station entries.
 *
 * This test verifies that when the dm_easy_mesh_t instance is initialized with no station entries in the map,
 * invoking get_next_sta_info returns a null pointer. It confirms the API handles the empty map scenario gracefully.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 316@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                      | Test Data                                                                                                                            | Expected Result                                                   | Notes         |
 * | :--------------: | -------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------- | ------------- |
 * | 01               | Initialize the dm_easy_mesh_t instance by calling mesh.init()                    | No input arguments                                                                                                                   | Mesh instance initialized successfully                            | Should be successful |
 * | 02               | Create a station info object using create_sta_info with specific MAC addresses     | sta = {0x40,0x11,0x22,0x33,0x44,0x01}, bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0x01}, radio = {0xaa,0xbb,0xcc,0xdd,0xee,0x02}         | Station info object created successfully                           | Should be successful |
 * | 03               | Invoke get_next_sta_info with the created info and em_target_sta_map_assoc, then validate the result using EXPECT_EQ | info pointer from create_sta_info, mapping type = em_target_sta_map_assoc                                                               | Returns nullptr confirming no associated station entry, and assertion passes | Should Pass   |
 */
TEST(dm_easy_mesh_t, EmptyMap)
{
    std::cout << "Entering EmptyMap test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t sta   = {0x40,0x11,0x22,0x33,0x44,0x01};
    mac_address_t bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0x01};
    mac_address_t radio = {0xaa,0xbb,0xcc,0xdd,0xee,0x02};
    em_sta_info_t info = create_sta_info(sta, bssid, radio);
    std::cout << "Invoking get_next_sta_info(&info, em_target_sta_map_assoc)" << std::endl;
    em_sta_info_t *next = mesh.get_next_sta_info(&info, em_target_sta_map_assoc);
    print_sta_info("Next", next);
    EXPECT_EQ(next, nullptr);
    mesh.deinit();
    std::cout << "Exiting EmptyMap test" << std::endl;
}

/**
 * @brief Validate that the default value of m_num_ap_mld is zero
 *
 * This test verifies that a newly constructed dm_easy_mesh_t object returns
 * a zero value when get_num_ap_mld() is invoked. The objective is to ensure the
 * default state of the mesh object's m_num_ap_mld member is correctly initialized.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 317@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                   | Test Data                                                           | Expected Result                         | Notes      |
 * | :--------------: | ----------------------------------------------------------------------------- | ------------------------------------------------------------------- | --------------------------------------- | ---------- |
 * | 01               | Create a default instance of dm_easy_mesh_t and invoke get_num_ap_mld()        | dm_easy_mesh_t object created with default state, output num = 0      | Method returns 0                        | Should Pass|
 */
TEST(dm_easy_mesh_t, get_num_ap_mld_DefaultValue)
{
    std::cout << "Entering get_num_ap_mld_DefaultValue test" << std::endl;
    dm_easy_mesh_t mesh {};
    std::cout << "Invoking get_num_ap_mld()" << std::endl;
    unsigned int num = mesh.get_num_ap_mld();
    std::cout << "Retrieved m_num_ap_mld = " << num << std::endl;
    EXPECT_EQ(num, 0u);
    std::cout << "Exiting get_num_ap_mld_DefaultValue test" << std::endl;
}

/**
 * @brief Verify the get_num_ap_mld() method returns a valid non-zero value.
 *
 * This test ensures that the get_num_ap_mld() API correctly retrieves a non-zero value stored in the dm_easy_mesh_t object.
 * It sets the m_num_ap_mld member to 3 and validates that the getter returns 3.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 318@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                 | Test Data                            | Expected Result                                                      | Notes      |
 * | :--------------: | ------------------------------------------------------------------------------------------- | ------------------------------------ | -------------------------------------------------------------------- | ---------- |
 * | 01               | Initialize dm_easy_mesh_t object, set m_num_ap_mld to 3, and call get_num_ap_mld() function. | m_num_ap_mld = 3, expected return = 3 | API returns 3 and the EXPECT_EQ assertion passes.                    | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_ap_mld_ValidNonZeroValue)
{
    std::cout << "Entering get_num_ap_mld_ValidNonZeroValue test" << std::endl;
    dm_easy_mesh_t mesh {};
    mesh.m_num_ap_mld = 3;
    std::cout << "Invoking get_num_ap_mld()" << std::endl;
    unsigned int num = mesh.get_num_ap_mld();
    std::cout << "Retrieved m_num_ap_mld = " << num << std::endl;
    EXPECT_EQ(num, 3u);
    std::cout << "Exiting get_num_ap_mld_ValidNonZeroValue test" << std::endl;
}

/**
 * @brief Verify that dm_easy_mesh_t correctly returns zero when its m_num_ap_mld is set to zero.
 *
 * This test instantiates dm_easy_mesh_t, explicitly sets its m_num_ap_mld member to zero, and validates that the get_num_ap_mld function returns zero as expected.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 319@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                            | Test Data                                                       | Expected Result                                             | Notes      |
 * | :--------------: | -------------------------------------------------------------------------------------- | --------------------------------------------------------------- | ------------------------------------------------------------ | ---------- |
 * | 01               | Instantiate dm_easy_mesh_t, set m_num_ap_mld to 0, and invoke get_num_ap_mld.            | mesh = dm_easy_mesh_t{}, mesh.m_num_ap_mld = 0, num = mesh.get_num_ap_mld() | API returns 0 and EXPECT_EQ(num, 0u) passes                 | Should Pass|
 */
TEST(dm_easy_mesh_t, ExplicitZeroValue)
{
    std::cout << "Entering ExplicitZeroValue test" << std::endl;
    dm_easy_mesh_t mesh {};
    mesh.m_num_ap_mld = 0;
    std::cout << "Invoking get_num_ap_mld()" << std::endl;
    unsigned int num = mesh.get_num_ap_mld();
    std::cout << "Retrieved m_num_ap_mld = " << num << std::endl;
    EXPECT_EQ(num, 0u);
    std::cout << "Exiting ExplicitZeroValue test" << std::endl;
}

/**
 * @brief Validate that dm_easy_mesh_t::get_num_ap_mld returns the correct value when a large value is set.
 *
 * This test verifies that when m_num_ap_mld is assigned a large value (1000), the get_num_ap_mld() method correctly retrieves the same value. This ensures that the API can handle large input values without errors.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 320@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                  | Test Data                                         | Expected Result                                                  | Notes          |
 * | :--------------: | -------------------------------------------------------------------------------------------- | ------------------------------------------------- | ---------------------------------------------------------------- | -------------- |
 * | 01               | Instantiate dm_easy_mesh_t object and set m_num_ap_mld to 1000                                 | m_num_ap_mld = 1000                               | Object m_num_ap_mld member is set to 1000                          | Should be successful |
 * | 02               | Invoke get_num_ap_mld() method to retrieve the value and validate against the expected number   | input: none, output: num, expected: 1000          | Returned value is 1000 and the EXPECT_EQ assertion passes          | Should Pass    |
 */
TEST(dm_easy_mesh_t, LargeValue)
{
    std::cout << "Entering LargeValue test" << std::endl;
    dm_easy_mesh_t mesh {};
    mesh.m_num_ap_mld = 1000;
    std::cout << "Invoking get_num_ap_mld()" << std::endl;
    unsigned int num = mesh.get_num_ap_mld();
    std::cout << "Retrieved m_num_ap_mld = " << num << std::endl;
    EXPECT_EQ(num, 1000u);
    std::cout << "Exiting LargeValue test" << std::endl;
}

/**
 * @brief Test that verifies the correct retrieval of the next station information from the mesh
 *
 * This test validates the functionality of get_next_sta_info() by initializing a dm_easy_mesh_t object,
 * adding two station information entries into the mesh, and then retrieving the first and the subsequent station.
 * It confirms that the next station info is not null, is different from the first station, and that its MAC address
 * matches with either of the provided station addresses.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 321@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                  | Test Data                                                                                                                                                           | Expected Result                                                                                                          | Notes         |
 * | :--------------: | -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ | ------------- |
 * | 01               | Initialize the dm_easy_mesh_t object and create station and radio MAC addresses              | mesh instance, sta1 = 0x00,0x11,0x22,0x33,0x44,0x01, sta2 = 0x00,0x11,0x22,0x33,0x44,0x02, bssid = 0xaa,0xbb,0xcc,0xdd,0xee,0x01, radio = 0xaa,0xbb,0xcc,0xdd,0xee,0x02 | Mesh object and MAC addresses should be correctly instantiated                                                           | Should be successful |
 * | 02               | Create station information entries using the provided MAC addresses                            | info1 created with sta1, bssid, radio; info2 created with sta2, bssid, radio, mode = em_target_sta_map_assoc                                                         | Station info objects should be created successfully                                                                      | Should Pass   |
 * | 03               | Insert the created station information into the mesh using association mapping                 | mesh.put_sta_info called with info1 and info2 along with em_target_sta_map_assoc                                                                                        | Station information should be correctly inserted into the mesh                                                           | Should Pass   |
 * | 04               | Retrieve the first station info from the mesh to initiate iteration                          | mesh.get_first_sta_info(em_target_sta_map_assoc)                                                                                                                    | A valid pointer (not nullptr) representing the first station info is returned                                             | Should Pass   |
 * | 05               | Invoke get_next_sta_info with the first pointer and validate that it is different and valid     | First pointer from previous step passed to mesh.get_next_sta_info(em_target_sta_map_assoc)                                                                             | A valid pointer (not nullptr) different from the first, with MAC address matching either sta1 or sta2, is returned           | Should Pass   |
 */
TEST(dm_easy_mesh_t, ValidNextStaInfo)
{
    std::cout << "Entering ValidNextStaInfo test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t sta1  = {0x00,0x11,0x22,0x33,0x44,0x01};
    mac_address_t sta2  = {0x00,0x11,0x22,0x33,0x44,0x02};
    mac_address_t bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0x01};
    mac_address_t radio = {0xaa,0xbb,0xcc,0xdd,0xee,0x02};
    em_sta_info_t info1 = create_sta_info(sta1, bssid, radio);
    em_sta_info_t info2 = create_sta_info(sta2, bssid, radio);
    mesh.put_sta_info(&info1, em_target_sta_map_assoc);
    mesh.put_sta_info(&info2, em_target_sta_map_assoc);
    // MUST use map-owned pointer
    em_sta_info_t *first = mesh.get_first_sta_info(em_target_sta_map_assoc);
    ASSERT_NE(first, nullptr);
    std::cout << "Invoking get_next_sta_info(first, em_target_sta_map_assoc)" << std::endl;
    em_sta_info_t *next = mesh.get_next_sta_info(first, em_target_sta_map_assoc);
    print_sta_info("Next", next);
    ASSERT_NE(next, nullptr);
    EXPECT_NE(first, next);
    bool is_sta1 = memcmp(next->id, sta1, sizeof(mac_address_t)) == 0;
    bool is_sta2 = memcmp(next->id, sta2, sizeof(mac_address_t)) == 0;
    EXPECT_TRUE(is_sta1 || is_sta2);
    mesh.deinit();
    std::cout << "Exiting ValidNextStaInfo test" << std::endl;
}

/**
 * @brief Validate that get_next_sta_info returns nullptr when provided with a null input pointer.
 *
 * This test verifies that when a nullptr is passed as the starting pointer to the get_next_sta_info API,
 * the function detects the invalid input and safely returns a null pointer. This behavior is critical to prevent
 * undefined behavior or crashes in scenarios with invalid API usage.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 322@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                             | Test Data                                                                                           | Expected Result                                  | Notes             |
 * | :--------------: | --------------------------------------------------------| --------------------------------------------------------------------------------------------------- | ------------------------------------------------ | ----------------- |
 * | 01               | Initialize mesh and station info elements               | mesh.init(), sta = {1,2,3,4,5,6}, bss = {6,5,4,3,2,1}, radio = {9,9,9,9,9,9}                          | Mesh initialized and station info created       | Should be successful |
 * | 02               | Insert station info into mesh                           | put_sta_info(&info, em_target_sta_map_assoc)                                                        | Station info stored in mesh                       | Should be successful |
 * | 03               | Invoke get_next_sta_info with nullptr as input pointer   | input pointer = nullptr, map type = em_target_sta_map_assoc                                           | Function returns nullptr                          | Should Fail       |
 */
TEST(dm_easy_mesh_t, get_next_sta_info_NullInput)
{
	std::cout << "Entering get_next_sta_info_NullInput test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t sta  = {1,2,3,4,5,6};
    mac_address_t bss  = {6,5,4,3,2,1};
    mac_address_t radio = {9,9,9,9,9,9};
    em_sta_info_t info = create_sta_info(sta, bss, radio);
    mesh.put_sta_info(&info, em_target_sta_map_assoc);
	std::cout << "Invoking get_next_sta_info(nullptr, em_target_sta_map_assoc)" << std::endl;
    em_sta_info_t *next = mesh.get_next_sta_info(nullptr, em_target_sta_map_assoc);
    EXPECT_EQ(next, nullptr);
    mesh.deinit();
	std::cout << "Exiting get_next_sta_info_NullInput test" << std::endl;
}

/**
 * @brief Verify that get_next_sta_info returns nullptr when called on the last element in the STA info list
 *
 * This test initializes a mesh instance, adds a single station info entry, and verifies that fetching the first station info returns a valid pointer, but that calling get_next_sta_info on this sole entry returns nullptr. This behavior is expected as there is no subsequent element beyond the sole entry.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 323@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | ------------- | ----- |
 * | 01 | Initialize the mesh instance and prepare STA info data | dm_easy_mesh_t instance created, call to init(), sta1 = {0,0,0,0,0,1}, bssid = {1,1,1,1,1,1}, radio = {2,2,2,2,2,2} | Mesh instance is properly initialized | Should be successful |
 * | 02 | Create STA info and add it to the mesh | Call create_sta_info with sta1, bssid, radio; then call put_sta_info with info1 and em_target_sta_map_assoc | STA info is correctly added to the mesh | Should Pass |
 * | 03 | Retrieve the first STA info element from the mesh | Call get_first_sta_info with em_target_sta_map_assoc | Returned pointer is not nullptr | Should Pass |
 * | 04 | Call get_next_sta_info on the only element in the mesh | Call get_next_sta_info with pointer to first element and em_target_sta_map_assoc | Returned pointer is nullptr indicating no further elements | Should Pass |
 */
TEST(dm_easy_mesh_t, get_next_sta_info_LastElement)
{
	std::cout << "Entering get_next_sta_info_LastElement test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t sta1  = {0,0,0,0,0,1};
    mac_address_t bssid = {1,1,1,1,1,1};
    mac_address_t radio = {2,2,2,2,2,2};
    em_sta_info_t info1 = create_sta_info(sta1, bssid, radio);
    mesh.put_sta_info(&info1, em_target_sta_map_assoc);
    em_sta_info_t *first = mesh.get_first_sta_info(em_target_sta_map_assoc);
    ASSERT_NE(first, nullptr);
	std::cout << "Invoking get_next_sta_info(first, em_target_sta_map_assoc) with only one entry" << std::endl;
    // Only one entry  next must be NULL
    em_sta_info_t *next = mesh.get_next_sta_info(first, em_target_sta_map_assoc);
    EXPECT_EQ(next, nullptr);
    mesh.deinit();
	std::cout << "Exiting get_next_sta_info_LastElement test" << std::endl;
}

/**
 * @brief Test get_next_sta_info API for empty target station map scenario
 *
 * This test verifies that when the get_next_sta_info API is invoked with an empty target station map,
 * it returns a nullptr. The test initializes a mesh instance, creates a station info record with specific
 * MAC address values, and then calls the API with an empty map. The expected outcome is that no station info
 * is found, hence the API should return a nullptr.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 324@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:** 
 * | Variation / Step | Description                                                                                 | Test Data                                                                                                      | Expected Result                                    | Notes         |
 * | :--------------: | ------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- | -------------------------------------------------- | ------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and create sta_info with provided MAC addresses            | Call: mesh.init(), sta = {1,2,3,4,5,6}, bss = {6,5,4,3,2,1}, radio = {9,9,9,9,9,9}                            | Mesh instance initialized successfully             | Should be successful |
 * | 02               | Invoke get_next_sta_info with empty target station map and verify it returns nullptr          | Call: get_next_sta_info(&info, em_target_sta_map_assoc) where info is created using create_sta_info(sta, bss, radio) | Return value is nullptr and assertion (EXPECT_EQ) passes | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_next_sta_info_EmptyMap)
{
	std::cout << "Entering get_next_sta_info_EmptyMap test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t sta  = {1,2,3,4,5,6};
    mac_address_t bss  = {6,5,4,3,2,1};
    mac_address_t radio = {9,9,9,9,9,9};	
    em_sta_info_t info = create_sta_info(sta, bss, radio);
	std::cout << "Invoking get_next_sta_info(&info, em_target_sta_map_assoc) with empty map" << std::endl;
    em_sta_info_t *next = mesh.get_next_sta_info(&info, em_target_sta_map_assoc);
    EXPECT_EQ(next, nullptr);
    mesh.deinit();
	std::cout << "Exiting get_next_sta_info_EmptyMap test" << std::endl;
}

/**
 * @brief Verify that get_num_ap_mld returns the default value for a default dm_easy_mesh_t instance.
 *
 * This test checks whether invoking dm_easy_mesh_t::get_num_ap_mld with a pointer to a default constructed dm_easy_mesh_t instance returns the expected default value. It is important to ensure that the default initializations are correctly configured in the instance.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 325@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Construct a default dm_easy_mesh_t instance and call get_num_ap_mld | input: mesh = default constructed dm_easy_mesh_t, output: num = expected default value | Return value equals the expected default value for m_num_ap_mld | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_num_ap_mld_DefaultValue)
{
    std::cout << "Entering static_get_num_ap_mld_DefaultValue test" << std::endl;
    dm_easy_mesh_t mesh {};
    std::cout << "Invoking get_num_ap_mld(&mesh)" << std::endl;
    unsigned int num = dm_easy_mesh_t::get_num_ap_mld(static_cast<void*>(&mesh));
    std::cout << "Retrieved m_num_ap_mld = " << num << std::endl;
    std::cout << "Exiting static_get_num_ap_mld_DefaultValue test" << std::endl;
}

/**
 * @brief Tests that get_num_ap_mld returns the correct non-zero value from a dm_easy_mesh_t object.
 *
 * This test verifies that when the dm_easy_mesh_t object's m_num_ap_mld member is set to a non-zero value (3), 
 * the static method get_num_ap_mld correctly retrieves the value. The test asserts that the returned value is 3.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 326@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data |Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create an instance of dm_easy_mesh_t. | None | Instance of dm_easy_mesh_t is created successfully. | Should be successful |
 * | 02 | Set the m_num_ap_mld member to 3. | m_num_ap_mld = 3 | m_num_ap_mld is assigned the value 3. | Should be successful |
 * | 03 | Invoke get_num_ap_mld with the address of the mesh instance. | input: &mesh, m_num_ap_mld = 3 | API returns 3. | Should Pass |
 * | 04 | Assert that the value returned by get_num_ap_mld is equal to 3. | returned value = num, expected value = 3u | EXPECT_EQ(num, 3u) passes. | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_num_ap_mld_ValidNonZeroValue)
{
    std::cout << "Entering static_get_num_ap_mld_ValidNonZeroValue test" << std::endl;
    dm_easy_mesh_t mesh {};
    mesh.m_num_ap_mld = 3;
    std::cout << "Invoking get_num_ap_mld(&mesh)" << std::endl;
    unsigned int num = dm_easy_mesh_t::get_num_ap_mld(&mesh);
    std::cout << "Retrieved m_num_ap_mld = " << num << std::endl;
    EXPECT_EQ(num, 3u);
    std::cout << "Exiting static_get_num_ap_mld_ValidNonZeroValue test" << std::endl;
}

/**
 * @brief Validate that get_num_ap_mld returns 0 when m_num_ap_mld is explicitly set to zero
 *
 * This test verifies that the static member function get_num_ap_mld correctly returns the value of m_num_ap_mld when it has been explicitly set to zero. It ensures that the method properly accesses the mesh structure and returns the expected unsigned integer value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 327@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                  | Expected Result                                      | Notes         |
 * | :--------------: | --------------------------------------------------------------------------- | ---------------------------------------------------------- | ---------------------------------------------------- | ------------- |
 * | 01               | Create an instance of dm_easy_mesh_t and set m_num_ap_mld to 0              | mesh.m_num_ap_mld = 0                                       | mesh.m_num_ap_mld is set to 0                         | Should be successful |
 * | 02               | Invoke get_num_ap_mld with the pointer to the mesh instance                 | input: pointer to mesh; no explicit output argument provided | Function returns 0u                                  | Should Pass   |
 * | 03               | Compare the returned value from get_num_ap_mld with the expected value 0    | returned num = value from get_num_ap_mld                    | EXPECT_EQ validates that returned num is 0u          | Should Pass   |
 */
TEST(dm_easy_mesh_t, static_get_num_ap_mld_ExplicitZero)
{
    std::cout << "Entering static_get_num_ap_mld_ExplicitZero test" << std::endl;
    dm_easy_mesh_t mesh {};
    mesh.m_num_ap_mld = 0;
    std::cout << "Invoking get_num_ap_mld(&mesh)" << std::endl;
    unsigned int num = dm_easy_mesh_t::get_num_ap_mld(&mesh);
    std::cout << "Retrieved m_num_ap_mld = " << num << std::endl;
    EXPECT_EQ(num, 0u);
    std::cout << "Exiting static_get_num_ap_mld_ExplicitZero test" << std::endl;
}

/**
 * @brief Validate static_get_num_ap_mld returns correct number of AP MLD for large value input
 *
 * This test validates that the static method get_num_ap_mld correctly returns the number of AP MLD stored in a dm_easy_mesh_t object when its m_num_ap_mld member is set to a large value (1000). It is essential to ensure that the API handles large input values without error.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 328@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                      | Test Data                                       | Expected Result                                      | Notes         |
 * | :--------------: | ---------------------------------------------------------------- | ----------------------------------------------- | ---------------------------------------------------- | ------------- |
 * | 01               | Initialize dm_easy_mesh_t and set m_num_ap_mld to 1000             | mesh.m_num_ap_mld = 1000                          | m_num_ap_mld correctly set to 1000                   | Should be successful |
 * | 02               | Invoke static method get_num_ap_mld using the mesh pointer         | input: pointer to mesh, output: num               | Returned num equals 1000                             | Should Pass   |
 * | 03               | Verify output using EXPECT_EQ assertion                          | output from get_num_ap_mld: num = 1000            | EXPECT_EQ assertion passes confirming num equals 1000| Should Pass   |
 */
TEST(dm_easy_mesh_t, static_get_num_ap_mld_LargeValue)
{
    std::cout << "Entering static_get_num_ap_mld_LargeValue test" << std::endl;
    dm_easy_mesh_t mesh {};
    mesh.m_num_ap_mld = 1000;
    std::cout << "Invoking get_num_ap_mld(&mesh)" << std::endl;
    unsigned int num = dm_easy_mesh_t::get_num_ap_mld(&mesh);
    std::cout << "Retrieved m_num_ap_mld = " << num << std::endl;
    EXPECT_EQ(num, 1000u);
    std::cout << "Exiting static_get_num_ap_mld_LargeValue test" << std::endl;
}

/**
 * @brief Verify get_num_ap_mld returns 0 when invoked with a nullptr
 *
 * This test verifies that when the dm_easy_mesh_t::get_num_ap_mld API is invoked with a nullptr,
 * the API correctly returns 0. This behavior is critical to ensure that the API gracefully handles
 * invalid memory references by providing a default value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 329@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                      | Test Data                                         | Expected Result                           | Notes       |
 * | :--------------: | ---------------------------------------------------------------- | ------------------------------------------------- | ----------------------------------------- | ----------- |
 * | 01               | Initialize dm to a nullptr                                       | dm = nullptr                                      | dm is set to nullptr                      | Should be successful |
 * | 02               | Invoke get_num_ap_mld API with nullptr and validate returned value | input: dm = nullptr, output: num should equal 0u  | API returns 0u as verified by EXPECT_EQ()   | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_num_ap_mld_Nullptr)
{
    std::cout << "Entering static_get_num_ap_mld_Nullptr test" << std::endl;
    void *dm = nullptr;
    std::cout << "Invoking get_num_ap_mld(nullptr)" << std::endl;
    unsigned int num = dm_easy_mesh_t::get_num_ap_mld(dm);
	EXPECT_EQ(num, 0u);
    std::cout << "Exiting static_get_num_ap_mld_Nullptr test" << std::endl;
}

/**
 * @brief Verify that a default-constructed dm_easy_mesh_t object returns 0 for get_num_assoc_sta_mld()
 *
 * This test verifies that when a dm_easy_mesh_t object is created using its default constructor, 
 * the get_num_assoc_sta_mld() method returns the expected value of 0. This confirms that the object 
 * initializes its internal state correctly for the number of associated STA MLD.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 330@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                               | Test Data                                                                                          | Expected Result                                 | Notes        |
 * | :--------------: | ----------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | ----------------------------------------------- | ------------ |
 * | 01               | Create an instance of dm_easy_mesh_t using the default constructor                         | N/A                                                                                                | Instance is created with default-initialized values | Should be successful |
 * | 02               | Invoke get_num_assoc_sta_mld on the default constructed instance and verify the returned value | instance: dm_easy_mesh_t (default constructed), function call: get_num_assoc_sta_mld(), output: result | Return value equals 0 (result == 0u)              | Should Pass  |
 */
TEST(dm_easy_mesh_t, get_num_assoc_sta_mld_default_initialization)
{
    std::cout << "Entering get_num_assoc_sta_mld_default_initialization test" << std::endl;
    dm_easy_mesh_t instance;
    std::cout << "Invoking get_num_assoc_sta_mld on default constructed instance" << std::endl;
    unsigned int result = instance.get_num_assoc_sta_mld();
    std::cout << "Retrieved value: " << result << std::endl;
    EXPECT_EQ(result, 0u);
    std::cout << "Exiting get_num_assoc_sta_mld_default_initialization test" << std::endl;
}

/**
 * @brief Verify that get_num_assoc_sta_mld returns the correct small positive value
 *
 * This test verifies that, when m_num_assoc_sta_mld is set to 5, the get_num_assoc_sta_mld method returns 5. The test checks the assignment and retrieval correctness in the dm_easy_mesh_t instance.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 331@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                      | Test Data                                          | Expected Result                                              | Notes       |
 * | :--------------: | -------------------------------------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ | ----------- |
 * | 01               | Set m_num_assoc_sta_mld to 5 and invoke get_num_assoc_sta_mld to retrieve value   | instance.m_num_assoc_sta_mld = 5, expected return = 5 | API returns 5 as verified by EXPECT_EQ(result, 5u)           | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_assoc_sta_mld_small_positive_value)
{
    std::cout << "Entering get_num_assoc_sta_mld_small_positive_value test" << std::endl;
    dm_easy_mesh_t instance;
    instance.m_num_assoc_sta_mld = 5;
    std::cout << "Set m_num_assoc_sta_mld to: 5" << std::endl;
    std::cout << "Invoking get_num_assoc_sta_mld on instance" << std::endl;
    unsigned int result = instance.get_num_assoc_sta_mld();
    std::cout << "Retrieved value: " << result << std::endl;
    EXPECT_EQ(result, 5u);
    std::cout << "Exiting get_num_assoc_sta_mld_small_positive_value test" << std::endl;
}

/**
 * @brief Verify that static get_num_assoc_sta_mld returns the correct value for a valid instance.
 *
 * This test verifies that the static method get_num_assoc_sta_mld correctly retrieves the value of m_num_assoc_sta_mld when provided with a valid instance pointer. The instance's m_num_assoc_sta_mld field is set to 10, and the test confirms that the returned value matches the expected value.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 332@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                              | Test Data                                                              | Expected Result                                                          | Notes            |
 * | :--------------: | ------------------------------------------------------------------------ | ---------------------------------------------------------------------- | ------------------------------------------------------------------------ | ---------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and set m_num_assoc_sta_mld to 10       | instance.m_num_assoc_sta_mld = 10                                        | Instance variable m_num_assoc_sta_mld is set to 10                         | Should be successful |
 * | 02               | Invoke static get_num_assoc_sta_mld with valid instance pointer and verify | input: pointer = address of instance, output: expected result = 10       | Method returns 10 and assertion EXPECT_EQ(10u) passes                      | Should Pass       |
 */
TEST(dm_easy_mesh_t, get_num_assoc_sta_mld_static_valid_instance)
{
    std::cout << "Entering get_num_assoc_sta_mld_static_valid_instance test" << std::endl;
    dm_easy_mesh_t instance;
    instance.m_num_assoc_sta_mld = 10;
    std::cout << "Set m_num_assoc_sta_mld in instance to: 10" << std::endl;
    std::cout << "Invoking static get_num_assoc_sta_mld with valid instance pointer" << std::endl;
    unsigned int result = dm_easy_mesh_t::get_num_assoc_sta_mld(static_cast<void*>(&instance));
    std::cout << "Retrieved value: " << result << std::endl;
    EXPECT_EQ(result, 10u);    
    std::cout << "Exiting get_num_assoc_sta_mld_static_valid_instance test" << std::endl;
}

/**
 * @brief Validate get_num_assoc_sta_mld function behavior with NULL pointer input
 *
 * This test verifies that the static method get_num_assoc_sta_mld returns 0 when provided with a NULL pointer.
 * It checks that the function handles the null input gracefully without causing any runtime errors.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 333@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                      | Test Data                                  | Expected Result                                             | Notes       |
 * | :--------------: | ------------------------------------------------ | ------------------------------------------ | ----------------------------------------------------------- | ----------- |
 * |       01         | Invoke get_num_assoc_sta_mld with NULL pointer   | input pointer = nullptr, output expected = 0 | Returns 0 and assertion EXPECT_EQ(result, 0u) passes           | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_assoc_sta_mld_static_null_pointer)
{
    std::cout << "Entering get_num_assoc_sta_mld_static_null_pointer test" << std::endl;
    std::cout << "Invoking static get_num_assoc_sta_mld with NULL pointer" << std::endl;
    unsigned int result = dm_easy_mesh_t::get_num_assoc_sta_mld(static_cast<void*>(nullptr));
    std::cout << "Retrieved value: " << result << std::endl;
    EXPECT_EQ(result, 0u);    
    std::cout << "Exiting get_num_assoc_sta_mld_static_null_pointer test" << std::endl;
}

/**
 * @brief Verify that the get_num_assoc_sta_mld API returns 0 when no associated stations are present.
 *
 * This test creates an instance of dm_easy_mesh_t, sets its m_num_assoc_sta_mld field to 0, and then invokes
 * the get_num_assoc_sta_mld API to ensure that it correctly returns 0. This confirms that the API works as expected
 * for a case with zero associated stations.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 334@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                                  | Expected Result                                      | Notes         |
 * | :--------------: | --------------------------------------------------------------------------- | -------------------------------------------------------------------------- | ---------------------------------------------------- | ------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and set m_num_assoc_sta_mld to 0         | dm pointer, m_num_assoc_sta_mld = 0                                        | Instance initialized with m_num_assoc_sta_mld set to 0 | Should be successful |
 * | 02               | Invoke get_num_assoc_sta_mld API with valid dm instance                     | Input: dm pointer, Output: will hold the returned m_num_assoc_sta_mld value  | API returns 0u                                        | Should Pass   |
 * | 03               | Verify that the returned value from get_num_assoc_sta_mld is 0 using an assertion | Input: expected value = 0u, output: result from API call                   | EXPECT_EQ(result, 0u) passes                          | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_num_assoc_sta_mld_zero_assoc_sta) {
    std::cout << "Entering get_num_assoc_sta_mld_zero_assoc_sta test" << std::endl;
    dm_easy_mesh_t dm;
    dm.m_num_assoc_sta_mld = 0;
    std::cout << "Invoking get_num_assoc_sta_mld with valid dm and m_num_assoc_sta_mld set to " << dm.m_num_assoc_sta_mld << std::endl;
    unsigned int result = dm_easy_mesh_t::get_num_assoc_sta_mld(static_cast<void*>(&dm));
    std::cout << "Retrieved m_num_assoc_sta_mld value: " << result << std::endl;
    EXPECT_EQ(result, 0u);
    std::cout << "Exiting get_num_assoc_sta_mld_zero_assoc_sta test" << std::endl;
}

/**
 * @brief Validate that the default object of dm_easy_mesh_t returns zero BSS count
 *
 * This test case verifies that when an object of dm_easy_mesh_t is created using the default constructor,
 * the get_num_bss() method returns 0 as expected. This is key to ensuring that the initial state of the object 
 * is correctly set.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 335@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                        | Test Data                                                   | Expected Result                                                      | Notes         |
 * | :-------------:  | ------------------------------------------------------------------ | ----------------------------------------------------------- | -------------------------------------------------------------------- | ------------- |
 * | 01               | Create a dm_easy_mesh_t object using the default constructor and invoke get_num_bss() method | Object creation: default constructor, Method call: get_num_bss(), Expected output: bssCount = 0 | get_num_bss() returns 0 and ASSERT_EQ verifies that bssCount is equal to 0  | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_num_bss_default_object) {
    std::cout << "Entering get_num_bss_default_object test" << std::endl;    
    dm_easy_mesh_t obj; 
    std::cout << "Invoked default constructor for dm_easy_mesh_t" << std::endl;    
    unsigned int bssCount = obj.get_num_bss();
    std::cout << "Invoked get_num_bss() method, retrieved value: " << bssCount << std::endl;    
    ASSERT_EQ(bssCount, 0);    
    std::cout << "Exiting get_num_bss_default_object test" << std::endl;
}

/**
 * @brief Validate that get_num_bss returns the typical value set in dm_easy_mesh_t instance
 *
 * This test verifies that when m_num_bss is set to a typical valid value (5) in the dm_easy_mesh_t instance, 
 * the static API get_num_bss correctly returns the same value. This ensures that the getter function behaves 
 * as expected when provided with valid input.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 336@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                 | Test Data                                                       | Expected Result                                                                                      | Notes        |
 * | :--------------: | ------------------------------------------------------------------------------------------- | --------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | ------------ |
 * | 01               | Create a dm_easy_mesh_t instance, set m_num_bss to 5, then call get_num_bss passing its address | input: m_num_bss = 5, pointer = address of dm_easy_mesh_t instance; output: returnedValue = 5 | get_num_bss returns 5U, and EXPECT_EQ(returnedValue, 5U) assertion passes                              | Should Pass  |
 */
TEST(dm_easy_mesh_t, get_num_bss_typical_value)
{
    std::cout << "Entering get_num_bss_typical_value test" << std::endl;
    dm_easy_mesh_t dmInstance;
    dmInstance.m_num_bss = 5;
    std::cout << "Invoking get_num_bss with m_num_bss set to: " << dmInstance.m_num_bss << std::endl;
    unsigned int returnedValue = dm_easy_mesh_t::get_num_bss(static_cast<void*>(&dmInstance));
    std::cout << "Returned value from get_num_bss: " << returnedValue << std::endl;
    EXPECT_EQ(returnedValue, 5U);
    std::cout << "Exiting get_num_bss_typical_value test" << std::endl;
}

/**
 * @brief Verify that get_num_bss returns zero when m_num_bss is set to zero
 *
 * This test validates that the get_num_bss API correctly returns a value of zero when the dm_easy_mesh_t instance has its m_num_bss member set to zero. The test ensures that the function handles a zero value appropriately as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 337@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                              | Test Data                                                          | Expected Result                                      | Notes            |
 * | :--------------: | ------------------------------------------------------------------------ | ------------------------------------------------------------------ | ---------------------------------------------------- | ---------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and set m_num_bss to 0                | dmInstance.m_num_bss = 0                                             | Instance is properly initialized with m_num_bss=0    | Should be successful |
 * | 02               | Invoke get_num_bss API with the address of the initialized instance        | input = pointer to dmInstance (m_num_bss=0)                          | get_num_bss returns 0                                | Should Pass      |
 * | 03               | Assert that the returned value from get_num_bss is equal to 0              | returnedValue (obtained from get_num_bss) = 0                        | EXPECT_EQ returns true as the returned value equals 0| Should Pass      |
 */
TEST(dm_easy_mesh_t, get_num_bss_zero_value)
{
    std::cout << "Entering get_num_bss_zero_value test" << std::endl;
    dm_easy_mesh_t dmInstance;
    dmInstance.m_num_bss = 0;
    std::cout << "Invoking get_num_bss with m_num_bss set to: " << dmInstance.m_num_bss << std::endl;
    unsigned int returnedValue = dm_easy_mesh_t::get_num_bss(static_cast<void*>(&dmInstance));
    std::cout << "Returned value from get_num_bss: " << returnedValue << std::endl;
    EXPECT_EQ(returnedValue, 0U);    
    std::cout << "Exiting get_num_bss_zero_value test" << std::endl;
}

/**
 * @brief Verify that get_num_bss returns the maximum BSS value when set to UINT_MAX
 *
 * This test sets the m_num_bss member of the dm_easy_mesh_t instance to UINT_MAX and verifies that the static
 * method get_num_bss correctly returns this maximum value. It ensures that the API properly handles and returns the
 * maximum unsigned integer value without any overflow or reset.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 338@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                       | Test Data                                            | Expected Result                                          | Notes         |
 * | :--------------: | --------------------------------------------------------------------------------- | ---------------------------------------------------- | -------------------------------------------------------- | ------------- |
 * | 01               | Initialize the dm_easy_mesh_t instance and set m_num_bss to UINT_MAX              | dmInstance.m_num_bss = UINT_MAX                        | dmInstance created with m_num_bss initialized to UINT_MAX | Should be successful |
 * | 02               | Invoke the get_num_bss API with the instance pointer                              | Input: pointer = &dmInstance                           | API returns UINT_MAX                                     | Should Pass   |
 * | 03               | Validate the returned value using EXPECT_EQ                                       | Input: returnedValue = result from get_num_bss, expected UINT_MAX | EXPECT_EQ asserts returned value equals UINT_MAX         | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_num_bss_max_value)
{
    std::cout << "Entering get_num_bss_max_value test" << std::endl;
    dm_easy_mesh_t dmInstance;
    dmInstance.m_num_bss = UINT_MAX;    
    std::cout << "Invoking get_num_bss with m_num_bss set to: " << dmInstance.m_num_bss << std::endl;
    unsigned int returnedValue = dm_easy_mesh_t::get_num_bss(static_cast<void*>(&dmInstance));
    std::cout << "Returned value from get_num_bss: " << returnedValue << std::endl;
    EXPECT_EQ(returnedValue, UINT_MAX);    
    std::cout << "Exiting get_num_bss_max_value test" << std::endl;
}

/**
 * @brief This test verifies that get_num_bss_for_associated_sta() returns the correct count when a station is associated with multiple BSS entries.
 *
 * This test checks whether the dm_easy_mesh_t API correctly handles multiple BSS associations for a given station. It initializes a mesh object, adds the same station with two different BSS IDs, and asserts that the count retrieved is exactly 2.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 339@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize the mesh object and invoke mesh.init() | mesh object created; no input parameters | Mesh is initialized successfully | Should be successful |
 * | 02 | Add a station associated with the first BSS using add_sta() | sta_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0x01}, bssid = {0x11,0x11,0x11,0x11,0x11,0x11}, radio_mac = {0x66,0x55,0x44,0x33,0x22,0x11} | Station is added to the mesh with first BSS association | Should be successful |
 * | 03 | Add the same station associated with the second BSS using add_sta() | sta_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0x01}, bssid = {0x22,0x22,0x22,0x22,0x22,0x22}, radio_mac = {0x66,0x55,0x44,0x33,0x22,0x11} | Station is added to the mesh with second BSS association | Should be successful |
 * | 04 | Retrieve the number of BSS associations for the given station by invoking get_num_bss_for_associated_sta() | input: sta_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0x01} | Returns count equal to 2, and the assertion EXPECT_EQ(count, 2) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_bss_for_associated_sta_multiple_matches)
{
    const char *testName = "get_num_bss_for_associated_sta_multiple_matches";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    unsigned char sta_mac[6]   = {0xAA,0xBB,0xCC,0xDD,0xEE,0x01};
    unsigned char bssid1[6]    = {0x11,0x11,0x11,0x11,0x11,0x11};
    unsigned char bssid2[6]    = {0x22,0x22,0x22,0x22,0x22,0x22};
    unsigned char radio_mac[6] = {0x66,0x55,0x44,0x33,0x22,0x11};
    add_sta(mesh, sta_mac, bssid1, radio_mac);
    add_sta(mesh, sta_mac, bssid2, radio_mac);
    std::cout << "Invoking get_num_bss_for_associated_sta()" << std::endl;
    int count = mesh.get_num_bss_for_associated_sta(sta_mac);
    std::cout << "Retrieved BSS count: " << count << std::endl;
    EXPECT_EQ(count, 2);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_num_bss_for_associated_sta returns 0 when the searched station is not associated
 *
 * This test verifies that when a non-associated station MAC address is provided to get_num_bss_for_associated_sta,
 * the function correctly returns 0. This ensures that the association logic in dm_easy_mesh_t handles unmatched cases properly.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 340@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                      | Test Data                                                                                                                                          | Expected Result                                                       | Notes         |
 * | :--------------: | ------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- | ------------- |
 * | 01 | Initialize the dm_easy_mesh_t object and set up the test environment. | N/A | The dm_easy_mesh_t object is initialized successfully with no issues. | Should be successful |
 * | 02 | Add a station with a specific MAC address to the mesh instance using add_sta function.         | existing_sta = {0xAA,0xBB,0xCC,0xDD,0xEE,0x01}, bssid = {0x11,0x22,0x33,0x44,0x55,0x66}, radio_mac = {0x66,0x55,0x44,0x33,0x22,0x11}     | Station is added successfully to the mesh.                            | Should be successful |
 * | 03 | Invoke get_num_bss_for_associated_sta with a non-associated station and verify the returned count. | search_sta = {0xFF,0xEE,0xDD,0xCC,0xBB,0xAA}                                                                                                     | The function returns 0, matching the EXPECT_EQ(count, 0) assertion.     | Should Pass  |
 */
TEST(dm_easy_mesh_t, get_num_bss_for_associated_sta_no_match)
{
    const char *testName = "get_num_bss_for_associated_sta_no_match";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    unsigned char existing_sta[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0x01};
    unsigned char search_sta[6]   = {0xFF,0xEE,0xDD,0xCC,0xBB,0xAA};
    unsigned char bssid[6]        = {0x11,0x22,0x33,0x44,0x55,0x66};
    unsigned char radio_mac[6]    = {0x66,0x55,0x44,0x33,0x22,0x11};
    add_sta(mesh, existing_sta, bssid, radio_mac);
    std::cout << "Invoking get_num_bss_for_associated_sta()" << std::endl;
    int count = mesh.get_num_bss_for_associated_sta(search_sta);
    std::cout << "Retrieved BSS count: " << count << std::endl;
    EXPECT_EQ(count, 0);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_num_bss_for_associated_sta returns zero for an empty association map
 *
 * This test initializes the dm_easy_mesh_t object, ensures its internal association map is empty, and then calls 
 * get_num_bss_for_associated_sta with a predefined station MAC address. The test verifies that the function correctly 
 * returns a count of zero, indicating no associated BSS for the provided MAC address. This basic scenario ensures the 
 * API behaves as expected when no associations have been set.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 341@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                         | Test Data                                                                 | Expected Result                                          | Notes        |
 * | :--------------: | ------------------------------------------------------------------- | ------------------------------------------------------------------------- | -------------------------------------------------------- | ------------ |
 * | 01               | Initialize mesh object using init() and call get_num_bss_for_associated_sta() on an empty association map. | sta_mac = 0xAA,0xBB,0xCC,0xDD,0xEE,0x01; expected count = 0                 | API returns 0 and EXPECT_EQ(count, 0) passes             | Should Pass  |
 */
TEST(dm_easy_mesh_t, get_num_bss_for_associated_sta_empty_map)
{
    const char *testName = "get_num_bss_for_associated_sta_empty_map";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    unsigned char sta_mac[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0x01};
    std::cout << "Invoking get_num_bss_for_associated_sta() on empty map" << std::endl;
    int count = mesh.get_num_bss_for_associated_sta(sta_mac);
    std::cout << "Retrieved BSS count: " << count << std::endl;
    EXPECT_EQ(count, 0);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_num_bss_for_associated_sta handles a null pointer input correctly
 *
 * This test verifies that the get_num_bss_for_associated_sta API does not crash when passed a null pointer and correctly returns 0, ensuring proper defensive programming is in place.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 342@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | -------------- | ----- |
 * | 01 | Initialize the mesh instance, configure a sample station information, and then invoke get_num_bss_for_associated_sta with a null pointer. | sta_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0x01}, bssid = {0x11,0x22,0x33,0x44,0x55,0x66}, radio_mac = {0x66,0x55,0x44,0x33,0x22,0x11}, input = nullptr, expected output count = 0 | API returns 0 and does not crash | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_bss_for_associated_sta_nullptr_crash)
{
    const char *testName = "get_num_bss_for_associated_sta_nullptr_crash";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    unsigned char sta_mac[6]   = {0xAA,0xBB,0xCC,0xDD,0xEE,0x01};
    unsigned char bssid[6]     = {0x11,0x22,0x33,0x44,0x55,0x66};
    unsigned char radio_mac[6] = {0x66,0x55,0x44,0x33,0x22,0x11};
    em_sta_info_t info{};
    memcpy(info.id, sta_mac, sizeof(mac_address_t));
    memcpy(info.bssid, bssid, sizeof(mac_address_t));
    memcpy(info.radiomac, radio_mac, sizeof(mac_address_t));
    mesh.put_sta_info(&info, em_target_sta_map_consolidated);
    std::cout << "Invoking get_num_bss_for_associated_sta(nullptr)" << std::endl;
    int count = mesh.get_num_bss_for_associated_sta(nullptr);
	EXPECT_EQ(count, 0);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify default initialization of dm_easy_mesh_t and get_num_bsta_mld() call
 *
 * This test case verifies that when a dm_easy_mesh_t instance is default initialized, the
 * get_num_bsta_mld() method returns the expected default number of bsta mld instances.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 343@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                               | Test Data                                                       | Expected Result                                                                  | Notes             |
 * | :--------------: | ------------------------------------------------------------------------- | --------------------------------------------------------------- | -------------------------------------------------------------------------------- | ----------------- |
 * | 01               | Create an instance of dm_easy_mesh_t using default constructor            | None                                                            | Instance is successfully created                                                 | Should be successful |
 * | 02               | Call get_num_bsta_mld() method on the instance                            | output1 = result, instance.get_num_bsta_mld() is invoked         | Returns the default unsigned int value (expected to be 0)                        | Should Pass       |
 */
TEST(dm_easy_mesh_t, get_num_bsta_mld_instance_default_initialization) {
    std::cout << "Entering get_num_bsta_mld_instance_default_initialization test" << std::endl;
    dm_easy_mesh_t instance;
    std::cout << "Invoking instance.get_num_bsta_mld()" << std::endl;
    unsigned int result = instance.get_num_bsta_mld();
    std::cout << "Returned value from instance.get_num_bsta_mld(): " << result << std::endl;    
    std::cout << "Exiting get_num_bsta_mld_instance_default_initialization test" << std::endl;
}

/**
 * @brief Validates the get_num_bsta_mld method for a positive scenario
 *
 * This test verifies that when the dm_easy_mesh_t object's m_num_bsta_mld field is set to 5,
 * calling the get_num_bsta_mld() method returns the correct value. It ensures that the getter
 * function works as expected for a positive scenario.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 344@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create an instance of dm_easy_mesh_t and set the m_num_bsta_mld field to 5 | instance.m_num_bsta_mld = 5 | Field is correctly set with value 5 | Should be successful |
 * | 02 | Invoke instance.get_num_bsta_mld() to retrieve the number of bsta mld instances | Call: result = instance.get_num_bsta_mld() | Returns 5u as unsigned int | Should Pass |
 * | 03 | Verify the correctness of get_num_bsta_mld() using EXPECT_EQ assertion | Assertion: EXPECT_EQ(result, 5u) | The test assertion passes confirming the expected output | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_bsta_mld_instance_positive) {
    std::cout << "Entering get_num_bsta_mld_instance_positive test" << std::endl;
    dm_easy_mesh_t instance;
    instance.m_num_bsta_mld = 5;
    std::cout << "Invoking instance.get_num_bsta_mld()" << std::endl;
    unsigned int result = instance.get_num_bsta_mld();
    std::cout << "Returned value from instance.get_num_bsta_mld(): " << result << std::endl;
    EXPECT_EQ(result, 5u);
    std::cout << "Exiting get_num_bsta_mld_instance_positive test" << std::endl;
}

/**
 * @brief Test to verify that get_num_bsta_mld returns 0 when m_num_bsta_mld is set to 0
 *
 * This test checks that get_num_bsta_mld() correctly returns the value of m_num_bsta_mld when it is initialized to 0. 
 * This ensures that the method behaves as expected under zero initialization conditions.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 345@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                        | Test Data                                   | Expected Result                                          | Notes             |
 * | :--------------: | ------------------------------------------------------------------ | ------------------------------------------- | -------------------------------------------------------- | ----------------- |
 * | 01               | Initialize an instance and set m_num_bsta_mld to 0                   | m_num_bsta_mld = 0                          | Instance member m_num_bsta_mld is set to 0               | Should be successful |
 * | 02               | Invoke get_num_bsta_mld() method on the instance                     | API call: get_num_bsta_mld()                | API returns the value of m_num_bsta_mld, which is expected 0 | Should Pass       |
 * | 03               | Verify that the returned value equals 0                             | result = instance.get_num_bsta_mld(), expected result = 0 | EXPECT_EQ(result, 0u) passes verifying the correct output | Should be successful |
 */
TEST(dm_easy_mesh_t, get_num_bsta_mld_zero_bsta) {
    std::cout << "Entering get_num_bsta_mld_zero_bsta test" << std::endl;
    dm_easy_mesh_t instance;
    instance.m_num_bsta_mld = 0;
    std::cout << "Invoking instance.get_num_bsta_mld()" << std::endl;
    unsigned int result = instance.get_num_bsta_mld();
    std::cout << "Returned value from instance.get_num_bsta_mld(): " << result << std::endl;
    EXPECT_EQ(result, 0u);
    std::cout << "Exiting get_num_bsta_mld_zero_bsta test" << std::endl;
}

/**
 * @brief Validate default value of BSTA MLD in dm_easy_mesh_t
 *
 * This test verifies that the default value returned by get_num_bsta_mld from a fresh instance of dm_easy_mesh_t is zero.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 346@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                          | Test Data                                                        | Expected Result                                    | Notes       |
 * | :--------------: | -------------------------------------------------------------------- | ---------------------------------------------------------------- | -------------------------------------------------- | ----------- |
 * | 01               | Create an instance of dm_easy_mesh_t and invoke get_num_bsta_mld.      | mesh = instance of dm_easy_mesh_t, result = get_num_bsta_mld(&mesh) | result should be 0u (default value for BSTA MLD).  | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_bsta_mld_default)
{
    const char *testName = "get_num_bsta_mld_default";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    std::cout << "Invoking get_num_bsta_mld(&mesh)" << std::endl;
    unsigned int result = dm_easy_mesh_t::get_num_bsta_mld(&mesh);
    std::cout << "Retrieved num_bsta_mld = " << result << std::endl;
    EXPECT_EQ(result, 0u);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that the get_num_bsta_mld API correctly retrieves the configured number
 *
 * This test verifies that when the dm_easy_mesh_t structure has its m_num_bsta_mld field set,
 * the get_num_bsta_mld API returns the correct value. It ensures that the API retrieves the value as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 347@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Set the m_num_bsta_mld field of dm_easy_mesh_t to 3 | mesh.m_num_bsta_mld = 3 | The structure's field is set to 3 | Should be successful |
 * | 02 | Invoke the get_num_bsta_mld API using the address of mesh | input: dm_easy_mesh_t pointer with m_num_bsta_mld = 3, output: result variable | API returns 3u | Should Pass |
 * | 03 | Validate the API return value with an assertion | EXPECT_EQ(result, 3u) | The assertion passes confirming the API returns 3u | Should be successful |
 */
TEST(dm_easy_mesh_t, get_num_bsta_mld_configured)
{
    const char *testName = "get_num_bsta_mld_configured";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bsta_mld = 3;
    std::cout << "Invoking get_num_bsta_mld(&mesh)" << std::endl;
    unsigned int result = dm_easy_mesh_t::get_num_bsta_mld(&mesh);
    std::cout << "Retrieved num_bsta_mld = " << result << std::endl;
    EXPECT_EQ(result, 3u);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that dm_easy_mesh_t::get_num_bsta_mld returns the maximum unsigned int value.
 *
 * This test creates a dm_easy_mesh_t instance with its m_num_bsta_mld member set to std::numeric_limits<unsigned int>::max().
 * It then invokes the get_num_bsta_mld function and checks that the returned value matches std::numeric_limits<unsigned int>::max(),
 * ensuring that the API correctly handles the boundary condition for maximum value.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 348@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t with m_num_bsta_mld set to maximum and invoke get_num_bsta_mld | input: mesh.m_num_bsta_mld = std::numeric_limits<unsigned int>::max(), input pointer = &mesh, output: result = std::numeric_limits<unsigned int>::max() | Returned value equals std::numeric_limits<unsigned int>::max() and EXPECT_EQ check passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_bsta_mld_boundary_max)
{
    const char *testName = "get_num_bsta_mld_boundary_max";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_bsta_mld = std::numeric_limits<unsigned int>::max();
    std::cout << "Invoking get_num_bsta_mld(&mesh)" << std::endl;
    unsigned int result = dm_easy_mesh_t::get_num_bsta_mld(&mesh);
    std::cout << "Retrieved num_bsta_mld = " << result << std::endl;
    EXPECT_EQ(result, std::numeric_limits<unsigned int>::max());
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test get_num_bsta_mld with null pointer to ensure graceful handling
 *
 * This test verifies that invoking the get_num_bsta_mld function with a null pointer does not crash the application and returns the expected result of 0. The objective is to confirm that the function handles invalid input properly, thus ensuring robustness of the API.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 349@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                  | Test Data                                   | Expected Result                                      | Notes      |
 * | :--------------: | ------------------------------------------------------------ | ------------------------------------------- | ---------------------------------------------------- | ---------- |
 * | 01               | Call get_num_bsta_mld with a null pointer and verify result  | input = nullptr, output expected = 0         | Function returns 0 without crashing                  | Should Pass|
 */
TEST(dm_easy_mesh_t, get_num_bsta_mld_nullptr_crash)
{
    const char *testName = "get_num_bsta_mld_nullptr_crash";
    std::cout << "Entering " << testName << " test" << std::endl;
    std::cout << "Invoking get_num_bsta_mld(nullptr)" << std::endl;
    unsigned int result = dm_easy_mesh_t::get_num_bsta_mld(nullptr);
	std::cout << "Retrieved num_bsta_mld = " << result << std::endl;
    EXPECT_EQ(result, 0u);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that the default constructed dm_easy_mesh_t object's get_num_network_ssid() method returns 0.
 *
 * This test verifies that when a dm_easy_mesh_t object is created using its default constructor, invoking the get_num_network_ssid() method returns 0. This ensures that the object is properly initialized with a default state where no network SSIDs are configured.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 350@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                          | Test Data                                                       | Expected Result                                   | Notes       |
 * | :--------------: | ---------------------------------------------------------------------------------------------------- | --------------------------------------------------------------- | ------------------------------------------------- | ----------- |
 * | 01               | Create a dm_easy_mesh_t object using its default constructor and call get_num_network_ssid() method. | object = default constructed, output: result from get_num_network_ssid() = 0 | Return value equals 0 and assertion passes          | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_network_ssid_default_object_returns_0)
{
    std::cout << "Entering get_num_network_ssid_default_object_returns_0 test" << std::endl;
    dm_easy_mesh_t obj;
    std::cout << "Created dm_easy_mesh_t object using default constructor" << std::endl;
    std::cout << "Invoking get_num_network_ssid() on default constructed object" << std::endl;
    unsigned int result = obj.get_num_network_ssid();
    std::cout << "get_num_network_ssid() returned: " << result << std::endl;
    ASSERT_EQ(result, 0u);    
    std::cout << "Exiting get_num_network_ssid_default_object_returns_0 test" << std::endl;
}

/**
 * @brief Verify that get_num_op_class() returns zero when m_num_opclass is set to 0
 *
 * This test creates an instance of dm_easy_mesh_t, explicitly sets its member m_num_opclass to 0, and invokes the get_num_op_class() method to verify that it correctly returns 0. The objective is to ensure that the getter function behaves as expected when the internal value is zero.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 351@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                             | Test Data                                                 | Expected Result                                          | Notes          |
 * | :--------------: | ----------------------------------------------------------------------- | --------------------------------------------------------- | -------------------------------------------------------- | -------------- |
 * | 01               | Instantiate dm_easy_mesh_t object and set m_num_opclass to 0            | m_num_opclass = 0                                         | Object's m_num_opclass is set to 0                        | Should be successful |
 * | 02               | Invoke get_num_op_class() and verify it returns 0                         | Invocation of get_num_op_class(), expected output = 0u    | Returns 0u and assertion EXPECT_EQ(0u, result) passes    | Should Pass    |
 */
TEST(dm_easy_mesh_t, get_num_op_class_default_object_zero) {
    std::cout << "Entering get_num_op_class_default_object_zero test" << std::endl;
    dm_easy_mesh_t obj;
    obj.m_num_opclass = 0;
    std::cout << "Invoking get_num_op_class() on object with m_num_opclass = " << obj.m_num_opclass << std::endl;
    unsigned int result = obj.get_num_op_class();
    std::cout << "get_num_op_class() returned: " << result << std::endl;
    EXPECT_EQ(0u, result);
    std::cout << "Exiting get_num_op_class_default_object_zero test" << std::endl;
}

/**
 * @brief Tests the get_num_op_class() method for a positive scenario
 *
 * This test verifies that the get_num_op_class() function correctly returns a non-zero value when m_num_opclass is set to 5. The objective is to ensure that the API behaves as expected when provided with valid data, returning the correct number of operational classes.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 352@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                           | Expected Result                                        | Notes       |
 * | :--------------: | --------------------------------------------------------------------------- | ----------------------------------- | ------------------------------------------------------ | ----------- |
 * | 01               | Initialize dm_easy_mesh_t object with m_num_opclass set to 5, invoke get_num_op_class() and validate that the returned value equals 5 | m_num_opclass = 5, expected_return = 5 | get_num_op_class() returns 5 and assertion passes      | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_op_class_positive_non_zero) {
    std::cout << "Entering get_num_op_class_positive_non_zero test" << std::endl;
    dm_easy_mesh_t obj;
    obj.m_num_opclass = 5;
    std::cout << "Invoking get_num_op_class() on object with m_num_opclass = " << obj.m_num_opclass << std::endl;
    unsigned int result = obj.get_num_op_class();
    std::cout << "get_num_op_class() returned: " << result << std::endl;
    EXPECT_EQ(5u, result);
    std::cout << "Exiting get_num_op_class_positive_non_zero test" << std::endl;
}

/**
 * @brief Validate that get_num_op_class() returns the maximum unsigned int value
 *
 * This test verifies that when the m_num_opclass member of a dm_easy_mesh_t object is set to UINT_MAX, 
 * invoking get_num_op_class() returns UINT_MAX. This confirms that the API correctly handles the edge 
 * scenario where the operation class value is at its maximum.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 353@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Instantiate dm_easy_mesh_t, set m_num_opclass to UINT_MAX, and invoke get_num_op_class() | m_num_opclass = UINT_MAX, invoke get_num_op_class(), result variable | get_num_op_class() returns UINT_MAX and EXPECT_EQ(UINT_MAX, result) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_op_class_max_value) {
    std::cout << "Entering get_num_op_class_max_value test" << std::endl;
    dm_easy_mesh_t obj;
    obj.m_num_opclass = UINT_MAX;
    std::cout << "Invoking get_num_op_class() on object with m_num_opclass = " << obj.m_num_opclass << std::endl;
    unsigned int result = obj.get_num_op_class();
    std::cout << "get_num_op_class() returned: " << result << std::endl;
    EXPECT_EQ(UINT_MAX, result);
    std::cout << "Exiting get_num_op_class_max_value test" << std::endl;
}

/**
 * @brief Validate the default operational class count for dm_easy_mesh_t
 *
 * This test initializes a dm_easy_mesh_t instance and invokes the get_num_op_class API to validate that the default operational class count is 0. This ensures that the mesh object is correctly initialized with no operational classes.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 354@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                           | Test Data                                              | Expected Result                                               | Notes       |
 * | :--------------: | ------------------------------------------------------------------------------------- | ------------------------------------------------------ | ------------------------------------------------------------- | ----------- |
 * | 01               | Initialize a default dm_easy_mesh_t instance, invoke get_num_op_class API and verify its return value | mesh: default instance, output: result = 0             | get_num_op_class returns 0 and EXPECT_EQ assertion passes       | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_op_class_default)
{
    const char *testName = "get_num_op_class_default";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    std::cout << "Invoking get_num_op_class(&mesh)" << std::endl;
    unsigned int result = dm_easy_mesh_t::get_num_op_class(&mesh);
    std::cout << "Retrieved num_op_class = " << result << std::endl;
    EXPECT_EQ(result, 0u);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_num_op_class returns the correct number of operational classes configured
 *
 * This test verifies that when the dm_easy_mesh_t structure is initialized with a specific number of operational classes,
 * the get_num_op_class API returns the same value. The test sets the m_num_opclass member to 5 and expects that the API returns 5.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 355@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                              | Test Data                                                  | Expected Result                                      | Notes       |
 * | :--------------: | ---------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ---------------------------------------------------- | ----------- |
 * | 01               | Instantiate dm_easy_mesh_t, set m_num_opclass to 5, invoke get_num_op_class, and verify result | input: mesh pointer, mesh.m_num_opclass = 5, output: 5       | The API returns 5 and the assertion EXPECT_EQ passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_op_class_configured)
{
    const char *testName = "get_num_op_class_configured";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_opclass = 5;
    std::cout << "Invoking get_num_op_class(&mesh)" << std::endl;
    unsigned int result = dm_easy_mesh_t::get_num_op_class(&mesh);
    std::cout << "Retrieved num_op_class = " << result << std::endl;
    EXPECT_EQ(result, 5u);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Tests the retrieval of the maximum operational class value for dm_easy_mesh_t.
 *
 * Tests whether the dm_easy_mesh_t::get_num_op_class function correctly retrieves the maximum value from the dm_easy_mesh_t instance when its m_num_opclass is set to the maximum unsigned integer value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 356@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                              | Test Data                                                                                       | Expected Result                                                                          | Notes      |
 * | :--------------: | ---------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------- | ---------- |
 * | 01               | Initialize a dm_easy_mesh_t instance, set m_num_opclass to maximum unsigned int value, and call get_num_op_class | mesh pointer: m_num_opclass = std::numeric_limits<unsigned int>::max()                           | Returned value equals std::numeric_limits<unsigned int>::max() and EXPECT_EQ assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_op_class_boundary_max)
{
    const char *testName = "get_num_op_class_boundary_max";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_opclass = std::numeric_limits<unsigned int>::max();
    std::cout << "Invoking get_num_op_class(&mesh)" << std::endl;
    unsigned int result = dm_easy_mesh_t::get_num_op_class(&mesh);
    std::cout << "Retrieved num_op_class = " << result << std::endl;
    EXPECT_EQ(result, std::numeric_limits<unsigned int>::max());
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validates that get_num_op_class returns 0 when a nullptr is provided.
 *
 * This test case evaluates the behavior of the get_num_op_class API when invoked with a nullptr argument.
 * It ensures that the API safely handles a null pointer input without causing a crash and returns 0,
 * indicating the absence of any operational classes.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 357@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                               | Test Data                                  | Expected Result                            | Notes        |
 * | :--------------: | ----------------------------------------- | ------------------------------------------ | ------------------------------------------ | ------------ |
 * | 01               | Call get_num_op_class with a nullptr input| input = nullptr, output = undefined result | Return value equals 0 and assertion passes | Should Pass  |
 */
TEST(dm_easy_mesh_t, get_num_op_class_nullptr)
{
    const char *testName = "get_num_op_class_nullptr";
    std::cout << "Entering " << testName << " test" << std::endl;
    std::cout << "Invoking get_num_op_class(nullptr)" << std::endl;
    unsigned int result = dm_easy_mesh_t::get_num_op_class(nullptr);
    EXPECT_EQ(result, 0u);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Tests the retrieval of the default policy count using dm_easy_mesh_t object.
 *
 * This test validates that the get_num_policy() function correctly returns the number of policies set by default in the dm_easy_mesh_t object. It ensures that the API call executes normally and returns an unsigned integer value representing the policy count.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 358@n
 * **Priority:** High
 * 
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Instantiate dm_easy_mesh_t and invoke get_num_policy() | dm_easy_mesh_t obj; retVal = obj.get_num_policy() | retVal is an unsigned int representing the default policy count | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_policy_default) {
    std::cout << "Entering get_num_policy_default test" << std::endl;
    dm_easy_mesh_t obj;
    std::cout << "Invoking get_num_policy()" << std::endl;
    unsigned int retVal = obj.get_num_policy();
    std::cout << "Returned value from get_num_policy(): " << retVal << std::endl;    
    std::cout << "Exiting get_num_policy_default test" << std::endl;
}

/**
 * @brief Verify that get_num_policy returns the correct value when m_num_policy is set to 3
 *
 * This test confirms that when the m_num_policy member of dm_easy_mesh_t is set to 3, the get_num_policy function returns the correct value. The test validates the internal state of the object and ensures the API correctly reflects the assigned member value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 359@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | -------------- | ----- |
 * | 01 | Create an instance of dm_easy_mesh_t, set m_num_policy to 3, and invoke get_num_policy | m_num_policy = 3, retVal (output) should match m_num_policy value | Returns 3 and assertion (EXPECT_EQ) passes  | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_policy_returns_correct_value_3) {
    std::cout << "Entering get_num_policy_returns_correct_value_3 test" << std::endl;
    dm_easy_mesh_t obj;
    obj.m_num_policy = 3;    
    std::cout << "Invoking get_num_policy()" << std::endl;
    unsigned int retVal = obj.get_num_policy();
    std::cout << "Returned value from get_num_policy(): " << retVal << std::endl;
    EXPECT_EQ(retVal, 3u);    
    std::cout << "Exiting get_num_policy_returns_correct_value_3 test" << std::endl;
}

/**
 * @brief Test to verify that get_num_policy() returns UINT_MAX when m_num_policy is set to UINT_MAX
 *
 * This test case ensures that when the m_num_policy member variable of dm_easy_mesh_t is set to UINT_MAX, the method get_num_policy() properly returns UINT_MAX. This test validates the functionality of the getter method in successfully retrieving the maximum unsigned integer value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 360@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                       | Test Data                                                           | Expected Result                                  | Notes          |
 * | :--------------: | ----------------------------------------------------------------- | ------------------------------------------------------------------- | ------------------------------------------------ | -------------- |
 * | 01               | Print entering message                                            | No input, no output                                                  | "Entering get_num_policy_returns_UINT_MAX test" is printed | Should be successful |
 * | 02               | Create an instance of dm_easy_mesh_t                              | dm_easy_mesh_t object is constructed                                 | Object is created                                | Should be successful |
 * | 03               | Set m_num_policy to UINT_MAX                                        | m_num_policy = UINT_MAX                                               | m_num_policy is set to UINT_MAX                  | Should Pass    |
 * | 04               | Print the set m_num_policy value                                    | No direct input; object.m_num_policy = UINT_MAX                       | Printed message shows m_num_policy equals UINT_MAX| Should be successful |
 * | 05               | Call get_num_policy()                                               | Invoking get_num_policy()                                             | Returns UINT_MAX                                 | Should Pass    |
 * | 06               | Verify the returned value using EXPECT_EQ                           | retVal = UINT_MAX, expected = UINT_MAX                                | EXPECT_EQ passes verifying UINT_MAX is returned  | Should Pass    |
 * | 07               | Print exiting message                                               | No input, no output                                                  | "Exiting get_num_policy_returns_UINT_MAX test" is printed | Should be successful |
 */
TEST(dm_easy_mesh_t, get_num_policy_returns_UINT_MAX) {
    std::cout << "Entering get_num_policy_returns_UINT_MAX test" << std::endl;
    dm_easy_mesh_t obj;   
    obj.m_num_policy = UINT_MAX;
    std::cout << "Set m_num_policy to: " << obj.m_num_policy << std::endl;
    std::cout << "Invoking get_num_policy()" << std::endl;
    unsigned int retVal = obj.get_num_policy();
    std::cout << "Returned value from get_num_policy(): " << retVal << std::endl;
    EXPECT_EQ(retVal, UINT_MAX);    
    std::cout << "Exiting get_num_policy_returns_UINT_MAX test" << std::endl;
}

/**
 * @brief Test the functionality of get_num_policy() for a set value
 *
 * This test verifies that the get_num_policy() method correctly returns the value
 * stored in the m_num_policy member variable when it is set to 5. The test ensures that
 * the API functions as expected for a basic scenario.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 361@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object. | None | Object is instantiated successfully | Should be successful |
 * | 02 | Set m_num_policy to 5. | m_num_policy = 5 | m_num_policy member set to 5 | Should be successful |
 * | 03 | Invoke get_num_policy() method. | Function call: retVal = obj.get_num_policy() | The API returns the value 5 | Should Pass |
 * | 04 | Validate the return value using EXPECT_EQ. | retVal = returned value | EXPECT_EQ(retVal, 5u) assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_policy_returns_correct_value_5) {
    std::cout << "Entering get_num_policy_returns_correct_value_5 test" << std::endl;
    dm_easy_mesh_t obj;
    obj.m_num_policy = 5;
    std::cout << "Set m_num_policy to: " << obj.m_num_policy << std::endl;
    std::cout << "Invoking get_num_policy()" << std::endl;
    unsigned int retVal = obj.get_num_policy();
    std::cout << "Returned value from get_num_policy(): " << retVal << std::endl;
    EXPECT_EQ(retVal, 5u);    
    std::cout << "Exiting get_num_policy_returns_correct_value_5 test" << std::endl;
}

/**
 * @brief Tests the default behavior of the get_num_radios() method in dm_easy_mesh_t.
 *
 * This test creates a default instance of dm_easy_mesh_t and calls its get_num_radios() method.
 * It validates that the default number of radios returned is 0, ensuring proper initialization of the mesh object.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 362@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create a default dm_easy_mesh_t object, invoke get_num_radios(), and validate the returned radio count | mesh = {} (default constructed), get_num_radios() invoked, expected output: result = 0 | get_num_radios() returns 0 and EXPECT_EQ(result, 0u) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_radios_default)
{
    const char *testName = "get_num_radios_default";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    std::cout << "Invoking get_num_radios()" << std::endl;
    unsigned int result = mesh.get_num_radios();
    std::cout << "Retrieved num_radios = " << result << std::endl;
    EXPECT_EQ(result, 0u);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test the correct functionality of get_num_radios() for dm_easy_mesh_t
 *
 * This test verifies that the get_num_radios() method returns the correct number of configured radios after setting the m_num_radios property of the dm_easy_mesh_t object, ensuring that the getter reflects the updated value.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 363@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                              | Test Data                                            | Expected Result                                        | Notes            |
 * | :--------------: | -------------------------------------------------------- | ---------------------------------------------------- | ------------------------------------------------------ | ---------------- |
 * | 01               | Initialize dm_easy_mesh_t object and set m_num_radios.   | mesh.m_num_radios = 3                                  | dm_easy_mesh_t object is initialized with m_num_radios set to 3 | Should be successful |
 * | 02               | Invoke get_num_radios() API.                             | input: none, output: result from get_num_radios()       | Returned value equals 3                                 | Should Pass      |
 * | 03               | Validate the returned value using EXPECT_EQ.           | input: result value, expected value = 3                | EXPECT_EQ check confirms the returned value is 3         | Should Pass      |
 */
TEST(dm_easy_mesh_t, get_num_radios_configured)
{
    const char *testName = "get_num_radios_configured";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_radios = 3;
    std::cout << "Invoking get_num_radios()" << std::endl;
    unsigned int result = mesh.get_num_radios();
    std::cout << "Retrieved num_radios = " << result << std::endl;
    EXPECT_EQ(result, 3u);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test the get_num_radios() API with maximum boundary value for m_num_radios.
 *
 * This test verifies that the get_num_radios() API correctly returns the maximum possible unsigned integer value when mesh.m_num_radios is explicitly set to std::numeric_limits<unsigned int>::max(). It ensures that the API handles the boundary condition properly.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 364@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                        | Test Data                                                                  | Expected Result                                                                            | Notes       |
 * | :--------------: | ------------------------------------------------------------------ | -------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ | ----------- |
 * | 01               | Set m_num_radios to maximum unsigned integer and invoke get_num_radios() | mesh.m_num_radios = std::numeric_limits<unsigned int>::max()                | get_num_radios() returns std::numeric_limits<unsigned int>::max() and EXPECT_EQ passes        | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_radios_boundary_max)
{
    const char *testName = "get_num_radios_boundary_max";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_radios = std::numeric_limits<unsigned int>::max();
    std::cout << "Invoking get_num_radios()" << std::endl;
    unsigned int result = mesh.get_num_radios();
    std::cout << "Retrieved num_radios = " << result << std::endl;
    EXPECT_EQ(result, std::numeric_limits<unsigned int>::max());
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that the static function get_num_radios returns the correct number of radios
 *
 * This test case validates the proper functioning of the static API dm_easy_mesh_t::get_num_radios. It ensures that,
 * when provided with a valid pointer to a dm_easy_mesh_t instance where the m_num_radios member is initialized, the
 * function returns exactly the number of radios that was set. This test confirms that the API behaves as expected
 * under a valid scenario.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 365@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                              | Test Data                                           | Expected Result                                                               | Notes         |
 * | :--------------: | ------------------------------------------------------------------------ | --------------------------------------------------- | ----------------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize dm_easy_mesh_t with m_num_radios set to 2 and invoke get_num_radios | input: mesh pointer with m_num_radios = 2, output: expected result = 2  | API returns the value 2 and assertion EXPECT_EQ confirms the equality | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_num_radios_static_valid)
{
    const char *testName = "get_num_radios_static_valid";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_radios = 2;
    std::cout << "Invoking get_num_radios(&mesh)" << std::endl;
    unsigned int result = dm_easy_mesh_t::get_num_radios(&mesh);
    std::cout << "Retrieved num_radios = " << result << std::endl;
    EXPECT_EQ(result, 2u);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that dm_easy_mesh_t::get_num_radios returns 0 when a nullptr is passed.
 *
 * This test case verifies that the get_num_radios static function correctly handles a null pointer input by returning 0. This behavior is essential to prevent crashes or undefined behavior when an invalid pointer is provided.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 366@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                   | Test Data                                  | Expected Result                                        | Notes       |
 * | :--------------: | ------------------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------ | ----------- |
 * | 01               | Invoke get_num_radios with nullptr argument to validate proper handling of invalid input | input = nullptr, output = 0u                 | Return value equals 0u and assertion passes          | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_radios_static_nullptr)
{
    const char *testName = "get_num_radios_static_nullptr";
    std::cout << "Entering " << testName << " test" << std::endl;
    std::cout << "Invoking get_num_radios(nullptr)" << std::endl;
    unsigned int result = dm_easy_mesh_t::get_num_radios(nullptr);
    EXPECT_EQ(result, 0u);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that the default scan results count is zero.
 *
 * This test case verifies that upon initialization of the dm_easy_mesh_t object,
 * the get_num_scan_results() API returns zero, ensuring that no scan results exist by default.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 367@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                              | Test Data                                                     | Expected Result                                                      | Notes      |
 * | :--------------: | ---------------------------------------------------------------------------------------- | ------------------------------------------------------------- | -------------------------------------------------------------------- | ---------- |
 * | 01               | Initialize dm_easy_mesh_t instance, invoke init(), call get_num_scan_results(), and verify the returned count is zero. | mesh: instance of dm_easy_mesh_t, call: get_num_scan_results(), expected output: count = 0 | get_num_scan_results() returns 0 and EXPECT_EQ(count, 0u) assertion passes. | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_scan_results_default)
{
    const char *testName = "get_num_scan_results_default";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    std::cout << "Invoking get_num_scan_results()" << std::endl;
    unsigned int count = mesh.get_num_scan_results();
    std::cout << "Retrieved scan result count = " << count << std::endl;
    EXPECT_EQ(count, 0u);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that an empty mesh returns 0 scan results.
 *
 * This test verifies that when a dm_easy_mesh_t object is initialized without any scan results added, calling get_num_scan_results() returns 0. This ensures the function correctly handles the case of an empty map.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 368@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                     | Test Data                                  | Expected Result                                                  | Notes       |
 * | :--------------: | :-------------------------------------------------------------- | :----------------------------------------- | :--------------------------------------------------------------- | :---------- |
 * | 01               | Initialize the dm_easy_mesh_t object and call init()             | mesh object, no input, init() called       | Mesh object is successfully initialized                        | Should Pass |
 * | 02               | Invoke get_num_scan_results() on the empty mesh                   | No input, output: count = 0u                 | Function returns a scan result count of 0 and EXPECT_EQ assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_scan_results_empty_map)
{
    const char *testName = "get_num_scan_results_empty_map";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    std::cout << "Invoking get_num_scan_results() on empty map" << std::endl;
    unsigned int count = mesh.get_num_scan_results();
    std::cout << "Retrieved scan result count = " << count << std::endl;
    EXPECT_EQ(count, 0u);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_num_scan_results() returns 0 when invoked on a mesh with a null map.
 *
 * This test verifies that the dm_easy_mesh_t API correctly handles the scenario where its underlying map is null.
 * It ensures that the function returns 0 and does not crash, maintaining robustness in edge-case conditions.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 369@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                      | Test Data                                              | Expected Result                                             | Notes            |
 * | :----:           | ---------------------------------------------------------------- | ------------------------------------------------------ | ----------------------------------------------------------- | ---------------- |
 * | 01               | Initialize dm_easy_mesh_t object and print the test entry message. | None                                                   | Test environment initialized; entry message printed         | Should be successful |
 * | 02               | Invoke get_num_scan_results() on the mesh to simulate a null map.     | mesh object, mapping pointer is null internally         | Returns 0u; assertion EXPECT_EQ(count, 0u) passes             | Should Pass      |
 * | 03               | Print the test exit message.                                        | None                                                   | End of test log message printed                                | Should be successful |
 */
TEST(dm_easy_mesh_t, get_num_scan_results_null_map_crash)
{
    const char *testName = "get_num_scan_results_null_map_crash";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    std::cout << "Invoking get_num_scan_results() with NULL map" << std::endl;
    unsigned int count = mesh.get_num_scan_results();
    EXPECT_EQ(count, 0u);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that a single scan result entry is correctly registered and retrieved.
 *
 * This test initializes a dm_easy_mesh_t object, sets up a single scan result entry using an em_scan_result_id_t structure, 
 * invokes the creation of a new scan result, and finally checks if the number of scan results retrieved matches the expected value of 1.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 370@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Call the init function of dm_easy_mesh_t to initialize the object. | None | The object is initialized successfully. | Should be successful |
 * | 02 | Populate em_scan_result_id_t structure with a single scan entry data. | net_id = "net1", dev_mac = {0x10,0x11,0x12,0x13,0x14,0x15}, scanner_mac = {0x20,0x21,0x22,0x23,0x24,0x25}, op_class = 81, channel = 6, scanner_type = em_scanner_type_radio | Structure is set correctly with all fields assigned. | Should be successful |
 * | 03 | Call create_new_scan_result with the populated id. | id = configured structure from step 02 | A new scan result record is created without error. | Should Pass |
 * | 04 | Call get_num_scan_results to retrieve the count of scan results. | None | Returns a count of 1, matching the created scan entry. | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_scan_results_single_entry)
{
    const char *testName = "get_num_scan_results_single_entry";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    em_scan_result_id_t id{};
    strncpy(id.net_id, "net1", sizeof(id.net_id) - 1);
    unsigned char dev_mac[6]     = {0x10, 0x11, 0x12, 0x13, 0x14, 0x15};
    unsigned char scanner_mac[6] = {0x20, 0x21, 0x22, 0x23, 0x24, 0x25};
    memcpy(id.dev_mac, dev_mac, sizeof(mac_address_t));
    memcpy(id.scanner_mac, scanner_mac, sizeof(mac_address_t));
    id.op_class     = 81;
    id.channel      = 6;
    id.scanner_type = em_scanner_type_radio;
    mesh.create_new_scan_result(&id);
    std::cout << "Invoking get_num_scan_results()" << std::endl;
    unsigned int count = mesh.get_num_scan_results();
    std::cout << "Retrieved scan result count = " << count << std::endl;
    EXPECT_EQ(count, 1u);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_num_scan_results() returns the correct count when multiple entries are added
 *
 * This test creates three scan result entries using create_new_scan_result() in a dm_easy_mesh_t object and then verifies that the get_num_scan_results() API returns the value 3. The test ensures that the API correctly handles multiple scan result entries.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 371@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize the dm_easy_mesh_t object, add three scan result entries, and invoke get_num_scan_results() | For each entry: net_id = net0, net1, net2; dev_mac = {0x10, 0x11, 0x12, 0x13, 0x14, 0x00/0x01/0x02}; scanner_mac = {0x20, 0x21, 0x22, 0x23, 0x24, 0x01/0x02/0x03}; op_class = 80, 81, 82; channel = 1, 2, 3; scanner_type = em_scanner_type_sta; | get_num_scan_results() returns count = 3 and EXPECT_EQ(count, 3u) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_num_scan_results_multiple_entries)
{
    const char *testName = "get_num_scan_results_multiple_entries";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    for (int i = 0; i < 3; ++i) {
        em_scan_result_id_t id{};
        snprintf(id.net_id, sizeof(id.net_id), "net%d", i);
        unsigned char dev_mac[6]     = {0x10, 0x11, 0x12, 0x13, 0x14, (unsigned char)i};
        unsigned char scanner_mac[6] = {0x20, 0x21, 0x22, 0x23, 0x24, (unsigned char)(i + 1)};
        memcpy(id.dev_mac, dev_mac, sizeof(mac_address_t));
        memcpy(id.scanner_mac, scanner_mac, sizeof(mac_address_t));
        id.op_class     = 80 + i;
        id.channel      = 1 + i;
        id.scanner_type = em_scanner_type_sta;
        mesh.create_new_scan_result(&id);
    }
    std::cout << "Invoking get_num_scan_results()" << std::endl;
    unsigned int count = mesh.get_num_scan_results();
    std::cout << "Retrieved scan result count = " << count << std::endl;
    EXPECT_EQ(count, 3u);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_op_class returns a valid pointer when provided with a valid index
 *
 * This test verifies that get_op_class correctly retrieves the pointer to the operation class structure from the mesh when a valid index is provided. It checks that the returned pointer is not null and that the operation class information (op_class, channel, tx_power) is correctly set.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 372@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize a mesh object and set operation class data at a valid index | index = 1, m_num_opclass = 2, op_class = 116, channel = 44, tx_power = 20 | Mesh object is configured with the expected operation class data | Should be successful |
 * | 02 | Invoke get_op_class with the valid index | input: index = 1 | Returns a valid (non-null) pointer to dm_op_class_t | Should Pass |
 * | 03 | Verify the retrieved op_class data | output: op_class pointer values: op_class = 116, channel = 44, tx_power = 20 | The op_class structure contains the correct values | Should Pass |
 */
TEST(dm_easy_mesh_t, get_op_class_valid_index)
{
    const char* testName = "get_op_class_valid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    unsigned int index = 1;
    mesh.m_num_opclass = 2;
    mesh.m_op_class[index].m_op_class_info.op_class = 116;
    mesh.m_op_class[index].m_op_class_info.channel = 44;
    mesh.m_op_class[index].m_op_class_info.tx_power = 20;
    std::cout << "Invoking get_op_class(" << index << ")" << std::endl;
    dm_op_class_t *op = mesh.get_op_class(index);
    EXPECT_NE(op, nullptr);
    if (op) {
        std::cout << "Retrieved op_class pointer: " << op << std::endl;
        std::cout << "op_class: " << op->m_op_class_info.op_class << std::endl;
        std::cout << "channel: " << op->m_op_class_info.channel << std::endl;
        std::cout << "tx_power: " << op->m_op_class_info.tx_power << std::endl;
    }
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Tests get_op_class function with an out-of-range index.
 *
 * This test verifies that dm_easy_mesh_t's get_op_class returns a nullptr when provided with an index that exceeds the valid range.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 373@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- | -------------- | ----- |
 * | 01 | Print test entry message | N/A | Message printed to stdout | Should be successful |
 * | 02 | Initialize dm_easy_mesh_t and set m_num_opclass to 1 | mesh.m_num_opclass = 1 | Object initialized with m_num_opclass set | Should be successful |
 * | 03 | Set the index to EM_MAX_OPCLASS + 1 and print invocation message | index = EM_MAX_OPCLASS + 1 | Message printed to stdout indicating out of range index | Should be successful |
 * | 04 | Invoke get_op_class with the out-of-range index | input: index = EM_MAX_OPCLASS + 1, output: op expected nullptr | EXPECT_EQ(op, nullptr) assertion passes | Should Pass |
 * | 05 | Print test exit message | N/A | Message printed to stdout | Should be successful |
 */
TEST(dm_easy_mesh_t, get_op_class_out_of_range_index)
{
    const char* testName = "get_op_class_out_of_range_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_opclass = 1;
    unsigned int index = EM_MAX_OPCLASS + 1;
    std::cout << "Invoking get_op_class(" << index << ") [OUT OF RANGE]" << std::endl;
    dm_op_class_t *op = mesh.get_op_class(index);
    EXPECT_EQ(op, nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_op_class_by_ref returns correct reference when provided with a valid index
 *
 * This test ensures that invoking get_op_class_by_ref with a valid index correctly returns a reference to the op_class element. The test verifies that the operation class details (op_class, channel, and tx_power) match the expected values, ensuring the proper functioning of the method when the mesh is configured with valid op_class data.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 374@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                         | Test Data                                                                                             | Expected Result                                      | Notes           |
 * | :--------------: | ------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | ---------------------------------------------------- | --------------- |
 * | 01               | Initialize mesh structure and populate first op_class details       | m_num_opclass = 1, m_op_class[0].m_op_class_info.op_class = 81, m_op_class[0].m_op_class_info.channel = 6, m_op_class[0].m_op_class_info.tx_power = 18 | Mesh structure is set with valid values              | Should be successful |
 * | 02               | Call get_op_class_by_ref with index 0 to retrieve the op_class reference | index = 0                                                                                             | Valid reference is returned                          | Should Pass     |
 * | 03               | Validate op_class values through the returned reference               | Expected op_class = 81, channel = 6, tx_power = 18                                                    | op_class, channel, and tx_power match expected values  | Should Pass     |
 */
TEST(dm_easy_mesh_t, get_op_class_by_ref_valid_index)
{
    const char* testName = "get_op_class_by_ref_valid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    unsigned int index = 0;
    mesh.m_num_opclass = 1;
    mesh.m_op_class[index].m_op_class_info.op_class = 81;
    mesh.m_op_class[index].m_op_class_info.channel = 6;
    mesh.m_op_class[index].m_op_class_info.tx_power = 18;
    std::cout << "Invoking get_op_class_by_ref(" << index << ")" << std::endl;
    dm_op_class_t &op = mesh.get_op_class_by_ref(index);
    std::cout << "Retrieved op_class reference address: " << &op << std::endl;
    std::cout << "op_class: " << op.m_op_class_info.op_class << std::endl;
    std::cout << "channel: " << op.m_op_class_info.channel << std::endl;
    std::cout << "tx_power: " << op.m_op_class_info.tx_power << std::endl;
    EXPECT_EQ(op.m_op_class_info.op_class, 81);
    EXPECT_EQ(op.m_op_class_info.channel, 6);
    EXPECT_EQ(op.m_op_class_info.tx_power, 18);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_op_class_info returns correct op class information for a valid index.
 *
 * This test sets up a dm_easy_mesh_t instance with a valid operational class entry, then calls the
 * get_op_class_info() API with a valid index. It verifies that the returned pointer is not null and that
 * the contents (op_class, channel, tx_power, and max_tx_power) match the expected values. This ensures that
 * the API correctly retrieves the operational class information when provided with a valid index.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 375@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                      | Test Data                                                                                         | Expected Result                                                                                                                       | Notes       |
 * | :--------------: | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- | ----------- |
 * | 01               | Initialize dm_easy_mesh_t structure with valid op_class values and invoke get_op_class_info API. | index = 0, m_num_opclass = 1, op_class = 81, channel = 6, tx_power = 18, max_tx_power = 20, output = pointer | Returned pointer is not null; op_class equals 81, channel equals 6, tx_power equals 18, and max_tx_power equals 20. | Should Pass |
 */
TEST(dm_easy_mesh_t, get_op_class_info_valid_index)
{
    const char *testName = "get_op_class_info_valid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    unsigned int index = 0;
    mesh.m_num_opclass = 1;
    mesh.m_op_class[index].m_op_class_info.op_class = 81;
    mesh.m_op_class[index].m_op_class_info.channel = 6;
    mesh.m_op_class[index].m_op_class_info.tx_power = 18;
    mesh.m_op_class[index].m_op_class_info.max_tx_power = 20;
    std::cout << "Invoking get_op_class_info(" << index << ")" << std::endl;
    em_op_class_info_t *info = mesh.get_op_class_info(index);
    EXPECT_NE(info, nullptr);
    if (info) {
        std::cout << "Retrieved op_class_info pointer: " << info << std::endl;
        std::cout << "op_class: " << info->op_class << std::endl;
        std::cout << "channel: " << info->channel << std::endl;
        std::cout << "tx_power: " << info->tx_power << std::endl;
        std::cout << "max_tx_power: " << info->max_tx_power << std::endl;
    }
    EXPECT_EQ(info->op_class, 81u);
    EXPECT_EQ(info->channel, 6u);
    EXPECT_EQ(info->tx_power, 18);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_op_class_info returns a null pointer when queried with an out-of-range index.
 *
 * This test verifies that calling get_op_class_info with an index greater than the valid range (EM_MAX_OPCLASS)
 * correctly returns a nullptr. This ensures that the API properly handles invalid index accesses, preventing potential
 * memory issues or undefined behavior.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 376@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create a dm_easy_mesh_t object and set its m_num_opclass to 1 | mesh.m_num_opclass = 1 | dm_easy_mesh_t object is initialized with m_num_opclass = 1 | Should be successful |
 * | 02 | Invoke get_op_class_info with an out-of-range index (EM_MAX_OPCLASS + 1) and verify it returns nullptr | input: index = EM_MAX_OPCLASS+1, output: info = nullptr | get_op_class_info returns nullptr indicating proper handling of an invalid index | Should Pass |
 */
TEST(dm_easy_mesh_t, get_op_class_info_out_of_range)
{
    const char *testName = "get_op_class_info_out_of_range";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_opclass = 1;
    unsigned int index = EM_MAX_OPCLASS + 1;
    std::cout << "Invoking get_op_class_info(" << index << ") [OUT OF RANGE]" << std::endl;
    em_op_class_info_t *info = mesh.get_op_class_info(index);
    EXPECT_EQ(info, nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate retrieval of operational class information using a valid index.
 *
 * This test verifies that when a valid index is provided for retrieval of the operational class information from the mesh object,
 * the API returns a valid pointer and the retrieved data matches the expected values. The check ensures that the API correctly
 * handles a properly initialized mesh structure with a valid index.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 377@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object with a valid operational class entry, invoke get_op_class_info with valid index | mesh.m_num_opclass = 2, index = 1, op_class = 116, channel = 44, tx_power = 23, max_tx_power = 30 | API returns a non-null pointer and the op_class_info structure contains op_class = 116, channel = 44, tx_power = 23, and max_tx_power = 30 | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_op_class_info_valid_index)
{
    const char *testName = "static_get_op_class_info_valid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    unsigned int index = 1;
    mesh.m_num_opclass = 2;
    mesh.m_op_class[index].m_op_class_info.op_class = 116;
    mesh.m_op_class[index].m_op_class_info.channel = 44;
    mesh.m_op_class[index].m_op_class_info.tx_power = 23;
    mesh.m_op_class[index].m_op_class_info.max_tx_power = 30;
    std::cout << "Invoking static get_op_class_info(dm, " << index << ")" << std::endl;
    em_op_class_info_t *info = dm_easy_mesh_t::get_op_class_info(&mesh, index);
    EXPECT_NE(info, nullptr);
    if (info) {
        std::cout << "Retrieved op_class_info pointer: " << info << std::endl;
        std::cout << "op_class: " << info->op_class << std::endl;
        std::cout << "channel: " << info->channel << std::endl;
        std::cout << "tx_power: " << info->tx_power << std::endl;
        std::cout << "max_tx_power: " << info->max_tx_power << std::endl;
    }
    EXPECT_EQ(info->op_class, 116u);
    EXPECT_EQ(info->channel, 44u);
    EXPECT_EQ(info->tx_power, 23);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_op_class_info returns nullptr when provided with an out-of-range index.
 *
 * This test verifies that providing an index greater than the maximum allowed op class index (EM_MAX_OPCLASS) to the static_get_op_class_info method results in a nullptr being returned. This behavior is essential to ensure that the function correctly handles invalid index inputs.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 378@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize a mesh object and set op class count | mesh instance created, mesh.m_num_opclass = 1 | Mesh object initialized with op class count = 1 | Should be successful |
 * | 02 | Calculate out-of-range index value | index = EM_MAX_OPCLASS, offset = 10, resulting in index = EM_MAX_OPCLASS + 10 | Index value is out-of-range | Should be successful |
 * | 03 | Invoke static_get_op_class_info with out-of-range index and verify the return value | mesh pointer, index = EM_MAX_OPCLASS + 10, expected: info = nullptr | Function returns nullptr and assertion EXPECT_EQ(info, nullptr) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_op_class_info_out_of_range)
{
    const char *testName = "static_get_op_class_info_out_of_range";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_opclass = 1;
    unsigned int index = EM_MAX_OPCLASS + 10;
    std::cout << "Invoking static get_op_class_info(dm, " << index << ") [OUT OF RANGE]" << std::endl;
    em_op_class_info_t *info = dm_easy_mesh_t::get_op_class_info(&mesh, index);
    EXPECT_EQ(info, nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_opclass_info_for_bss returns the correct op_class_info when matching by BSSID.
 *
 * This test verifies that the get_opclass_info_for_bss function correctly identifies and returns the op_class_info structure when provided with a BSSID that matches the stored entry within the mesh structure.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 379@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke get_opclass_info_for_bss with a matching BSSID and NULL as second parameter | input: bssid = 00:11:22:33:44:55, second parameter = NULL; pre-configured mesh: m_num_opclass = 1, op_class = 81, channel = 6, tx_power = 20 | Returns non-null pointer with op_class equal to 81, channel equal to 6, and tx_power equal to 20 | Should Pass |
 */
TEST(dm_easy_mesh_t, get_opclass_info_for_bss_match_bssid_only)
{
    const char *testName = "get_opclass_info_for_bss_match_bssid_only";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_opclass = 1;
    mac_address_t bssid = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
    memcpy(mesh.m_op_class[0].m_op_class_info.id.ruid, bssid, ETH_ALEN);
    mesh.m_op_class[0].m_op_class_info.op_class = 81;
    mesh.m_op_class[0].m_op_class_info.channel = 6;
    mesh.m_op_class[0].m_op_class_info.tx_power = 20;
    std::cout << "Invoking get_opclass_info_for_bss(bssid, NULL)" << std::endl;
    em_op_class_info_t *info = mesh.get_opclass_info_for_bss(bssid, NULL);
    EXPECT_NE(info, nullptr);
    if (info) {
        std::cout << "Retrieved op_class_info pointer: " << info << std::endl;
        std::cout << "op_class: " << info->op_class << std::endl;
        std::cout << "channel: " << info->channel << std::endl;
        std::cout << "tx_power: " << info->tx_power << std::endl;
    }
    EXPECT_EQ(info->op_class, 81u);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_opclass_info_for_bss returns the correct op_class_info pointer for a matching BSSID and op_class.
 *
 * This test validates that when the DM Easy Mesh instance is populated with multiple op_class entries, calling
 * get_opclass_info_for_bss with a matching BSSID and op_class returns the proper op_class_info pointer. The test
 * sets up two entries where only one entry has the op_class matching the specified wanted_opclass, and asserts that the
 * returned pointer is not null and that its op_class field equals the wanted_opclass.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 380@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                      | Test Data                                                                                                                                                  | Expected Result                                          | Notes      |
 * | :--------------: | ------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------- | ---------- |
 * | 01               | Initialize mesh object with two op_class entries, set BSSID and op_class values, then invoke get_opclass_info_for_bss. | mesh.m_num_opclass = 2, first entry: op_class = 81, second entry: op_class = 115, bssid = "AA,BB,CC,DD,EE,FF", wanted_opclass = 115, channel = 36 | Returned pointer is not null and info->op_class equals 115 | Should Pass |
 */
TEST(dm_easy_mesh_t, get_opclass_info_for_bss_match_bssid_and_opclass)
{
    const char *testName = "get_opclass_info_for_bss_match_bssid_and_opclass";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_opclass = 2;
    mac_address_t bssid = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    unsigned int wanted_opclass = 115;
    memcpy(mesh.m_op_class[0].m_op_class_info.id.ruid, bssid, ETH_ALEN);
    mesh.m_op_class[0].m_op_class_info.op_class = 81;
    memcpy(mesh.m_op_class[1].m_op_class_info.id.ruid, bssid, ETH_ALEN);
    mesh.m_op_class[1].m_op_class_info.op_class = wanted_opclass;
    mesh.m_op_class[1].m_op_class_info.channel = 36;
    std::cout << "Invoking get_opclass_info_for_bss(bssid, &op_class)" << std::endl;
    em_op_class_info_t *info = mesh.get_opclass_info_for_bss(bssid, &wanted_opclass);
    EXPECT_NE(info, nullptr);
    if (info) {
        std::cout << "Retrieved op_class_info pointer: " << info << std::endl;
        std::cout << "op_class: " << info->op_class << std::endl;
        std::cout << "channel: " << info->channel << std::endl;
    }
    EXPECT_EQ(info->op_class, wanted_opclass);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_opclass_info_for_bss returns nullptr for a non-existent BSSID
 *
 * This test checks that when get_opclass_info_for_bss is invoked with a BSSID that is not present
 * in the mesh op class data, the API correctly returns a null pointer indicating that no matching entry was found.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 381@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                            | Test Data                                                                                          | Expected Result                                                                 | Notes            |
 * | :--------------: | ---------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- | ---------------- |
 * | 01               | Initialize mesh instance and set op class parameters with valid values   | m_num_opclass = 1, existing_bssid = 00:00:00:00:00:01, op_class = 81                                | Mesh instance is configured with one valid op class entry                       | Should be successful |
 * | 02               | Invoke get_opclass_info_for_bss with a non-existent BSSID                | search_bssid = FF:FF:FF:FF:FF:FF, second argument = NULL                                            | API returns nullptr and the assertion EXPECT_EQ(info, nullptr) passes             | Should Pass      |
 */
TEST(dm_easy_mesh_t, get_opclass_info_for_bss_bssid_not_found)
{
    const char *testName = "get_opclass_info_for_bss_bssid_not_found";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_opclass = 1;
    mac_address_t existing_bssid = {0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
    mac_address_t search_bssid   = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    memcpy(mesh.m_op_class[0].m_op_class_info.id.ruid, existing_bssid, ETH_ALEN);
    mesh.m_op_class[0].m_op_class_info.op_class = 81;
    std::cout << "Invoking get_opclass_info_for_bss(bssid_not_present)" << std::endl;
    em_op_class_info_t *info = mesh.get_opclass_info_for_bss(search_bssid, NULL);
    EXPECT_EQ(info, nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test get_opclass_info_for_bss returns nullptr when opclass from BSS mismatches the wanted opclass.
 *
 * This test case verifies that the function get_opclass_info_for_bss returns a null pointer when the opclass
 * provided by the BSS does not match the wanted opclass. The mesh instance is configured with one opclass,
 * and the BSSID is set with an opclass of 81 while the function is invoked with a wanted opclass of 116. 
 * The EXPECT_EQ assertion checks that the returned pointer is indeed nullptr.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 382@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                              | Test Data                                                                                                          | Expected Result                                          | Notes      |
 * | :--------------: | ------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------- | ---------- |
 * | 01               | Set up the mesh instance with a single opclass and BSSID, invoke get_opclass_info_for_bss | mesh.m_num_opclass = 1, bssid = 10:20:30:40:50:60, mesh.m_op_class[0].m_op_class_info.op_class = 81, wanted_opclass = 116 | Returns nullptr; EXPECT_EQ(info, nullptr) assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_opclass_info_for_bss_opclass_mismatch)
{
    const char *testName = "get_opclass_info_for_bss_opclass_mismatch";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_opclass = 1;
    mac_address_t bssid = {0x10, 0x20, 0x30, 0x40, 0x50, 0x60};
    unsigned int wanted_opclass = 116;
    memcpy(mesh.m_op_class[0].m_op_class_info.id.ruid, bssid, ETH_ALEN);
    mesh.m_op_class[0].m_op_class_info.op_class = 81;
    std::cout << "Invoking get_opclass_info_for_bss(bssid, &op_class_mismatch)" << std::endl;
    em_op_class_info_t *info = mesh.get_opclass_info_for_bss(bssid, &wanted_opclass);
    EXPECT_EQ(info, nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate get_opclass_info_for_bss returns nullptr when no opclasses are available
 *
 * This test verifies that invoking get_opclass_info_for_bss with a valid BSSID and without any operational classes configured (m_num_opclass = 0) correctly results in a nullptr response. This ensures the API properly handles cases when no operational classes are present.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 383@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke get_opclass_info_for_bss with a BSSID when no opclasses are configured | m_num_opclass = 0, bssid = {0x01,0x02,0x03,0x04,0x05,0x06}, second parameter = NULL | Return value is nullptr and EXPECT_EQ(info, nullptr) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_opclass_info_for_bss_no_opclasses)
{
    const char *testName = "get_opclass_info_for_bss_no_opclasses";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh{};
    mesh.m_num_opclass = 0;
    mac_address_t bssid = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06};
    std::cout << "Invoking get_opclass_info_for_bss(bssid) with no opclasses" << std::endl;
    em_op_class_info_t *info = mesh.get_opclass_info_for_bss(bssid, NULL);
    EXPECT_EQ(info, nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that the default dm_easy_mesh_t instance returns a valid platform string.
 *
 * This test verifies that invoking get_platform() on a newly constructed default dm_easy_mesh_t instance returns a non-null, non-empty string.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 384@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                  | Test Data                                                                                           | Expected Result                                           | Notes              |
 * | :--------------: | ------------------------------------------------------------ | --------------------------------------------------------------------------------------------------- | --------------------------------------------------------- | ------------------ |
 * | 01               | Create a default instance of dm_easy_mesh_t                   | None                                                                                                | Instance created successfully                             | Should be successful |
 * | 02               | Call get_platform() method on the instance                    | input: default instance; output: pointer to platform string                                         | Returns a valid, non-null pointer with non-zero length string | Should Pass        |
 * | 03               | Validate the returned platform string using assertions         | output: get_platform() result (platform pointer); expected: platform != nullptr, strlen(platform) > 0 | Assertions pass: ASSERT_NE(platform, nullptr) and ASSERT_GT(strlen(platform),0)  | Should be successful |
 */
TEST(dm_easy_mesh_t, get_platform_valid_default_instance) {
    std::cout << "Entering get_platform_valid_default_instance test" << std::endl;
    dm_easy_mesh_t device;
    std::cout << "Created default dm_easy_mesh_t instance" << std::endl;
    std::cout << "Invoking get_platform() method on default instance" << std::endl;
    const char *platform = device.get_platform();
    std::cout << "Retrieved platform: " << (platform ? platform : "NULL") << std::endl;
    ASSERT_NE(platform, nullptr);
    ASSERT_GT(std::strlen(platform), 0u);
    std::cout << "Exiting get_platform_valid_default_instance test" << std::endl;
}

/**
 * @brief Verify that get_policy returns the correct policy for a valid index
 *
 * This test verifies that when a valid index is provided to the get_policy method, the corresponding policy is correctly retrieved. 
 * The mesh is initialized with two policies, where the second policy's type is set to em_policy_id_type_traffic_separation.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 385@n
 * **Priority:** High
 * 
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                  | Test Data                                                                                                                                                             | Expected Result                                                                                                  | Notes            |
 * | :--------------: | -------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- | ---------------- |
 * | 01               | Initialize dm_easy_mesh_t object with two policies and assign the policy types accordingly.    | mesh.m_num_policy = 2, m_policy[0].m_policy.id.type = em_policy_id_type_steering_local, m_policy[1].m_policy.id.type = em_policy_id_type_traffic_separation | Mesh object should be initialized with the two policies set with the correct types.                              | Should be successful |
 * | 02               | Invoke get_policy with valid index 1 to retrieve the second policy.                          | index = 1, API call: get_policy(1)                                                                                                                                     | The API returns a pointer to the policy whose type is em_policy_id_type_traffic_separation.                       | Should Pass      |
 * | 03               | Validate the retrieved policy's type using EXPECT_EQ assertion.                              | output1 = policy->m_policy.id.type, expected = em_policy_id_type_traffic_separation                                                                                   | The retrieved policy type should equal em_policy_id_type_traffic_separation and the assertion should pass.         | Should Pass      |
 */
TEST(dm_easy_mesh_t, get_policy_valid_index)
{
    const char* testName = "get_policy_valid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_policy = 2;
    mesh.m_policy[0].m_policy.id.type = em_policy_id_type_steering_local;
    mesh.m_policy[1].m_policy.id.type = em_policy_id_type_traffic_separation;
    unsigned int index = 1;
    std::cout << "Invoking get_policy(" << index << ")" << std::endl;
    dm_policy_t* policy = mesh.get_policy(index);
    std::cout << "Retrieved policy type = " << policy->m_policy.id.type << std::endl;
    EXPECT_EQ(policy->m_policy.id.type, em_policy_id_type_traffic_separation);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test get_policy API with an invalid index
 *
 * This test verifies that the get_policy function of the dm_easy_mesh_t class returns a nullptr
 * when an invalid index, which is out of the range of available policies, is provided. This ensures 
 * that the API handles boundary conditions correctly.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 386@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                             | Test Data                                                  | Expected Result                                                | Notes          |
 * | :--------------: | ------------------------------------------------------- | ---------------------------------------------------------- | -------------------------------------------------------------- | -------------- |
 * | 01               | Setup dm_easy_mesh_t instance and assign num_policy     | mesh.m_num_policy = 1                                      | Instance created with m_num_policy set to 1                     | Should be successful |
 * | 02               | Invoke get_policy with an invalid index                 | index = 5, call: dm_policy_t* policy = mesh.get_policy(5)    | get_policy returns nullptr; EXPECT_EQ(policy, nullptr) passes     | Should Pass    |
 */
TEST(dm_easy_mesh_t, get_policy_invalid_index)
{
    const char* testName = "get_policy_invalid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_policy = 1;
    unsigned int index = 5;
    std::cout << "Invoking get_policy(" << index << ")" << std::endl;
    dm_policy_t* policy = mesh.get_policy(index);
    EXPECT_EQ(policy, nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test get_policy_by_ref with a valid index.
 *
 * This test verifies that the dm_easy_mesh_t::get_policy_by_ref API correctly returns a reference to the
 * policy at the specified valid index. The test sets up a mesh instance with one policy, assigns the policy type,
 * and then calls the API using index 0. The returned policy's type is checked against the expected value to ensure
 * correctness of the method.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 387@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t instance, set m_num_policy to 1, and assign policy type to em_policy_id_type_steering_btm | mesh.m_num_policy = 1, mesh.m_policy[0].m_policy.id.type = em_policy_id_type_steering_btm | Mesh initialization is successful | Should be successful |
 * | 02 | Invoke get_policy_by_ref with index 0 | index = 0 | Function returns a reference to the policy with m_policy.id.type equal to em_policy_id_type_steering_btm | Should Pass |
 * | 03 | Verify that the returned policy type matches em_policy_id_type_steering_btm | output: policy.m_policy.id.type = em_policy_id_type_steering_btm | EXPECT_EQ passes confirming the correct policy type is retrieved | Should Pass |
 */
TEST(dm_easy_mesh_t, get_policy_by_ref_valid_index)
{
    const char* testName = "get_policy_by_ref_valid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_policy = 1;
    mesh.m_policy[0].m_policy.id.type = em_policy_id_type_steering_btm;
    unsigned int index = 0;
    std::cout << "Invoking get_policy_by_ref(" << index << ")" << std::endl;
    dm_policy_t& policy = mesh.get_policy_by_ref(index);
    std::cout << "Retrieved policy type = " << policy.m_policy.id.type << std::endl;
    EXPECT_EQ(policy.m_policy.id.type, em_policy_id_type_steering_btm);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test to verify that get_primary_device_type() returns the correct primary device type.
 *
 * This test verifies that when the primary device type is set to "router" in the mesh object, the get_primary_device_type() API correctly retrieves and returns "router". The test ensures the functionality of the API call and validates that the output matches the expected value.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 388@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                                                          | Expected Result                                                                                           | Notes           |
 * | :--------------: | --------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | --------------- |
 * | 01               | Initialize test variables and set primary device type to "router".           | input: primary_device_type = "router"                                                                | Primary device type in the mesh object is successfully set to "router".                                   | Should be successful |
 * | 02               | Invoke the get_primary_device_type() API.                                   | input: dm_easy_mesh_t object with primary_device_type set, output: deviceType variable                | API call returns a non-null pointer containing the string "router".                                       | Should Pass     |
 * | 03               | Validate the output using an assertion to compare the retrieved string.      | input: expected output "router", actual output stored in deviceType                                  | EXPECT_STREQ assertion passes confirming that deviceType equals "router".                                 | Should Pass     |
 */
TEST(dm_easy_mesh_t, get_primary_device_type_valid)
{
    const char* testName = "get_primary_device_type_valid";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    strncpy(mesh.m_device.m_device_info.primary_device_type, "router", sizeof(mesh.m_device.m_device_info.primary_device_type));
    std::cout << "Invoking get_primary_device_type()" << std::endl;
    char* deviceType = mesh.get_primary_device_type();
    std::cout << "Retrieved primary device type = " << (deviceType ? deviceType : "NULL") << std::endl;
    EXPECT_STREQ(deviceType, "router");
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test retrieval of prioritized interface for a valid Ethernet configuration.
 *
 * This test verifies that the API get_prioritized_interface correctly returns the interface "eth0" when the mesh is configured with one Ethernet preference and one interface, and the provided platform is "rpi". The test ensures that the returned interface pointer is not NULL and that the interface name matches "eth0".
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 389@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                             | Test Data                                                                                                                                               | Expected Result                                                                           | Notes      |
 * | :--------------: | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | ---------- |
 * | 01               | Initialize mesh with one Ethernet preference and one interface, then call get_prioritized_interface   | m_num_preferences = 1, preference[0].platform = "rpi", preference[0].media = em_media_type_ieee8023ab, m_num_interfaces = 1, interface[0].name = "eth0", platform = "rpi" | Returns pointer to interface with name "eth0", assertions EXPECT_TRUE and EXPECT_STREQ pass | Should Pass |
 */
TEST(dm_easy_mesh_t, get_prioritized_interface_valid_eth)
{
    const char* testName = "get_prioritized_interface_valid_eth";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_preferences = 1;
    strncpy(mesh.m_preference[0].platform, "rpi", sizeof(mesh.m_preference[0].platform));
    mesh.m_preference[0].media = em_media_type_ieee8023ab; // Ethernet
    mesh.m_num_interfaces = 1;
    strncpy(mesh.m_interfaces[0].name, "eth0", sizeof(mesh.m_interfaces[0].name));
    const char* platform = "rpi";
    std::cout << "Invoking get_prioritized_interface(\"" << platform << "\")" << std::endl;
    em_interface_t* iface = mesh.get_prioritized_interface(platform);
    std::cout << "Retrieved interface name = " << (iface ? iface->name : "NULL") << std::endl;
    EXPECT_TRUE(iface != nullptr);
    EXPECT_STREQ(iface->name, "eth0");
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_prioritized_interface returns the correct WLAN interface for a given valid platform
 *
 * This test initializes an instance of dm_easy_mesh_t with one preference and one interface. It then invokes the get_prioritized_interface API with a valid platform name ("bpi") and verifies that the returned interface is not null and its name matches the expected "wlan0". This confirms that the API correctly prioritizes and returns the WLAN interface corresponding to the given platform.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 390@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                                          | Test Data                                                                                                                                                | Expected Result                                                    | Notes       |
 * | :--------------: | -------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ | ----------- |
 * | 01               | Initialize dm_easy_mesh_t instance with one preference ("bpi") and one interface ("wlan0"), then invoke get_prioritized_interface with platform "bpi". | mesh.m_num_preferences = 1, mesh.m_preference[0].platform = "bpi", mesh.m_preference[0].media = em_media_type_ieee80211b_24, mesh.m_num_interfaces = 1, mesh.m_interfaces[0].name = "wlan0", platform = "bpi" | API returns a non-null interface pointer and the interface name equals "wlan0" | Should Pass |
 */
TEST(dm_easy_mesh_t, get_prioritized_interface_valid_wlan)
{
    const char* testName = "get_prioritized_interface_valid_wlan";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_preferences = 1;
    strncpy(mesh.m_preference[0].platform, "bpi", sizeof(mesh.m_preference[0].platform));
    mesh.m_preference[0].media = em_media_type_ieee80211b_24; // WiFi
    mesh.m_num_interfaces = 1;
    strncpy(mesh.m_interfaces[0].name, "wlan0", sizeof(mesh.m_interfaces[0].name));
    const char* platform = "bpi";
    std::cout << "Invoking get_prioritized_interface(\"" << platform << "\")" << std::endl;
    em_interface_t* iface = mesh.get_prioritized_interface(platform);
    std::cout << "Retrieved interface name = " << (iface ? iface->name : "NULL") << std::endl;
    EXPECT_TRUE(iface != nullptr);
    EXPECT_STREQ(iface->name, "wlan0");
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate get_prioritized_interface returns NULL when no matching interface is found
 *
 * This test verifies that the dm_easy_mesh_t::get_prioritized_interface API returns a NULL pointer when the provided platform ("bpi")
 * does not match the configured platform ("rpi") in the mesh preferences. This ensures that the system correctly identifies the absence
 * of a matching interface based on the given inputs.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 391@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                                                                                      | Test Data                                                                                                                                                                                                              | Expected Result                                                                    | Notes       |
 * | :--------------: | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- | ----------- |
 * | 01               | Initialize mesh with one preference and one interface; call get_prioritized_interface with platform "bpi", which does not match the configured "rpi". | mesh.m_num_preferences = 1, m_preference[0].platform = "rpi", m_preference[0].media = em_media_type_ieee8023ab; mesh.m_num_interfaces = 1, m_interfaces[0].name = "eth0", input platform = "bpi" | The get_prioritized_interface API should return a NULL pointer, satisfying EXPECT_TRUE(iface == nullptr). | Should Pass |
 */
TEST(dm_easy_mesh_t, get_prioritized_interface_no_match)
{
    const char* testName = "get_prioritized_interface_no_match";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_preferences = 1;
    strncpy(mesh.m_preference[0].platform, "rpi", sizeof(mesh.m_preference[0].platform));
    mesh.m_preference[0].media = em_media_type_ieee8023ab; // Ethernet
    mesh.m_num_interfaces = 1;
    strncpy(mesh.m_interfaces[0].name, "eth0", sizeof(mesh.m_interfaces[0].name));
    const char* platform = "bpi";
    std::cout << "Invoking get_prioritized_interface(\"" << platform << "\")" << std::endl;
    em_interface_t* iface = mesh.get_prioritized_interface(platform);
    std::cout << "Retrieved interface name = " << (iface ? iface->name : "NULL") << std::endl;
    EXPECT_TRUE(iface == nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_radio() returns the correct radio pointer when a valid index is provided.
 *
 * This test verifies that the dm_easy_mesh_t::get_radio function correctly retrieves the radio structure associated with the specified valid index. It sets up a mesh with two radio entries, assigns unique net_id values to each, and checks if the returned radio's net_id matches the expected value. This ensures proper functionality and data retrieval for valid indices.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 392@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Setup dm_easy_mesh_t structure with two radios and assign valid net_id values; invoke get_radio() with a valid index to retrieve the expected radio. | mesh.m_num_radios = 2, radio[0].m_radio_info.id.net_id = radio0, radio[1].m_radio_info.id.net_id = radio1, index = 1 | API returns a valid pointer to the radio with net_id "radio1" and subsequent assertion checks succeed. | Should Pass |
 */
TEST(dm_easy_mesh_t, get_radio_valid_index)
{
    const char* testName = "get_radio_valid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_radios = 2;
    strncpy(mesh.m_radio[0].m_radio_info.id.net_id, "radio0", sizeof(mesh.m_radio[0].m_radio_info.id.net_id));
    strncpy(mesh.m_radio[1].m_radio_info.id.net_id, "radio1", sizeof(mesh.m_radio[1].m_radio_info.id.net_id));
    unsigned int index = 1;
    std::cout << "Invoking get_radio(" << index << ")" << std::endl;
    dm_radio_t* radio = mesh.get_radio(index);
    std::cout << "Retrieved radio net_id = " << (radio ? radio->m_radio_info.id.net_id : "NULL") << std::endl;
    EXPECT_TRUE(radio != nullptr);
    EXPECT_STREQ(radio->m_radio_info.id.net_id, "radio1");
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_radio returns nullptr for an invalid index.
 *
 * This test validates that when an invalid radio index is provided to the get_radio API, the function returns a null pointer as expected. This ensures that the API gracefully handles out-of-bound indices and maintains robust behavior under invalid input scenarios.@n
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 393@n
 * **Priority:** High@n
 * @n
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * @n
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data |Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object and set m_num_radios to 1; assign invalid index as EM_MAX_BANDS+5; invoke get_radio with the invalid index | mesh.m_num_radios = 1, index = EM_MAX_BANDS+5, expected radio = nullptr | API returns nullptr and EXPECT_TRUE assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_radio_invalid_index)
{
    const char* testName = "get_radio_invalid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_radios = 1;
    unsigned int index = EM_MAX_BANDS + 5;
    std::cout << "Invoking get_radio(" << index << ")" << std::endl;
    dm_radio_t* radio = mesh.get_radio(index);
    std::cout << "Retrieved radio = " << (radio ? radio->m_radio_info.id.net_id : "NULL") << std::endl;
    EXPECT_TRUE(radio == nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_radio returns the correct radio instance based on the provided MAC address.
 *
 * This test initializes a mesh object with two radios, sets their MAC addresses and assigns a network identifier to the second radio.
 * It then calls the get_radio API with the MAC address of the second radio and verifies that a valid radio pointer is returned and that its network identifier matches the expected value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 394@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                       | Test Data                                                                                                                         | Expected Result                                                     | Notes         |
 * | :--------------: | --------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize dm_easy_mesh_t with 2 radios and assign MAC addresses and net_id        | m_num_radios = 2, radio[0].mac = 00,11,22,33,44,55; radio[1].mac = AA,BB,CC,DD,EE,FF; radio[1].net_id = "radio1"                   | Mesh object initialized correctly                                   | Should be successful |
 * | 02               | Invoke get_radio API using the MAC address of the second radio                     | input: mac = AA,BB,CC,DD,EE,FF                                                                                                     | API returns a non-null pointer                                      | Should Pass   |
 * | 03               | Verify that the returned radios network identifier equals "radio1"                | output: radio->net_id from API call                                                                                                 | radio->net_id equals "radio1" via assertion                           | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_radio_valid_mac)
{
    const char* testName = "get_radio_valid_mac";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_radios = 2;
    mac_address_t mac0 = {0x00,0x11,0x22,0x33,0x44,0x55};
    mac_address_t mac1 = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    memcpy(mesh.m_radio[0].m_radio_info.intf.mac, mac0, sizeof(mac_address_t));
    memcpy(mesh.m_radio[1].m_radio_info.intf.mac, mac1, sizeof(mac_address_t));
    strncpy(mesh.m_radio[1].m_radio_info.id.net_id, "radio1", sizeof(mesh.m_radio[1].m_radio_info.id.net_id));
    std::cout << "Invoking get_radio(mac1)" << std::endl;
    dm_radio_t* radio = mesh.get_radio(mac1);
    std::cout << "Retrieved radio net_id = " << (radio ? radio->m_radio_info.id.net_id : "NULL") << std::endl;
    EXPECT_TRUE(radio != nullptr);
    EXPECT_STREQ(radio->m_radio_info.id.net_id, "radio1");
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate get_radio correctly handles invalid MAC address lookup.
 *
 * This test verifies that the get_radio function returns a null pointer when a MAC address that does not match any stored radio is provided. It ensures that the API gracefully handles a lookup for a non-existent radio.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 395@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object and set one radio with a valid MAC address | mesh.m_num_radios = 1, radio[0].m_radio_info.intf.mac = 00,11,22,33,44,55 | Mesh object contains one radio with the specified MAC | Should be successful |
 * | 02 | Invoke get_radio with an invalid MAC address to perform lookup | searchMac = AA,BB,CC,DD,EE,FF, API call: get_radio(searchMac) | API returns nullptr and EXPECT_TRUE(radio == nullptr) assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_radio_invalid_mac)
{
    const char* testName = "get_radio_invalid_mac";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_radios = 1;
    mac_address_t mac0 = {0x00,0x11,0x22,0x33,0x44,0x55};
    memcpy(mesh.m_radio[0].m_radio_info.intf.mac, mac0, sizeof(mac_address_t));
    mac_address_t searchMac = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    std::cout << "Invoking get_radio(searchMac)" << std::endl;
    dm_radio_t* radio = mesh.get_radio(searchMac);
    std::cout << "Retrieved radio = " << (radio ? radio->m_radio_info.id.net_id : "NULL") << std::endl;
    EXPECT_TRUE(radio == nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_radio_by_ref returns the correct radio reference for a valid index
 *
 * This test verifies that when a valid index is provided, the get_radio_by_ref method correctly retrieves the radio instance with the expected radio identifier. The test sets a known radio id ("radio0") and then confirms that the retrieved radio reference contains this id.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 396@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                 | Test Data                                                      | Expected Result                                                                           | Notes      |
 * | :--------------: | ------------------------------------------------------------------------------------------- | -------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | ---------- |
 * | 01               | Set radio id to "radio0", invoke get_radio_by_ref with index 0, and verify the retrieved id | mesh.m_radio[0].m_radio_info.id.net_id = "radio0", index = 0     | get_radio_by_ref returns a radio reference with m_radio_info.id.net_id equal to "radio0"    | Should Pass|
 */
TEST(dm_easy_mesh_t, get_radio_by_ref_valid_index)
{
    const char* testName = "get_radio_by_ref_valid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    strncpy(mesh.m_radio[0].m_radio_info.id.net_id, "radio0", sizeof(mesh.m_radio[0].m_radio_info.id.net_id));
    unsigned int index = 0;
    std::cout << "Invoking get_radio_by_ref(" << index << ")" << std::endl;
    dm_radio_t& radio = mesh.get_radio_by_ref(index);
    std::cout << "Retrieved radio net_id = " << radio.m_radio_info.id.net_id << std::endl;
    EXPECT_STREQ(radio.m_radio_info.id.net_id, "radio0");
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_radio_cap returns the correct radio capability for a valid MAC address.
 *
 * This test verifies that when a valid MAC address (present in the radio capabilities list) is provided to the get_radio_cap API,
 * the method returns a non-null pointer to the corresponding radio capability structure with the expected MAC address.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 397@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                              | Test Data                                                                                                             | Expected Result                                                                                           | Notes           |
 * | :--------------: | -------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | --------------- |
 * | 01               | Create and initialize the mesh object and set the number of radio capabilities to 2.                     | mesh.m_num_radios = 2                                                                                                 | Mesh object initialized with 2 radios.                                                                    | Should be successful |
 * | 02               | Set MAC addresses for the two radio capabilities in the mesh object.                                    | For radio 0: MAC = 00,11,22,33,44,55; For radio 1: MAC = AA,BB,CC,DD,EE,FF                                               | MAC addresses correctly assigned to radio capabilities.                                                 | Should be successful |
 * | 03               | Invoke the get_radio_cap API with the valid MAC address of radio 1.                                     | Input: mac1 = AA,BB,CC,DD,EE,FF                                                                                        | API returns a non-null pointer to the radio capability structure corresponding to mac1.                   | Should Pass     |
 * | 04               | Verify that the returned radio capability pointer is not null and that its MAC address matches mac1.     | Output: radioCap pointer; Expected MAC output: AA,BB,CC,DD,EE,FF                                                         | Assertions pass: radioCap is not null and its MAC address exactly matches mac1.                           | Should Pass     |
 */
TEST(dm_easy_mesh_t, get_radio_cap_valid_mac)
{
    const char* testName = "get_radio_cap_valid_mac";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_radios = 2;
    mac_address_t mac0 = {0x00,0x11,0x22,0x33,0x44,0x55};
    mac_address_t mac1 = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    memcpy(mesh.m_radio_cap[0].m_radio_cap_info.ruid.mac, mac0, sizeof(mac_address_t));
    memcpy(mesh.m_radio_cap[1].m_radio_cap_info.ruid.mac, mac1, sizeof(mac_address_t));
    std::cout << "Invoking get_radio_cap(mac1)" << std::endl;
    dm_radio_cap_t* radioCap = mesh.get_radio_cap(mac1);
    std::cout << "Retrieved radio_cap = " << (radioCap ? "FOUND" : "NULL") << std::endl;
    if(radioCap) {
        std::cout << "MAC: ";
        for(int i=0;i<6;i++) std::cout << std::hex << (int)radioCap->m_radio_cap_info.ruid.mac[i] << " ";
        std::cout << std::dec << std::endl;
    }
    EXPECT_TRUE(radioCap != nullptr);
    EXPECT_TRUE(memcmp(radioCap->m_radio_cap_info.ruid.mac, mac1, sizeof(mac_address_t)) == 0);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_radio_cap returns a nullptr when provided with an invalid MAC address.
 *
 * This test sets up a mesh instance with a single radio capability having a valid MAC address. It then invokes the get_radio_cap API using an invalid MAC address that does not match the valid one. The objective is to ensure that the API correctly returns a nullptr when no matching radio capability is found.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 398@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                            | Test Data                                                      | Expected Result                                      | Notes             |
 * | :--------------: | ---------------------------------------------------------------------- | -------------------------------------------------------------- | ---------------------------------------------------- | ----------------- |
 * | 01               | Initialize the mesh instance with one radio capability and assign a valid MAC address.  | mesh.m_num_radios = 1, mesh.m_radio_cap[0].m_radio_cap_info.ruid.mac = 00,11,22,33,44,55  | Mesh instance is correctly configured with a valid radio capability. | Should be successful |
 * | 02               | Invoke get_radio_cap with an invalid MAC address and verify that it returns nullptr.  | searchMac = AA,BB,CC,DD,EE,FF                                   | API returns nullptr, confirming no matching radio capability was found. | Should Pass       |
 */
TEST(dm_easy_mesh_t, get_radio_cap_invalid_mac)
{
    const char* testName = "get_radio_cap_invalid_mac";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_radios = 1;
    mac_address_t mac0 = {0x00,0x11,0x22,0x33,0x44,0x55};
    memcpy(mesh.m_radio_cap[0].m_radio_cap_info.ruid.mac, mac0, sizeof(mac_address_t));
    mac_address_t searchMac = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    std::cout << "Invoking get_radio_cap(searchMac)" << std::endl;
    dm_radio_cap_t* radioCap = mesh.get_radio_cap(searchMac);
    std::cout << "Retrieved radio_cap = " << (radioCap ? "FOUND" : "NULL") << std::endl;
    EXPECT_TRUE(radioCap == nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validates that get_radio_data returns the correct radio data for a valid interface.
 *
 * This test verifies that when a mesh object containing two radios ("wlan0" and "wlan1") is provided,
 * calling get_radio_data with an interface named "wlan1" returns a non-null pointer and the expected radio data.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 399@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |@n
 * | :----: | --------- | ---------- |-------------- | ----- |@n
 * | 01 | Initialize mesh with two radios and invoke get_radio_data using "wlan1". | mesh.m_wifi_data->u.decoded.num_radios = 2, mesh.m_wifi_data->u.decoded.radios[0].name = wlan0, mesh.m_wifi_data->u.decoded.radios[1].name = wlan1, iface.name = wlan1 | Returns a non-null radio pointer with radio->name equal to "wlan1". | Should Pass |
 */
TEST(dm_easy_mesh_t, get_radio_data_valid_interface)
{
    const char* testName = "get_radio_data_valid_interface";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_wifi_data = new webconfig_subdoc_data_t{};
    mesh.m_wifi_data->u.decoded.num_radios = 2;
    strncpy(mesh.m_wifi_data->u.decoded.radios[0].name, "wlan0", sizeof(mesh.m_wifi_data->u.decoded.radios[0].name));
    strncpy(mesh.m_wifi_data->u.decoded.radios[1].name, "wlan1", sizeof(mesh.m_wifi_data->u.decoded.radios[1].name));
    em_interface_t iface;
    strncpy(iface.name, "wlan1", sizeof(iface.name));
    std::cout << "Invoking get_radio_data(iface.name=" << iface.name << ")" << std::endl;
    rdk_wifi_radio_t* radio = mesh.get_radio_data(&iface);
    std::cout << "Retrieved radio name = " << (radio ? radio->name : "NULL") << std::endl;
    EXPECT_TRUE(radio != nullptr);
    EXPECT_STREQ(radio->name, "wlan1");
    delete mesh.m_wifi_data;
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_radio_data returns nullptr for an invalid interface.
 *
 * This test validates that the get_radio_data API properly returns a nullptr when the provided interface name does not match any of the radios configured in the mesh. The mesh is initialized with one valid radio ("wlan0") while the interface under test is set to "wlan5", ensuring that the API correctly identifies the mismatch.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 400@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                 | Test Data                                                                                      | Expected Result                                   | Notes         |
 * | :---------------:| --------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ------------------------------------------------- | ------------- |
 * | 01               | Initialize the mesh with one radio interface having name "wlan0".          | mesh.m_wifi_data->u.decoded.num_radios = 1, radios[0].name = "wlan0"                             | Mesh is initialized with one valid radio.         | Should be successful |
 * | 02               | Prepare an interface with an invalid radio name "wlan5".                   | iface.name = "wlan5"                                                                             | Interface is set up with name "wlan5".              | Should be successful |
 * | 03               | Invoke get_radio_data API with the invalid interface and verify the result.  | input: iface.name = "wlan5", output: radio pointer expected to be nullptr                        | API returns nullptr indicating no matching radio. | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_radio_data_invalid_interface)
{
    const char* testName = "get_radio_data_invalid_interface";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_wifi_data = new webconfig_subdoc_data_t{};
    mesh.m_wifi_data->u.decoded.num_radios = 1;
    strncpy(mesh.m_wifi_data->u.decoded.radios[0].name, "wlan0", sizeof(mesh.m_wifi_data->u.decoded.radios[0].name));
    em_interface_t iface;
    strncpy(iface.name, "wlan5", sizeof(iface.name));
    std::cout << "Invoking get_radio_data(iface.name=" << iface.name << ")" << std::endl;
    rdk_wifi_radio_t* radio = mesh.get_radio_data(&iface);
    std::cout << "Retrieved radio = " << (radio ? radio->name : "NULL") << std::endl;
    EXPECT_TRUE(radio == nullptr);
    delete mesh.m_wifi_data;
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_radio_data returns nullptr when m_wifi_data is null
 *
 * This test verifies that when the wifi_data member of the dm_easy_mesh_t instance is set to nullptr,
 * invoking get_radio_data with a valid interface returns a nullptr. This ensures that the method properly
 * handles a null wifi_data scenario.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 401@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Instantiate dm_easy_mesh_t and set m_wifi_data to nullptr | mesh.m_wifi_data = nullptr | Object is initialized with wifi_data as nullptr | Should be successful |
 * | 02 | Setup em_interface_t with iface.name set to "wlan0" using strncpy | iface.name = "wlan0" | Interface is correctly initialized with the name "wlan0" | Should be successful |
 * | 03 | Invoke get_radio_data with the provided interface and validate the output | Input: iface.name = "wlan0", mesh.m_wifi_data = nullptr; Output: radio pointer | Return value is nullptr and EXPECT_TRUE(radio == nullptr) assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_radio_data_null_wifi_data)
{
    const char* testName = "get_radio_data_null_wifi_data";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_wifi_data = nullptr;
    em_interface_t iface;
    strncpy(iface.name, "wlan0", sizeof(iface.name));
    std::cout << "Invoking get_radio_data(iface.name=" << iface.name << ")" << std::endl;
    rdk_wifi_radio_t* radio = mesh.get_radio_data(&iface);
    std::cout << "Retrieved radio = " << (radio ? radio->name : "NULL") << std::endl;
    EXPECT_TRUE(radio == nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_radio_info returns correct radio information for a valid index
 *
 * This test initializes a dm_easy_mesh_t instance with two radios and assigns specific radio IDs ("radio0" and "radio1"). It then calls the get_radio_info function using a valid index (1) and verifies that the returned pointer is not null and that the radio's net_id matches "radio1". This confirms that the function behaves as expected when queried with a valid radio index.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 402@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize mesh instance with 2 radios and assign radio IDs "radio0" and "radio1" | m_num_radios=2, m_radio[0].m_radio_info.id.net_id="radio0", m_radio[1].m_radio_info.id.net_id="radio1" | Mesh instance properly configured with two radios | Should be successful |
 * | 02 | Invoke get_radio_info with index=1 and verify the returned radio info | index=1 | Returns non-null pointer with radio_info.id.net_id equal to "radio1" | Should Pass |
 */
TEST(dm_easy_mesh_t, get_radio_info_valid_index)
{
    const char* testName = "get_radio_info_valid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_radios = 2;
    strncpy(mesh.m_radio[0].m_radio_info.id.net_id, "radio0", sizeof(mesh.m_radio[0].m_radio_info.id.net_id));
    strncpy(mesh.m_radio[1].m_radio_info.id.net_id, "radio1", sizeof(mesh.m_radio[1].m_radio_info.id.net_id));
    unsigned int index = 1;
    std::cout << "Invoking get_radio_info(index=" << index << ")" << std::endl;
    em_radio_info_t* radioInfo = mesh.get_radio_info(index);
    std::cout << "Retrieved radio_info net_id = " << (radioInfo ? radioInfo->id.net_id : "NULL") << std::endl;
    EXPECT_TRUE(radioInfo != nullptr);
    EXPECT_STREQ(radioInfo->id.net_id, "radio1");
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_radio_info returns nullptr when an invalid index is provided.
 *
 * This test checks the proper error handling in the get_radio_info API by supplying an index that exceeds 
 * the number of available radios. The dm_easy_mesh_t instance is configured with one valid radio. Calling 
 * get_radio_info with an index of 5 should return a nullptr, indicating the index is invalid.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 403@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                     | Test Data                                                                        | Expected Result                           | Notes           |
 * | :--------------: | --------------------------------------------------------------- | -------------------------------------------------------------------------------- | ----------------------------------------- | --------------- |
 * | 01               | Initialize dm_easy_mesh_t instance with a valid radio information | m_num_radios = 1, radio[0].m_radio_info.id.net_id = "radio0"                      | Instance initialized successfully         | Should be successful |
 * | 02               | Invoke get_radio_info with an invalid index                     | index = 5                                                                        | Returns nullptr                           | Should Pass     |
 */
TEST(dm_easy_mesh_t, get_radio_info_invalid_index)
{
    const char* testName = "get_radio_info_invalid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_radios = 1;
    strncpy(mesh.m_radio[0].m_radio_info.id.net_id, "radio0", sizeof(mesh.m_radio[0].m_radio_info.id.net_id));
    unsigned int index = 5;
    std::cout << "Invoking get_radio_info(index=" << index << ")" << std::endl;    
    em_radio_info_t* radioInfo = mesh.get_radio_info(index);
    EXPECT_TRUE(radioInfo == nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_radio_info returns the correct radio information for a valid index.
 *
 * This test creates a dm_easy_mesh_t instance with one radio configured with net_id "radio0". It then invokes the
 * static get_radio_info API with a valid index (0). The test verifies that the returned pointer is non-null and that
 * the radio information (net_id) matches the expected value "radio0". This ensures that the API correctly retrieves
 * radio details when provided with a valid index.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 404@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t instance with one radio and set radio net_id to "radio0", then invoke get_radio_info with index 0 and validate the returned data | mesh.m_num_radios = 1, mesh.m_radio[0].m_radio_info.id.net_id = "radio0", index = 0 | The API returns a non-null pointer and the returned radio info net_id equals "radio0". Assertions pass. | Should Pass |
 */
TEST(dm_easy_mesh_t, static_get_radio_info_valid_index)
{
    const char* testName = "static_get_radio_info_valid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_radios = 1;
    strncpy(mesh.m_radio[0].m_radio_info.id.net_id, "radio0", sizeof(mesh.m_radio[0].m_radio_info.id.net_id));
    unsigned int index = 0;
    std::cout << "Invoking static get_radio_info(dm, index=" << index << ")" << std::endl;
    em_radio_info_t* radioInfo = dm_easy_mesh_t::get_radio_info(&mesh, index);
    std::cout << "Retrieved radio_info net_id = " << (radioInfo ? radioInfo->id.net_id : "NULL") << std::endl;
    EXPECT_TRUE(radioInfo != nullptr);
    EXPECT_STREQ(radioInfo->id.net_id, "radio0");
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that dm_easy_mesh_t::get_radio_info returns nullptr when an invalid radio index is provided
 *
 * This test initializes a dm_easy_mesh_t instance with one valid radio entry and then attempts to retrieve radio information using an out-of-bound index. The objective is to ensure that get_radio_info correctly handles invalid input by returning a null pointer, which is subsequently verified using an assertion.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 405@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | --------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t instance by setting the number of radios to 1 and assigning the radio id to "radio0". | mesh.m_num_radios = 1, radio[0].m_radio_info.id.net_id = "radio0" | dm_easy_mesh_t instance is correctly initialized with one radio. | Should be successful |
 * | 02 | Define an invalid radio index that is out-of-bound. | index = 10 | Index is set to 10, which exceeds the number of available radios. | Should be successful |
 * | 03 | Invoke dm_easy_mesh_t::get_radio_info with the mesh pointer and the invalid index. | input: dm = mesh, index = 10, output: radioInfo expected to be nullptr | The API returns a nullptr, and the assertion (EXPECT_TRUE) confirms the expected outcome. | Should Fail |
 * | 04 | Log the test exit message to confirm test completion. | Console output: "Exiting static_get_radio_info_invalid_index test" | Test exit message is printed successfully. | Should be successful |
 */
TEST(dm_easy_mesh_t, static_get_radio_info_invalid_index)
{
    const char* testName = "static_get_radio_info_invalid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_radios = 1;
    strncpy(mesh.m_radio[0].m_radio_info.id.net_id, "radio0", sizeof(mesh.m_radio[0].m_radio_info.id.net_id));
    unsigned int index = 10;
    std::cout << "Invoking static get_radio_info(dm, index=" << index << ")" << std::endl;
    em_radio_info_t* radioInfo = dm_easy_mesh_t::get_radio_info(&mesh, index);
    EXPECT_TRUE(radioInfo == nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test get_radio_interface API with a valid radio index.
 *
 * This test verifies that the get_radio_interface() function returns a valid interface pointer when a correct radio index is provided. It checks that the interface name is correctly set to "wlan0" and that the API behaves as expected under standard conditions.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 406@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t with 1 radio, set the radio interface name to "wlan0", and invoke get_radio_interface with index=0. | m_num_radios=1, radio[0].m_radio_info.intf.name="wlan0", index=0 | Returns a non-null pointer; interface name equals "wlan0" | Should Pass |
 */
TEST(dm_easy_mesh_t, get_radio_interface_valid_index)
{
    const char* testName = "get_radio_interface_valid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_radios = 1;
    strncpy(mesh.m_radio[0].m_radio_info.intf.name, "wlan0", sizeof(mesh.m_radio[0].m_radio_info.intf.name));
    unsigned int index = 0;
    std::cout << "Invoking get_radio_interface(index=" << index << ")" << std::endl;
    em_interface_t* intf = mesh.get_radio_interface(index);
    if (intf) {
        std::cout << "Retrieved interface name = " << intf->name << std::endl;
        std::cout << "Retrieved interface mac  = ";
        for (int i = 0; i < 6; i++) {
            std::cout << std::hex << (int)intf->mac[i];
            if (i < 5) std::cout << ":";
        }
        std::cout << std::dec << std::endl;
    } else {
        std::cout << "Retrieved interface is NULL" << std::endl;
    }
    EXPECT_NE(intf, nullptr);
    EXPECT_STREQ(intf->name, "wlan0");
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test to validate get_radio_interface returns nullptr when an invalid index is provided
 *
 * This test verifies that the get_radio_interface API returns a nullptr when the provided index is out of range of the available radio interfaces. 
 * It ensures that the function properly handles invalid index accesses.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 407@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                     | Test Data                                                                                             | Expected Result                                                | Notes        |
 * | :--------------: | ----------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | -------------------------------------------------------------- | ------------ |
 * | 01               | Initialize mesh with one radio and invoke get_radio_interface with an invalid index (5)           | mesh.m_num_radios = 1, mesh.m_radio[0].m_radio_info.intf.name = wlan0, index = 5, return = nullptr   | API should return a nullptr when index is invalid and assertion passes | Should Fail  |
 */
TEST(dm_easy_mesh_t, get_radio_interface_invalid_index)
{
    const char* testName = "get_radio_interface_invalid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_num_radios = 1;
    strncpy(mesh.m_radio[0].m_radio_info.intf.name, "wlan0", sizeof(mesh.m_radio[0].m_radio_info.intf.name));
    unsigned int index = 5;
    std::cout << "Invoking get_radio_interface(index=" << index << ")" << std::endl;
    em_interface_t* intf = mesh.get_radio_interface(index);
    EXPECT_EQ(intf, nullptr);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_scan_result returns a valid scan result for a proper index.
 *
 * This test verifies that after creating a new scan result with valid parameters in the dm_easy_mesh_t object,
 * the get_scan_result API returns the correct scan result structure when queried with a valid index.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 408@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                              | Test Data                                                                                                                                      | Expected Result                                                                                                                                                         | Notes       |
 * | :--------------: | -------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------- |
 * | 01               | Initialize dm_easy_mesh_t object and set up scan result data | mesh.init() called; id: net_id = "net1", dev_mac[0] = 0x10, scanner_mac[0] = 0x20, op_class = 81, channel = 6, scanner_type = em_scanner_type_radio | dm_easy_mesh_t object is initialized and id structure is populated correctly.                                                                                        | Should Pass |
 * | 02               | Add a new scan result entry using create_new_scan_result  | Call create_new_scan_result(&id) with id containing net_id = "net1", dev_mac = 0x10, scanner_mac = 0x20, op_class = 81, channel = 6, scanner_type = em_scanner_type_radio | New scan result entry is added to the mesh object.                                                                                                                     | Should Pass |
 * | 03               | Retrieve scan result with valid index using get_scan_result | Call get_scan_result(index = 0)                                                                                                                  | Returns a valid pointer with m_scan_result.id: net_id = "net1", op_class = 81, channel = 6, scanner_type = em_scanner_type_radio, and assertions pass.                  | Should Pass |
 */
TEST(dm_easy_mesh_t, get_scan_result_single_entry_valid_index)
{
    const char* testName = "get_scan_result_single_entry_valid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    em_scan_result_id_t id{};
    strncpy(id.net_id, "net1", sizeof(id.net_id));
    id.dev_mac[0] = 0x10;
    id.scanner_mac[0] = 0x20;
    id.op_class = 81;
    id.channel = 6;
    id.scanner_type = em_scanner_type_radio;
    mesh.create_new_scan_result(&id);
    unsigned int index = 0;
    std::cout << "Invoking get_scan_result(index=" << index << ")" << std::endl;
    dm_scan_result_t* res = mesh.get_scan_result(index);
    // Print retrieved values
    if (res) {
        std::cout << "Retrieved net_id        = " << res->m_scan_result.id.net_id << std::endl;
        std::cout << "Retrieved op_class      = " << res->m_scan_result.id.op_class << std::endl;
        std::cout << "Retrieved channel       = " << res->m_scan_result.id.channel << std::endl;
        std::cout << "Retrieved scanner_type  = " << res->m_scan_result.id.scanner_type << std::endl;
    } else {
        std::cout << "Retrieved scan result is NULL" << std::endl;
    }
    EXPECT_NE(res, nullptr);
    EXPECT_STREQ(res->m_scan_result.id.net_id, "net1");
    EXPECT_EQ(res->m_scan_result.id.op_class, 81u);
    EXPECT_EQ(res->m_scan_result.id.channel, 6u);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test retrieval of a scan result by valid index from multiple scan entries
 *
 * This test verifies that when multiple scan results exist within the dm_easy_mesh_t object,
 * retrieving the scan result using get_scan_result with a valid index (specifically index 1)
 * returns the correct scan result with the expected net_id and op_class values.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 409@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize mesh and create multiple scan results | Call: mesh.init(); Loop iteration entries: entry0: net_id=net0, op_class=80, channel=1, scanner_type=em_scanner_type_sta; entry1: net_id=net1, op_class=81, channel=2, scanner_type=em_scanner_type_sta; entry2: net_id=net2, op_class=82, channel=3, scanner_type=em_scanner_type_sta | Mesh initialized and scan entries successfully created in the mesh object | Should be successful |
 * | 02 | Invoke get_scan_result with a valid index | index = 1 | Returns a non-null pointer to the scan result corresponding to the second entry (net_id "net1", op_class 81, etc.) | Should Pass |
 * | 03 | Verify the retrieved scan result values | Expected values: net_id = net1, op_class = 81 | Assertions: res is not null; res->m_scan_result.id.net_id equals "net1"; res->m_scan_result.id.op_class equals 81u | Should Pass |
 */
TEST(dm_easy_mesh_t, get_scan_result_multiple_entries_valid_index)
{
    const char* testName = "get_scan_result_multiple_entries_valid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    for (int i = 0; i < 3; i++) {
        em_scan_result_id_t id{};
        snprintf(id.net_id, sizeof(id.net_id), "net%d", i);
        id.dev_mac[5] = i;
        id.scanner_mac[5] = i + 1;
        id.op_class = 80 + i;
        id.channel = 1 + i;
        id.scanner_type = em_scanner_type_sta;
        mesh.create_new_scan_result(&id);
    }
    unsigned int index = 1;
    std::cout << "Invoking get_scan_result(index=" << index << ")" << std::endl;
    dm_scan_result_t* res = mesh.get_scan_result(index);
    if (res) {
        std::cout << "Retrieved net_id        = " << res->m_scan_result.id.net_id << std::endl;
        std::cout << "Retrieved op_class      = " << res->m_scan_result.id.op_class << std::endl;
        std::cout << "Retrieved channel       = " << res->m_scan_result.id.channel << std::endl;
        std::cout << "Retrieved scanner_type  = " << res->m_scan_result.id.scanner_type << std::endl;
    } else {
        std::cout << "Retrieved scan result is NULL" << std::endl;
    }
    EXPECT_NE(res, nullptr);
    EXPECT_STREQ(res->m_scan_result.id.net_id, "net1");
    EXPECT_EQ(res->m_scan_result.id.op_class, 81u);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test the get_scan_result API with an invalid index
 *
 * This test verifies that the get_scan_result method returns a nullptr when an invalid index is provided. It first sets up a mesh object by initializing it and creating a new scan result with specific parameters, and then attempts to fetch a scan result using an index that is not available.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 410@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize the mesh object and set up the scan result parameters (net_id, dev_mac, scanner_mac, op_class, channel, scanner_type) | id.net_id = "net1", id.dev_mac[0] = 0xAA, id.scanner_mac[0] = 0xBB, id.op_class = 81, id.channel = 6, id.scanner_type = em_scanner_type_radio | Mesh object is initialized and new scan result is created successfully | Should be successful |
 * | 02 | Invoke get_scan_result with an invalid index value (5) | index = 5 | Expected API to return nullptr indicating no scan result available for the given index; Assertion (EXPECT_EQ) verifies res == nullptr | Should Pass |
 */
TEST(dm_easy_mesh_t, get_scan_result_invalid_index)
{
    const char* testName = "get_scan_result_invalid_index";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    em_scan_result_id_t id{};
    strncpy(id.net_id, "net1", sizeof(id.net_id));
    id.dev_mac[0] = 0xAA;
    id.scanner_mac[0] = 0xBB;
    id.op_class = 81;
    id.channel = 6;
    id.scanner_type = em_scanner_type_radio;
    mesh.create_new_scan_result(&id);
    unsigned int index = 5;
    std::cout << "Invoking get_scan_result(index=" << index << ")" << std::endl;
    dm_scan_result_t* res = mesh.get_scan_result(index);
    if (res) {
        std::cout << "Retrieved net_id = " << res->m_scan_result.id.net_id << std::endl;
    } else {
        std::cout << "Retrieved scan result is NULL (as expected)" << std::endl;
    }
    EXPECT_EQ(res, nullptr);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_scan_result returns a nullptr when the scan map is empty.
 *
 * This test validates that when dm_easy_mesh_t is initialized but no scan data is present,
 * invoking get_scan_result with an index returns a nullptr. The test ensures that the API correctly
 * handles the empty scan case.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 411@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                          | Test Data                                   | Expected Result                                         | Notes          |
 * | :--------------: | ---------------------------------------------------- | ------------------------------------------- | ------------------------------------------------------- | -------------- |
 * | 01               | Initialize the dm_easy_mesh_t instance using init()  | No input, output: mesh instance initialized | Mesh is initialized successfully without errors       | Should be successful |
 * | 02               | Invoke get_scan_result with index=0                  | input: index = 0, output: res = nullptr        | API returns nullptr indicating that the scan map is empty; assertion EXPECT_EQ(res, nullptr) passes | Should Pass    |
 */
TEST(dm_easy_mesh_t, get_scan_result_empty_map)
{
    const char* testName = "get_scan_result_empty_map";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    unsigned int index = 0;
    std::cout << "Invoking get_scan_result(index=" << index << ")" << std::endl;
    dm_scan_result_t* res = mesh.get_scan_result(index);
    if (res) {
        std::cout << "Unexpected scan result found" << std::endl;
    } else {
        std::cout << "Retrieved scan result is NULL (empty map)" << std::endl;
    }
    EXPECT_EQ(res, nullptr);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test that get_serial_number returns a valid serial number for a correctly initialized mesh
 *
 * This test verifies that when the dm_easy_mesh_t object is initialized with a valid serial number,
 * the get_serial_number API successfully retrieves the same serial number. It ensures that the API does not 
 * return a null pointer and correctly matches the expected string value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 412@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                 | Test Data                                                                     | Expected Result                                                           | Notes         |
 * | :--------------: | ------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- | ------------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize dm_easy_mesh_t object, set its serial number, call get_serial_number and check it   | mesh.m_device.m_device_info.serial_number = SN12345678, output = SN12345678      | API returns non-null pointer and serial string equals "SN12345678"          | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_serial_number_valid)
{
    const char* testName = "get_serial_number_valid";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    strncpy(mesh.m_device.m_device_info.serial_number, "SN12345678", sizeof(mesh.m_device.m_device_info.serial_number));
    std::cout << "Invoking get_serial_number()" << std::endl;
    char* serial = mesh.get_serial_number();
    // Print retrieved value
    if (serial) {
        std::cout << "Retrieved serial number = " << serial << std::endl;
    } else {
        std::cout << "Retrieved serial number is NULL" << std::endl;
    }
    EXPECT_NE(serial, nullptr);
    EXPECT_STREQ(serial, "SN12345678");
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validates that get_serial_number() handles an empty serial number correctly.
 *
 * This test verifies that when the serial number of the device is initialized as empty, the get_serial_number() API returns a non-null pointer with an empty string as its content.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 413@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                      | Test Data                                                                                   | Expected Result                                                                                                  | Notes           |
 * | :--------------: | ---------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- | --------------- |
 * | 01               | Initialize a mesh object and set the device's serial number to empty | mesh.m_device.m_device_info.serial_number[0] = '\0'                                          | The serial number field in the device information is set to an empty string                                        | Should be successful  |
 * | 02               | Invoke get_serial_number() to retrieve the serial number             | Function call: char* serial = mesh.get_serial_number()                                       | The API returns a non-null pointer with an empty string                                                           | Should Pass     |
 * | 03               | Verify the retrieved serial number is non-null and an empty string      | Assertions: EXPECT_NE(serial, nullptr), EXPECT_STREQ(serial, "")                              | The API returns a valid non-null pointer and the content of the serial number is an empty string                    | Should Pass     |
 */
TEST(dm_easy_mesh_t, get_serial_number_empty)
{
    const char* testName = "get_serial_number_empty";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_device.m_device_info.serial_number[0] = '\0';
    std::cout << "Invoking get_serial_number()" << std::endl;
    char* serial = mesh.get_serial_number();
    // Print retrieved value
    if (serial) {
        std::cout << "Retrieved serial number = '" << serial << "'" << std::endl;
    } else {
        std::cout << "Retrieved serial number is NULL" << std::endl;
    }
    EXPECT_NE(serial, nullptr);
    EXPECT_STREQ(serial, "");
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_software_version returns the correct version string when a valid version is set
 *
 * This test sets a predefined software version in the mesh object's device information and then invokes the get_software_version function.
 * It verifies that the function returns a non-null pointer and the expected version string ("v1.2.3-build45").
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 414@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                            | Test Data                                                                     | Expected Result                                                                 | Notes         |
 * | :--------------: | ---------------------------------------------------------------------- | ----------------------------------------------------------------------------- | ------------------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize mesh object and set the device info software version        | mesh.m_device.m_device_info.software_ver = "v1.2.3-build45"                     | The software version field is successfully updated with "v1.2.3-build45"         | Should be successful |
 * | 02               | Invoke get_software_version method on mesh object                      | No additional parameters; method is invoked on mesh object                     | Returns a non-null pointer containing the string "v1.2.3-build45"                | Should Pass   |
 * | 03               | Validate the returned software version using assertions               | Return value from get_software_version (expected "v1.2.3-build45")                | EXPECT_NE(version, nullptr) and EXPECT_STREQ(version, "v1.2.3-build45") checks pass | Should Pass   |
 */
TEST(dm_easy_mesh_t, get_software_version_valid)
{
    const char* testName = "get_software_version_valid";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    strncpy(mesh.m_device.m_device_info.software_ver, "v1.2.3-build45", sizeof(mesh.m_device.m_device_info.software_ver));
    std::cout << "Invoking get_software_version()" << std::endl;
    char* version = mesh.get_software_version();
    // Print retrieved value
    if (version) {
        std::cout << "Retrieved software version = " << version << std::endl;
    } else {
        std::cout << "Retrieved software version is NULL" << std::endl;
    }
    EXPECT_NE(version, nullptr);
    EXPECT_STREQ(version, "v1.2.3-build45");
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_software_version() returns a non-null pointer to an empty string when the software version is empty.
 *
 * This test checks that when the software version field in the device information is empty,
 * the get_software_version() function returns a valid pointer and an empty string as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 415@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t instance and set software version to empty. | dm_easy_mesh_t instance created, software_ver[0] = '\0' | Instance is initialized with empty software version | Should be successful |
 * | 02 | Invoke get_software_version() method on the mesh instance. | Input: device_info.software_ver = "", Output: version pointer from get_software_version() | get_software_version() returns a non-null pointer. | Should Pass |
 * | 03 | Verify that the returned version string is empty. | version = result of get_software_version() | The version string is equal to "" (empty string) | Should Pass |
 */
TEST(dm_easy_mesh_t, get_software_version_empty)
{
    const char* testName = "get_software_version_empty";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.m_device.m_device_info.software_ver[0] = '\0';
    std::cout << "Invoking get_software_version()" << std::endl;
    char* version = mesh.get_software_version();
    // Print retrieved value
    if (version) {
        std::cout << "Retrieved software version = '" << version << "'" << std::endl;
    } else {
        std::cout << "Retrieved software version is NULL" << std::endl;
    }
    EXPECT_NE(version, nullptr);
    EXPECT_STREQ(version, "");
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Positive test to verify the retrieval of STA info associated with mesh
 *
 * This test inserts STA association information using put_sta_info and then retrieves it using get_sta_info. It validates that the returned STA info pointer is not null and that the STA MAC matches the expected value.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 416@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | ------------- | ----- |
 * | 01 | Initialize mesh, insert STA info using put_sta_info, and call get_sta_info | testName = get_sta_info_assoc_positive, sta = {0x00,0x11,0x22,0x33,0x44,0x55}, bssid = {0x66,0x77,0x88,0x99,0xaa,0xbb}, ruid = {0xcc,0xdd,0xee,0xff,0x00,0x01} | Returns non-null pointer with matching STA MAC | Should Pass |
 */
TEST(dm_easy_mesh_t, get_sta_info_assoc_positive)
{
    const char *testName = "get_sta_info_assoc_positive";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    em_sta_info_t sta_info{};
    mac_address_t sta  = {0x00,0x11,0x22,0x33,0x44,0x55};
    bssid_t       bssid = {0x66,0x77,0x88,0x99,0xaa,0xbb};
    mac_address_t ruid = {0xcc,0xdd,0xee,0xff,0x00,0x01};
    memcpy(sta_info.id, sta, sizeof(mac_address_t));
    memcpy(sta_info.bssid, bssid, sizeof(bssid_t));
    memcpy(sta_info.radiomac, ruid, sizeof(mac_address_t));
    mesh.put_sta_info(&sta_info, em_target_sta_map_assoc);
    std::cout << "Invoking get_sta_info(sta, bssid, ruid, em_target_sta_map_assoc)" << std::endl;
    em_sta_info_t *result = mesh.get_sta_info(sta, bssid, ruid, em_target_sta_map_assoc);
    if (result) {
        std::cout << "Retrieved STA MAC = ";
        for (int i = 0; i < 6; i++) std::cout << std::hex << (int)result->id[i] << " ";
        std::cout << std::dec << std::endl;
    } else {
        std::cout << "Retrieved STA info is NULL" << std::endl;
    }
    EXPECT_NE(result, nullptr);
    EXPECT_EQ(memcmp(result->id, sta, sizeof(mac_address_t)), 0);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_sta_info returns nullptr for a wrong BSSID.
 *
 * This test case validates that providing an incorrect BSSID to the get_sta_info API results in a null pointer, ensuring that the API does not return valid information for non-associated stations.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 417@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize the mesh and set up the STA, wrong BSSID, and ruid | Input: sta = {0x10,0x11,0x12,0x13,0x14,0x15}, wrong_bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0xff}, ruid = {0x20,0x21,0x22,0x23,0x24,0x25} | Mesh object is initialized successfully | Should be successful |
 * | 02 | Invoke get_sta_info with wrong BSSID | Input: Call get_sta_info(sta, wrong_bssid, ruid, em_target_sta_map_assoc) | API returns nullptr and EXPECT_EQ(result, nullptr) assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_sta_info_assoc_negative_wrong_bssid)
{
    const char *testName = "get_sta_info_assoc_negative_wrong_bssid";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t sta  = {0x10,0x11,0x12,0x13,0x14,0x15};
    bssid_t wrong_bssid = {0xaa,0xbb,0xcc,0xdd,0xee,0xff};
    mac_address_t ruid = {0x20,0x21,0x22,0x23,0x24,0x25};
    std::cout << "Invoking get_sta_info(sta, wrong_bssid, ruid, em_target_sta_map_assoc)" << std::endl;
    em_sta_info_t *result = mesh.get_sta_info(sta, wrong_bssid, ruid, em_target_sta_map_assoc);
    std::cout << "Retrieved STA info pointer = " << result << std::endl;
    EXPECT_EQ(result, nullptr);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate retrieval of STA info using valid parameters.
 *
 * Validate that dm_easy_mesh_t::get_sta_info() successfully retrieves STA information when supplied with valid STA, BSSID, and RUID values, and the correct target flag, ensuring consistent API functionality.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 418@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize the mesh object and setup STA info with valid MAC addresses | mesh.init(), sta_info with sta = 01,02,03,04,05,06; bssid = 11,12,13,14,15,16; ruid = 21,22,23,24,25,26 | Mesh and STA info successfully initialized | Should be successful |
 * | 02 | Insert STA info into mesh using put_sta_info() | mesh pointer, sta_info pointer, target flag = em_target_sta_map_disassoc | STA info is inserted correctly into the mesh without error | Should be successful |
 * | 03 | Retrieve STA info by calling get_sta_info() with valid parameters | mesh pointer, sta = 01,02,03,04,05,06; bssid = 11,12,13,14,15,16; ruid = 21,22,23,24,25,26; target flag = em_target_sta_map_disassoc | Function returns a non-null pointer and the retrieved STA info is valid as confirmed by EXPECT_NE(result, nullptr) | Should Pass |
 */
TEST(dm_easy_mesh_t, get_sta_info_static_positive)
{
    const char *testName = "get_sta_info_static_positive";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    em_sta_info_t sta_info{};
    mac_address_t sta  = {0x01,0x02,0x03,0x04,0x05,0x06};
    bssid_t       bssid = {0x11,0x12,0x13,0x14,0x15,0x16};
    mac_address_t ruid = {0x21,0x22,0x23,0x24,0x25,0x26};
    memcpy(sta_info.id, sta, sizeof(mac_address_t));
    memcpy(sta_info.bssid, bssid, sizeof(bssid_t));
    memcpy(sta_info.radiomac, ruid, sizeof(mac_address_t));
    mesh.put_sta_info(&sta_info, em_target_sta_map_disassoc);
    std::cout << "Invoking static get_sta_info(dm, sta, bssid, ruid, em_target_sta_map_disassoc)" << std::endl;
    em_sta_info_t *result = dm_easy_mesh_t::get_sta_info(&mesh, sta, bssid, ruid, em_target_sta_map_disassoc);
    if (result) {
        std::cout << "Retrieved STA MAC = ";
        for (int i = 0; i < 6; i++) std::cout << std::hex << (int)result->id[i] << " ";
        std::cout << std::dec << std::endl;
    } else {
        std::cout << "Retrieved STA info is NULL" << std::endl;
    }
    EXPECT_NE(result, nullptr);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_sta_info static API returns nullptr when STA is not found.
 *
 * This test verifies that the get_sta_info static function correctly returns a null pointer when the specified STA information is not present in the mesh context. It ensures that the function handles the negative scenario appropriately.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 419@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize the mesh, define test MAC addresses and invoke get_sta_info static function. | mesh: dm_easy_mesh_t instance after init(), sta = 0xde,0xad,0xbe,0xef,0x00,0x01, bssid = 0xba,0xdc,0x0f,0xfe,0xee,0x01, ruid = 0xca,0xfe,0xba,0xbe,0x00,0x02, target = em_target_sta_map_assoc | The function returns nullptr indicating that the STA info was not found. | Should Fail |
 */
TEST(dm_easy_mesh_t, get_sta_info_static_negative_not_found)
{
    const char *testName = "get_sta_info_static_negative_not_found";
    std::cout << "Entering " << testName << " test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    mac_address_t sta  = {0xde,0xad,0xbe,0xef,0x00,0x01};
    bssid_t       bssid = {0xba,0xdc,0x0f,0xfe,0xee,0x01};
    mac_address_t ruid = {0xca,0xfe,0xba,0xbe,0x00,0x02};
    std::cout << "Invoking static get_sta_info(dm, sta, bssid, ruid, em_target_sta_map_assoc)" << std::endl;
    em_sta_info_t *result = dm_easy_mesh_t::get_sta_info(&mesh, sta, bssid, ruid, em_target_sta_map_assoc);
    std::cout << "Retrieved STA info pointer = " << result << std::endl;
    EXPECT_EQ(result, nullptr);
    mesh.deinit();
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate the subdoc radio type retrieval for 2.4GHz frequency band.
 *
 * This test verifies that the get_subdoc_radio_type_for_freq API returns the correct subdoc type for the 2.4GHz frequency band. It ensures that the returned value matches the expected subdoc type (webconfig_subdoc_type_radio_24G) when provided with the frequency band em_freq_band_24.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 420@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                         | Test Data                                                         | Expected Result                                                                     | Notes       |
 * | :--------------: | --------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- | ----------------------------------------------------------------------------------- | ----------- |
 * | 01               | Initialize the test and invoke get_subdoc_radio_type_for_freq using em_freq_band_24                 | band = em_freq_band_24, expected output = webconfig_subdoc_type_radio_24G | The function returns webconfig_subdoc_type_radio_24G and assertion passes              | Should Pass |
 */
TEST(dm_easy_mesh_t, get_subdoc_radio_type_for_freq_24G_positive)
{
    const char *testName = "get_subdoc_radio_type_for_freq_24G_positive";
    std::cout << "Entering " << testName << " test" << std::endl;
    em_freq_band_t band = em_freq_band_24;
    std::cout << "Invoking get_subdoc_radio_type_for_freq(em_freq_band_24)" << std::endl;
    webconfig_subdoc_type_t result = dm_easy_mesh_t::get_subdoc_radio_type_for_freq(band);
    std::cout << "Retrieved subdoc type = " << result << std::endl;
    EXPECT_EQ(result, webconfig_subdoc_type_radio_24G);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_subdoc_radio_type_for_freq returns the correct subdocument type for a 5G frequency.
 *
 * This test verifies that invoking the function get_subdoc_radio_type_for_freq with the frequency
 * band set to em_freq_band_5 properly returns the webconfig_subdoc_type_radio_5G. The test ensures
 * that the API behaves as expected when processing a 5G frequency input.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 421@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                      | Test Data                                                  | Expected Result                                                                 | Notes        |
 * | :--------------: | --------------------------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------------------------------------- | ------------ |
 * | 01               | Invoke get_subdoc_radio_type_for_freq with band = em_freq_band_5  | band = em_freq_band_5, output = webconfig_subdoc_type_radio_5G | Function returns webconfig_subdoc_type_radio_5G; EXPECT_EQ assertion passes         | Should Pass  |
 */
TEST(dm_easy_mesh_t, get_subdoc_radio_type_for_freq_5G_positive)
{
    const char *testName = "get_subdoc_radio_type_for_freq_5G_positive";
    std::cout << "Entering " << testName << " test" << std::endl;
    em_freq_band_t band = em_freq_band_5;
    std::cout << "Invoking get_subdoc_radio_type_for_freq(em_freq_band_5)" << std::endl;
    webconfig_subdoc_type_t result = dm_easy_mesh_t::get_subdoc_radio_type_for_freq(band);
    std::cout << "Retrieved subdoc type = " << result << std::endl;
    EXPECT_EQ(result, webconfig_subdoc_type_radio_5G);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Verify that get_subdoc_radio_type_for_freq returns the correct subdoc type when an invalid frequency band is provided.
 *
 * This test verifies that when an invalid frequency band (simulated by passing a value of 99) is provided to the
 * get_subdoc_radio_type_for_freq API, the function returns the default subdoc type "webconfig_subdoc_type_radio_6G".
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 422@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke get_subdoc_radio_type_for_freq with an invalid frequency band value to verify default behavior | band = 99, expected_result = webconfig_subdoc_type_radio_6G | API returns webconfig_subdoc_type_radio_6G | Should Pass |
 */
TEST(dm_easy_mesh_t, get_subdoc_radio_type_for_freq_invalid_band_negative)
{
    const char *testName = "get_subdoc_radio_type_for_freq_invalid_band_negative";
    std::cout << "Entering " << testName << " test" << std::endl;
    em_freq_band_t band = static_cast<em_freq_band_t>(99);
    std::cout << "Invoking get_subdoc_radio_type_for_freq(invalid band)" << std::endl;
    webconfig_subdoc_type_t result = dm_easy_mesh_t::get_subdoc_radio_type_for_freq(band);
    std::cout << "Retrieved subdoc type = " << result << std::endl;
    EXPECT_EQ(result, webconfig_subdoc_type_radio_6G);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_subdoc_vap_type_for_freq returns the correct subdoc type for the 2.4G frequency band
 *
 * This test verifies that invoking get_subdoc_vap_type_for_freq with the frequency band em_freq_band_24 correctly returns the subdoc type webconfig_subdoc_type_vap_24G. It ensures that the API properly maps the 2.4G frequency band to its corresponding VAP subdocument type.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 423@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                            | Expected Result                                                                 | Notes              |
 * | :--------------: | --------------------------------------------------------------------------- | -------------------------------------------------------------------- | ------------------------------------------------------------------------------- | ------------------ |
 * | 01               | Start test execution and log the entry message                              | N/A                                                                  | Console prints "Entering get_subdoc_vap_type_for_freq_24G_positive test"          | Should be successful |
 * | 02               | Invoke get_subdoc_vap_type_for_freq with input parameter em_freq_band_24       | input: band = em_freq_band_24, output: result = undefined             | Function returns webconfig_subdoc_type_vap_24G                                  | Should Pass        |
 * | 03               | Check the returned result using EXPECT_EQ to ensure correctness              | input: expected result = webconfig_subdoc_type_vap_24G                | EXPECT_EQ validates that result is equal to webconfig_subdoc_type_vap_24G         | Should Pass        |
 * | 04               | End test execution and log the exit message                                 | N/A                                                                  | Console prints "Exiting get_subdoc_vap_type_for_freq_24G_positive test"           | Should be successful |
 */
TEST(dm_easy_mesh_t, get_subdoc_vap_type_for_freq_24G_positive)
{
    const char *testName = "get_subdoc_vap_type_for_freq_24G_positive";
    std::cout << "Entering " << testName << " test" << std::endl;
    em_freq_band_t band = em_freq_band_24;
    std::cout << "Invoking get_subdoc_vap_type_for_freq(em_freq_band_24)" << std::endl;
    webconfig_subdoc_type_t result = dm_easy_mesh_t::get_subdoc_vap_type_for_freq(band);
    std::cout << "Retrieved subdoc type = " << result << std::endl;
    EXPECT_EQ(result, webconfig_subdoc_type_vap_24G);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Validate that get_subdoc_vap_type_for_freq correctly returns the sub-document type for the 5G frequency.
 *
 * This unit test verifies that when the get_subdoc_vap_type_for_freq API is invoked with a frequency band of 5G (em_freq_band_5),
 * it returns the expected sub-document type webconfig_subdoc_type_vap_5G. This ensures proper mapping and handling for the 5G band.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 424@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |@n
 * | :----: | --------- | ---------- |-------------- | ----- |@n
 * | 01 | Invoke get_subdoc_vap_type_for_freq with em_freq_band_5 and verify the returned sub-document type | band = em_freq_band_5, expected output = webconfig_subdoc_type_vap_5G | API returns webconfig_subdoc_type_vap_5G and EXPECT_EQ check passes | Should Pass |
 */
TEST(dm_easy_mesh_t, get_subdoc_vap_type_for_freq_5G_positive)
{
    const char *testName = "get_subdoc_vap_type_for_freq_5G_positive";
    std::cout << "Entering " << testName << " test" << std::endl;
    em_freq_band_t band = em_freq_band_5;
    std::cout << "Invoking get_subdoc_vap_type_for_freq(em_freq_band_5)" << std::endl;
    webconfig_subdoc_type_t result = dm_easy_mesh_t::get_subdoc_vap_type_for_freq(band);
    std::cout << "Retrieved subdoc type = " << result << std::endl;
    EXPECT_EQ(result, webconfig_subdoc_type_vap_5G);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief Test for get_subdoc_vap_type_for_freq with an invalid frequency band
 *
 * This test verifies that when an invalid frequency band value is provided to the get_subdoc_vap_type_for_freq function,
 * the function returns the default sub-document type (webconfig_subdoc_type_vap_6G) to handle invalid input gracefully.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 425@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke get_subdoc_vap_type_for_freq with an invalid band value to validate error handling for invalid input. | band = 255, expected output = webconfig_subdoc_type_vap_6G | Return value equals webconfig_subdoc_type_vap_6G; assertion EXPECT_EQ passes. | Should Fail |
 */
TEST(dm_easy_mesh_t, get_subdoc_vap_type_for_freq_invalid_band_negative)
{
    const char *testName = "get_subdoc_vap_type_for_freq_invalid_band_negative";
    std::cout << "Entering " << testName << " test" << std::endl;
    em_freq_band_t band = static_cast<em_freq_band_t>(255);
    std::cout << "Invoking get_subdoc_vap_type_for_freq(invalid band)" << std::endl;
    webconfig_subdoc_type_t result = dm_easy_mesh_t::get_subdoc_vap_type_for_freq(band);
    std::cout << "Retrieved subdoc type = " << result << std::endl;
    EXPECT_EQ(result, webconfig_subdoc_type_vap_6G);
    std::cout << "Exiting " << testName << " test" << std::endl;
}

/**
 * @brief This test verifies that the set_agent_al_interface_mac() method correctly assigns a valid MAC address to the agent's interface.
 *
 * This test creates a dm_easy_mesh_t object, sets a valid MAC address using the set_agent_al_interface_mac() method, and then verifies that the MAC address has been correctly updated in the object's m_device.m_device_info.intf.mac field.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 426@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                  | Test Data                                                         | Expected Result                                                                                           | Notes         |
 * | :--------------: | ----------------------------------------------------------------------------- | ----------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize the dm_easy_mesh_t object and set up a valid MAC address array.      | valid_mac = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF}                   | Object is initialized and valid_mac array is created with the specified MAC values.                        | Should be successful |
 * | 02               | Invoke the set_agent_al_interface_mac() API with the valid MAC address.         | input: valid_mac = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF}             | The API updates the object's m_device.m_device_info.intf.mac to the valid MAC address.                     | Should Pass   |
 * | 03               | Validate that the MAC address in m_device.m_device_info.intf.mac matches valid_mac. | input: valid_mac = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF}, output: m_device.m_device_info.intf.mac = valid_mac | EXPECT_EQ std::memcmp returns 0 indicating both MAC addresses are identical. | Should Pass   |
 */
TEST(dm_easy_mesh_t, set_agent_al_interface_mac_valid_mac_address) {
    std::cout << "Entering set_agent_al_interface_mac_valid_mac_address test" << std::endl;
    dm_easy_mesh_t obj;
    unsigned char valid_mac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    std::cout << "Invoking set_agent_al_interface_mac with valid MAC address: ";
    for (int i = 0; i < 6; i++) {
         std::cout << std::hex << static_cast<int>(valid_mac[i]) << " ";
    }
    std::cout << std::dec << std::endl;   
    obj.set_agent_al_interface_mac(valid_mac);
    std::cout << "After invocation, m_device.m_device_info.intf.mac contains: ";
    for (int i = 0; i < 6; i++) {
         std::cout << std::hex << static_cast<int>(obj.m_device.m_device_info.intf.mac[i]) << " ";
    }
    std::cout << std::dec << std::endl;
    EXPECT_EQ(std::memcmp(obj.m_device.m_device_info.intf.mac, valid_mac, 6), 0);
    std::cout << "Exiting set_agent_al_interface_mac_valid_mac_address test" << std::endl;
}

/**
 * @brief Verify that invoking set_agent_al_interface_mac with a NULL pointer does not modify the MAC address.
 *
 * This test ensures that when a NULL pointer is passed to the set_agent_al_interface_mac function, the MAC address remains unchanged. The test is critical to confirm that the API safely handles invalid input without corrupting the existing MAC configuration.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 427@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize device MAC to a known value before API invocation | initial_mac = 0x11,0x22,0x33,0x44,0x55,0x66, object's MAC = initial_mac | MAC address in object's structure is set to initial_mac | Should be successful |
 * | 02 | Invoke set_agent_al_interface_mac with a NULL pointer to simulate invalid input | null_mac = nullptr | API is invoked with a NULL pointer; no modification is made to the MAC address | Should Pass |
 * | 03 | Validate that the MAC address remains unchanged after the API call | Compare object's MAC with initial_mac using memcmp | memcmp returns 0 indicating the MAC address remains unchanged | Should be successful |
 */
TEST(dm_easy_mesh_t, set_agent_al_interface_mac_null_pointer) {
    std::cout << "Entering set_agent_al_interface_mac_null_pointer test" << std::endl;
    dm_easy_mesh_t obj;
    unsigned char initial_mac[6] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
    memcpy(obj.m_device.m_device_info.intf.mac, initial_mac, 6);
    std::cout << "Initial m_device.m_device_info.intf.mac is set to: ";
    for (int i = 0; i < 6; i++) {
         std::cout << std::hex << static_cast<int>(initial_mac[i]) << " ";
    }
    std::cout << std::dec << std::endl;
    unsigned char *null_mac = nullptr;
    std::cout << "Invoking set_agent_al_interface_mac with NULL pointer" << std::endl;
    obj.set_agent_al_interface_mac(null_mac);
    std::cout << "After invocation, m_device.m_device_info.intf.mac contains: ";
    for (int i = 0; i < 6; i++) {
         std::cout << std::hex << static_cast<int>(obj.m_device.m_device_info.intf.mac[i]) << " ";
    }
    std::cout << std::dec << std::endl;
    EXPECT_EQ(std::memcmp(obj.m_device.m_device_info.intf.mac, initial_mac, 6), 0);
    std::cout << "Exiting set_agent_al_interface_mac_null_pointer test" << std::endl;
}

/**
 * @brief Test that the valid interface name "eth0" is correctly set in the dm_easy_mesh_t object.
 *
 * This test verifies that providing the interface name "eth0" to the set_agent_al_interface_name method correctly updates the object's internal interface name.
 * It is important to ensure that valid input is handled properly to maintain the correct network configuration.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 428@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                  | Test Data                                                       | Expected Result                                                                                | Notes      |
 * | :--------------: | -------------------------------------------------------------------------------------------- | --------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ---------- |
 * | 01               | Invoke set_agent_al_interface_name with input "eth0" and verify the stored interface name     | input_name = "eth0", expected_interface_name = "eth0"           | The function should set the internal interface name to "eth0" and the EXPECT_STREQ check should pass | Should Pass |
 */
TEST(dm_easy_mesh_t, set_agent_al_interface_name_valid_eth0) {
    std::cout << "Entering set_agent_al_interface_name_valid_eth0 test" << std::endl;
    dm_easy_mesh_t obj;
    char input_name[] = "eth0";
    std::cout << "Invoking set_agent_al_interface_name with input: " << input_name << std::endl;
    obj.set_agent_al_interface_name(input_name);    
    std::cout << "Retrieved interface name: " << obj.m_device.m_device_info.intf.name << std::endl;
    EXPECT_STREQ(obj.m_device.m_device_info.intf.name, "eth0");
    std::cout << "Exiting set_agent_al_interface_name_valid_eth0 test" << std::endl;
}

/**
 * @brief Verify that set_agent_al_interface_name handles NULL input correctly
 *
 * This test validates that when a NULL value is passed to set_agent_al_interface_name, the device interface name is not set to NULL.
 *
 * **Test Group ID:** Basic: 01  
 * **Test Case ID:** 429@n
 * **Priority:** High  
 *
 * **Pre-Conditions:** None  
 * **Dependencies:** None  
 * **User Interaction:** None  
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                 | Test Data                                         | Expected Result                                                                 | Notes       |
 * | :--------------: | ----------------------------------------------------------- | ------------------------------------------------- | ------------------------------------------------------------------------------- | ----------- |
 * | 01               | Call set_agent_al_interface_name with NULL input and verify that the interface name is not set to NULL | input_name = NULL, output interface name != NULL | The API should handle the NULL input by not setting the interface name to NULL, hence EXPECT_STRNE assertion passes | Should Pass |
 */
TEST(dm_easy_mesh_t, set_agent_al_interface_name_null_input) {
    std::cout << "Entering set_agent_al_interface_name_null_input test" << std::endl;
    dm_easy_mesh_t obj;
    char* input_name = NULL;
    std::cout << "Invoking set_agent_al_interface_name with input: NULL" << std::endl;
    obj.set_agent_al_interface_name(input_name);    
    std::cout << "Retrieved interface name after NULL input: " << obj.m_device.m_device_info.intf.name << std::endl;
    EXPECT_STRNE(obj.m_device.m_device_info.intf.name, NULL);
    std::cout << "Exiting set_agent_al_interface_name_null_input test" << std::endl;
}

/**
 * @brief Verify that the interface name is correctly handled when an empty string is provided
 *
 * This test ensures that calling set_agent_al_interface_name with an empty string correctly resets the interface name to an empty string without causing any errors. It validates that the API can handle empty input gracefully.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 430@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                 | Test Data                                                  | Expected Result                                                                                          | Notes      |
 * | :--------------: | ------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- | ---------- |
 * | 01               | Create dm_easy_mesh_t object and invoke set_agent_al_interface_name with an empty string       | input_name = "", output_interface_name expected = ""       | API sets the interface name to an empty string and EXPECT_STREQ assertion passes                          | Should Pass|
 */
TEST(dm_easy_mesh_t, set_agent_al_interface_name_empty_string) {
    std::cout << "Entering set_agent_al_interface_name_empty_string test" << std::endl;
    dm_easy_mesh_t obj;    
    char input_name[] = "";
    std::cout << "Invoking set_agent_al_interface_name with input: empty string" << std::endl;
    obj.set_agent_al_interface_name(input_name);
    std::cout << "Retrieved interface name after empty string input: " << obj.m_device.m_device_info.intf.name << std::endl;
    EXPECT_STREQ(obj.m_device.m_device_info.intf.name, "");
    std::cout << "Exiting set_agent_al_interface_name_empty_string test" << std::endl;
}

/**
 * @brief Validate set_agent_al_interface_name behavior with invalid character input.
 *
 * This test verifies that the set_agent_al_interface_name function correctly handles inputs containing invalid characters. It ensures that when the input "eth$0" is provided, the internal interface name within the object is set to the same value without alteration.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 431@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                  | Test Data                                             | Expected Result                                                                  | Notes       |
 * | :--------------: | -------------------------------------------------------------------------------------------- | ----------------------------------------------------- | --------------------------------------------------------------------------------- | ----------- |
 * | 01               | Invoke set_agent_al_interface_name with an interface name containing invalid characters ("eth$0"). | input_name = "eth$0", output expected = "eth$0"        | The interface name should be set to "eth$0" and match the expected result from API. | Should Pass |
 */
TEST(dm_easy_mesh_t, set_agent_al_interface_name_invalid_characters) {
    std::cout << "Entering set_agent_al_interface_name_invalid_characters test" << std::endl;
    dm_easy_mesh_t obj;    
    char input_name[] = "eth$0";
    std::cout << "Invoking set_agent_al_interface_name with input: " << input_name << std::endl;
    obj.set_agent_al_interface_name(input_name);
    std::cout << "Retrieved interface name after invalid input: " << obj.m_device.m_device_info.intf.name << std::endl;
    EXPECT_STREQ(obj.m_device.m_device_info.intf.name, "eth$0");
    std::cout << "Exiting set_agent_al_interface_name_invalid_characters test" << std::endl;
}

/**
 * @brief Validate adding a new operational class entry using set_channels_list API
 *
 * This test verifies that calling set_channels_list with a new operational class entry correctly updates the internal mesh structure. It initializes a dm_easy_mesh_t object, sets its MAC address, configures an op_class input with specific values, calls set_channels_list, and then checks that the number of opclass entries and the op_class value are updated as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 432@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                                                                                       | Expected Result                                                                                          | Notes        |
 * | :--------------: | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- | ------------ |
 * | 01               | Initialize the dm_easy_mesh_t object and set the device MAC address          | mesh: created object, dev_mac = 0xAA,0xBB,0xCC,0xDD,0xEE,0xFF                                                                  | Mesh object is initialized with the correct MAC address                                                  | Should be successful |
 * | 02               | Configure the op_class input with type, op_class value, and RUID               | input[0].id.type = em_op_class_type_current, input[0].id.op_class = 81, input[0].ruid = 0x10,0x20,0x30,0x40,0x50,0x60             | op_class input is correctly initialized with the provided values                                         | Should be successful |
 * | 03               | Call set_channels_list API and verify the mesh structure updates              | API call: set_channels_list(input, 1), output: mesh.m_num_opclass, mesh.m_op_class[0].id.op_class                                 | mesh.m_num_opclass equals 1; mesh.m_op_class[0].id.op_class equals 81                                      | Should Pass  |
 */
TEST(dm_easy_mesh_t, set_channels_list_AddNewOpClass)
{
    std::cout << "Entering set_channels_list_AddNewOpClass test" << std::endl;
    dm_easy_mesh_t mesh;
    unsigned char dev_mac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    memcpy(mesh.m_device.m_device_info.intf.mac, dev_mac, 6);
    dm_op_class_t input[1];
    memset(input, 0, sizeof(input));
    input[0].m_op_class_info.id.type = em_op_class_type_current;
    input[0].m_op_class_info.id.op_class = 81;
    unsigned char ruid[6] = {0x10, 0x20, 0x30, 0x40, 0x50, 0x60};
    memcpy(input[0].m_op_class_info.id.ruid, ruid, 6);
    std::cout << "Invoking set_channels_list(op_class, 1)" << std::endl;
    mesh.set_channels_list(input, 1);
    EXPECT_EQ(mesh.m_num_opclass, 1u);
    EXPECT_EQ(mesh.m_op_class[0].m_op_class_info.id.op_class, 81);
    std::cout << "Stored RUID: ";
    for (int i = 0; i < 6; i++) {
        std::cout << std::hex
                  << static_cast<unsigned int>(
                         mesh.m_op_class[0].m_op_class_info.id.ruid[i]);
        if (i < 5) std::cout << ":";
    }
    std::cout << std::dec << std::endl;
    std::cout << "Exiting set_channels_list_AddNewOpClass test" << std::endl;
}

/**
 * @brief Verify that set_channels_list correctly replaces an existing operational class in the mesh instance.
 *
 * This test initializes a mesh instance with an existing op class entry and then calls set_channels_list to replace it. The test verifies that the number of op classes remains 1 and that the stored op class details (ID and RUID) correctly reflect the values provided via the input. This ensures that the API correctly updates the op class information without adding extra entries.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 433@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |@n
 * | :----: | --------- | ---------- |-------------- | ----- |@n
 * | 01 | Initialize mesh instance with device MAC and an existing op class | dev_mac = {0xDE, 0xAD, 0xBE, 0xEF, 0x00, 0x01}, m_num_opclass = 1, op_class_info: type = em_op_class_type_current, op_class = 81, ruid = dev_mac | Mesh instance has one op class entry initialized as per input values | Should be successful |@n
 * | 02 | Prepare input array with new op class information matching the existing one | input[0]: op_class_info: type = em_op_class_type_current, op_class = 81, ruid = dev_mac | Input op class structure is prepared with the expected values to update the mesh | Should be successful |@n
 * | 03 | Call set_channels_list with the prepared input to replace the existing op class | Function call: mesh.set_channels_list(input, 1) | The mesh's op class list is updated, retaining only one entry with correct op class details | Should Pass |@n
 * | 04 | Verify that the mesh op class count and details are correct after replacement | Check m_num_opclass (expected 1), op_class_info.id.op_class (expected 81), and ruid (expected dev_mac) | EXPECT_EQ(mesh.m_num_opclass, 1u) passes and the op class details match the expected values | Should Pass |
 */
TEST(dm_easy_mesh_t, set_channels_list_ReplaceExistingOpClass)
{
    std::cout << "Entering set_channels_list_ReplaceExistingOpClass test" << std::endl;
    dm_easy_mesh_t mesh;
    unsigned char dev_mac[6] = {0xDE, 0xAD, 0xBE, 0xEF, 0x00, 0x01};
    memcpy(mesh.m_device.m_device_info.intf.mac, dev_mac, 6);
    mesh.m_num_opclass = 1;
    mesh.m_op_class[0].m_op_class_info.id.type = em_op_class_type_current;
    mesh.m_op_class[0].m_op_class_info.id.op_class = 81;
    memcpy(mesh.m_op_class[0].m_op_class_info.id.ruid, dev_mac, 6);
    dm_op_class_t input[1];
    memset(input, 0, sizeof(input));
    input[0].m_op_class_info.id.type = em_op_class_type_current;
    input[0].m_op_class_info.id.op_class = 81;
    memcpy(input[0].m_op_class_info.id.ruid, dev_mac, 6);
    std::cout << "Invoking set_channels_list(op_class, 1)" << std::endl;
    mesh.set_channels_list(input, 1);
    EXPECT_EQ(mesh.m_num_opclass, 1u);
    std::cout << "Stored op_class: " << mesh.m_op_class[0].m_op_class_info.id.op_class << std::endl;
    std::cout << "Stored RUID: ";
    for (int i = 0; i < 6; i++) {
        std::cout << std::hex
                  << static_cast<unsigned int>(
                         mesh.m_op_class[0].m_op_class_info.id.ruid[i])
                  << (i < 5 ? ":" : "");
    }
    std::cout << std::dec << std::endl;
    std::cout << "Exiting set_channels_list_ReplaceExistingOpClass test" << std::endl;
}

/**
 * @brief Verify that the channels list auto-fills the RUID when provided as null for an anticipated operation class.
 *
 * This test verifies that when the set_channels_list API is invoked with an op_class entry that has a null RUID and an operation class type set to anticipated, the function auto-fills the RUID with the device's MAC address. The test confirms that the op_class count is updated correctly and the auto-filled RUID matches the expected device MAC address.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 434@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                         | Test Data                                                                                                                  | Expected Result                                                                                                                             | Notes           |
 * | :--------------: | --------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | --------------- |
 * |       01       | Initialize the device MAC and prepare an op_class entry with anticipated type and null RUID         | dev_mac = [0x01,0x02,0x03,0x04,0x05,0x06], op_class: type = anticipated, op_class = 115, ruid = [0,0,0,0,0,0]              | Device structure initialized with valid MAC and op_class entry prepared                                                                     | Should be successful |
 * |       02       | Invoke set_channels_list API with the prepared op_class array and its size                           | input = op_class array, size = 1                                                                                           | API is executed and op_class count is updated internally                                                                                    | Should Pass     |
 * |       03       | Assert that the op_class count is exactly 1 and the auto-filled RUID matches the device MAC address   | m_num_opclass expected = 1, auto-filled ruid expected = dev_mac                                                            | m_num_opclass equals 1 and memcmp between op_class RUID and dev_mac returns 0                                                                  | Should Pass     |
 * |       04       | Log the auto-filled RUID for verification in the console                                            | Printed output: hexadecimal representation of the device MAC                                                               | Confirmation log with the correct RUID displayed in hexadecimal format                                                                      | Should be successful |
 */
TEST(dm_easy_mesh_t, set_channels_list_NullRuidAutoFilledForAnticipated)
{
    std::cout << "Entering set_channels_list_NullRuidAutoFilledForAnticipated test" << std::endl;
    dm_easy_mesh_t mesh;
    unsigned char dev_mac[6] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06};
    memcpy(mesh.m_device.m_device_info.intf.mac, dev_mac, 6);
    dm_op_class_t input[1];
    memset(input, 0, sizeof(input));
    input[0].m_op_class_info.id.type = em_op_class_type_anticipated;
    input[0].m_op_class_info.id.op_class = 115;
    memset(input[0].m_op_class_info.id.ruid, 0, 6);
    std::cout << "Invoking set_channels_list(op_class, 1)" << std::endl;
    mesh.set_channels_list(input, 1);
    EXPECT_EQ(mesh.m_num_opclass, 1u);
    EXPECT_EQ(memcmp(mesh.m_op_class[0].m_op_class_info.id.ruid, dev_mac, 6), 0);
    std::cout << "Auto-filled RUID: ";
    for (int i = 0; i < 6; i++) {
        std::cout << std::hex
                  << static_cast<unsigned int>(
                         mesh.m_op_class[0].m_op_class_info.id.ruid[i])
                  << (i < 5 ? ":" : "");
    }
    std::cout << std::dec << std::endl;
    std::cout << "Exiting set_channels_list_NullRuidAutoFilledForAnticipated test" << std::endl;
}

/**
 * @brief Test for set_channels_list API with zero input count.
 *
 * This test verifies that invoking set_channels_list with a nullptr for the channels list and a count of 0
 * leaves the dm_easy_mesh_t object's m_num_opclass member unchanged (expected to remain 0). This ensures
 * that the API correctly handles cases where no channels are provided.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 435@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                       | Test Data                                                         | Expected Result                                     | Notes      |
 * | :--------------: | ----------------------------------------------------------------- | ----------------------------------------------------------------- | --------------------------------------------------- | ---------- |
 * | 01               | Invoke set_channels_list with nullptr and count value 0           | input: channels = nullptr, count = 0; output: m_num_opclass = 0u    | m_num_opclass remains 0u after the call              | Should Pass|
 */
TEST(dm_easy_mesh_t, set_channels_list_ZeroInputCount)
{
    std::cout << "Entering set_channels_list_ZeroInputCount test" << std::endl;
    dm_easy_mesh_t mesh;
    std::cout << "Invoking set_channels_list(nullptr, 0)" << std::endl;
    mesh.set_channels_list(nullptr, 0);
    EXPECT_EQ(mesh.m_num_opclass, 0u);
    std::cout << "m_num_opclass: " << mesh.m_num_opclass << std::endl;
    std::cout << "Exiting set_channels_list_ZeroInputCount test" << std::endl;
}

/**
 * @brief Verify that set_channels_list correctly handles operations with the same RUID but different operating classes.
 *
 * This test ensures that when two op_class objects with the same RUID are provided but with differing op_class values, 
 * the dm_easy_mesh_t::set_channels_list function correctly stores both entries and updates the internal count accordingly.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 436@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                 | Test Data                                                                                                     | Expected Result                                                                                                     | Notes         |
 * | :--------------: | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize the mesh object and set the device MAC address                                   | mesh object, dev_mac = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA}                                                   | mesh object is created and device MAC is correctly assigned                                                         | Should be successful |
 * | 02               | Prepare 2 op_class objects with the same RUID but different op_class values and call set_channels_list | input[0]: op_class = 80, RUID = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA}; input[1]: op_class = 81, RUID = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA} | The set_channels_list API is invoked with two op_class objects and processes them without error                        | Should Pass   |
 * | 03               | Validate that the op_class list was stored correctly and the count is updated to 2            | mesh.m_num_opclass expected = 2; mesh.m_op_class[i].m_op_class_info.id.op_class should equal 80 for i=0 and 81 for i=1 | The mesh internal count equals 2 and each op_class value is stored as expected                                        | Should Pass   |
 */
TEST(dm_easy_mesh_t, set_channels_list_SameRuidDifferentOpClass)
{
    std::cout << "Entering set_channels_list_SameRuidDifferentOpClass test" << std::endl;
    dm_easy_mesh_t mesh;
    unsigned char dev_mac[6] = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA};
    memcpy(mesh.m_device.m_device_info.intf.mac, dev_mac, 6);
    dm_op_class_t input[2];
    memset(input, 0, sizeof(input));
    for (int i = 0; i < 2; i++) {
        input[i].m_op_class_info.id.type = em_op_class_type_current;
        input[i].m_op_class_info.id.op_class = 80 + i;
        memcpy(input[i].m_op_class_info.id.ruid, dev_mac, 6);
    }
    std::cout << "Invoking set_channels_list(op_class, 2)" << std::endl;
    mesh.set_channels_list(input, 2);
    EXPECT_EQ(mesh.m_num_opclass, 2u);
    for (unsigned int i = 0; i < mesh.m_num_opclass; i++) {
        std::cout << "Stored op_class[" << i << "] = "
                  << mesh.m_op_class[i].m_op_class_info.id.op_class
                  << ", RUID=";
        for (int j = 0; j < 6; j++) {
            std::cout << std::hex
                      << static_cast<unsigned int>(
                             mesh.m_op_class[i].m_op_class_info.id.ruid[j])
                      << (j < 5 ? ":" : "");
        }
        std::cout << std::dec << std::endl;
    }
    std::cout << "Exiting set_channels_list_SameRuidDifferentOpClass test" << std::endl;
}

/**
 * @brief Test the valid copying of command context into dm_easy_mesh_t object
 *
 * This test verifies that the set_cmd_ctx API correctly copies a valid command context structure to the mesh object's member. 
 * It checks that after setting the command context, all the fields (arr_index, type, and obj_id) match the input values.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 437@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                                            | Expected Result                                                                           | Notes      |
 * | :--------------: | --------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | ---------- |
 * | 01               | Call set_cmd_ctx with a valid command context having arr_index=10, type=dm_orch_type_net_insert, and obj_id="network_001" | ctx.arr_index = 10, ctx.type = dm_orch_type_net_insert, ctx.obj_id = network_001 | mesh.m_cmd_ctx.arr_index equals 10, mesh.m_cmd_ctx.type equals dm_orch_type_net_insert, and mesh.m_cmd_ctx.obj_id equals "network_001" | Should Pass |
 */
TEST(dm_easy_mesh_t, set_cmd_ctx_ValidCmdCtxCopy)
{
    std::cout << "Entering set_cmd_ctx_ValidCmdCtxCopy test" << std::endl;
    dm_easy_mesh_t mesh;
    em_cmd_ctx_t ctx{};
    ctx.arr_index = 10;
    ctx.type = dm_orch_type_net_insert;
    strncpy(ctx.obj_id, "network_001", sizeof(ctx.obj_id) - 1);
    std::cout << "Invoking set_cmd_ctx(&ctx)" << std::endl;
    mesh.set_cmd_ctx(&ctx);
    EXPECT_EQ(mesh.m_cmd_ctx.arr_index, 10u);
    EXPECT_EQ(mesh.m_cmd_ctx.type, dm_orch_type_net_insert);
    EXPECT_STREQ(mesh.m_cmd_ctx.obj_id, "network_001");
    std::cout << "Retrieved arr_index : " << mesh.m_cmd_ctx.arr_index << std::endl;
    std::cout << "Retrieved type      : " << mesh.m_cmd_ctx.type << std::endl;
    std::cout << "Retrieved obj_id    : " << mesh.m_cmd_ctx.obj_id << std::endl;
    std::cout << "Exiting set_cmd_ctx_ValidCmdCtxCopy test" << std::endl;
}

/**
 * @brief Validate command context setup using a zero-initialized context
 *
 * This test verifies that when a zero-initialized command context is provided to the mesh object using the set_cmd_ctx API, the mesh's command context fields are initialized with default values.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 438@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                         | Test Data                                                                                                          | Expected Result                                                                                                   | Notes      |
 * | :--------------: | --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- | ---------- |
 * | 01               | Initialize a zero-initialized command context, call set_cmd_ctx, and validate that mesh fields are correctly set. | zero_ctx = {0}, expected: m_cmd_ctx.arr_index = 0, m_cmd_ctx.type = dm_orch_type_none, m_cmd_ctx.obj_id = "" | mesh.m_cmd_ctx.arr_index equals 0u, mesh.m_cmd_ctx.type equals dm_orch_type_none, mesh.m_cmd_ctx.obj_id is an empty string | Should Pass |
 */
TEST(dm_easy_mesh_t, set_cmd_ctx_ZeroInitializedCmdCtx)
{
    std::cout << "Entering ZeroInitializedCmdCtx test" << std::endl;
    dm_easy_mesh_t mesh;
    em_cmd_ctx_t zero_ctx;
    memset(&zero_ctx, 0, sizeof(zero_ctx));
    std::cout << "Invoking set_cmd_ctx(&zero_ctx)" << std::endl;
    mesh.set_cmd_ctx(&zero_ctx);
    EXPECT_EQ(mesh.m_cmd_ctx.arr_index, 0u);
    EXPECT_EQ(mesh.m_cmd_ctx.type, dm_orch_type_none);
    EXPECT_STREQ(mesh.m_cmd_ctx.obj_id, "");
    std::cout << "Retrieved arr_index : " << mesh.m_cmd_ctx.arr_index << std::endl;
    std::cout << "Retrieved type      : " << mesh.m_cmd_ctx.type << std::endl;
    std::cout << "Retrieved obj_id    : '" << mesh.m_cmd_ctx.obj_id << "'" << std::endl;
    std::cout << "Exiting set_cmd_ctx_ZeroInitializedCmdCtx test" << std::endl;
}

/**
 * @brief Validate that set_cmd_ctx correctly handles a null pointer input by throwing an exception.
 *
 * This test verifies that invoking the set_cmd_ctx method with a null pointer (ctx = nullptr) results in an exception being thrown. 
 * It ensures that the API properly detects undefined behavior when an invalid command context pointer is provided.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 439@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                  | Expected Result                                        | Notes      |
 * | :--------------: | --------------------------------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------ | ---------- |
 * | 01               | Invoke set_cmd_ctx with a nullptr command context pointer to trigger exception | mesh = instance of dm_easy_mesh_t, ctx = nullptr | The method should throw an exception (validated by EXPECT_ANY_THROW) | Should Fail |
 */
TEST(dm_easy_mesh_t, set_cmd_ctx_NullCmdCtxPointer)
{
    std::cout << "Entering set_cmd_ctx_NullCmdCtxPointer test" << std::endl;
    dm_easy_mesh_t mesh;
    em_cmd_ctx_t *ctx = nullptr;
    std::cout << "Invoking set_cmd_ctx(nullptr) - undefined behavior" << std::endl;
    EXPECT_ANY_THROW(mesh.set_cmd_ctx(ctx));
    std::cout << "Exiting set_cmd_ctx_NullCmdCtxPointer test" << std::endl;
}

/**
 * @brief Verify that setting the colocated flag to true works as expected.
 *
 * This test checks that the dm_easy_mesh_t object's set_colocated method correctly updates the m_colocated member variable to true when invoked with true. The test ensures that the boolean flag is appropriately set and validates proper API functionality.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 440@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Log entering the test | n/a | Entry message printed to console | Should be successful |
 * | 02 | Invoke set_colocated(true) on dm_easy_mesh_t instance | input: true, output: none | m_colocated is set to true inside the object | Should Pass |
 * | 03 | Retrieve m_colocated value and perform assertion check | input: m_colocated value = true, expected: true | EXPECT_TRUE validates that m_colocated is true | Should Pass |
 * | 04 | Log exiting the test | n/a | Exit message printed to console | Should be successful |
 */
TEST(dm_easy_mesh_t, set_colocated_set_true)
{
    std::cout << "Entering set_colocated_set_true test" << std::endl;
    dm_easy_mesh_t mesh;
    std::cout << "Invoking set_colocated with value: true" << std::endl;
    mesh.set_colocated(true);
    std::cout << "Retrieved m_colocated: " << std::boolalpha << mesh.m_colocated << std::endl;
    EXPECT_TRUE(mesh.m_colocated);
    std::cout << "Exiting set_colocated_set_true test" << std::endl;
}

/**
 * @brief Test for setting the 'colocated' flag to false.
 *
 * This test verifies that calling the set_colocated API with a value of false correctly updates the internal state of the dm_easy_mesh_t object. The test checks that the m_colocated flag is set to false.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 441@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | --------------- | ----- |
 * | 01 | Instantiate dm_easy_mesh_t object | N/A | Object is created successfully | Should be successful |
 * | 02 | Invoke set_colocated with parameter false | input: false, output: m_colocated flag unset (default state) | m_colocated is set to false | Should Pass |
 * | 03 | Verify the m_colocated flag using EXPECT_FALSE | retrieved m_colocated flag = false | EXPECT_FALSE assertion passes confirming m_colocated is false | Should Pass |
 */
TEST(dm_easy_mesh_t, set_colocated_set_false)
{
    std::cout << "Entering set_colocated_set_false test" << std::endl;    
    dm_easy_mesh_t mesh;
    std::cout << "Invoking set_colocated with value: false" << std::endl;
    mesh.set_colocated(false);
    std::cout << "Retrieved m_colocated: " << std::boolalpha << mesh.m_colocated << std::endl;
    EXPECT_FALSE(mesh.m_colocated);
    std::cout << "Exiting set_colocated_set_false test" << std::endl;
}

/**
 * @brief Verify that the set_controller_id API accepts a valid MAC address and updates the internal controller ID accordingly
 *
 * This test ensures that when a valid MAC address is provided to the set_controller_id method of dm_easy_mesh_t, the internal controller ID is correctly updated. The test prints the MAC address before invoking the API and then verifies that the memory comparison of the internal controller ID with the provided MAC address yields a match.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 442@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                         | Test Data                                                                                      | Expected Result                                                                                       | Notes           |
 * | :--------------: | ------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | --------------- |
 * | 01               | Invoke set_controller_id with a valid MAC address                   | input: valid_mac = {0x1A, 0x1B, 0x2C, 0x3D, 0x4E, 0x5E}                                         | The API is called without error and internal state is updated accordingly                           | Should Pass     |
 * | 02               | Verify that the controller MAC address is updated correctly by asserting that the memory content of the stored MAC matches the valid MAC provided | input: expected_mac = {0x1A, 0x1B, 0x2C, 0x3D, 0x4E, 0x5E}, actual_mac = dm_easy_mesh_t.m_network.m_net_info.ctrl_id.mac | memcmp returns 0 indicating the stored MAC and provided MAC are identical                             | Should be successful |
 */
TEST(dm_easy_mesh_t, set_controller_id_valid_mac_address_update)
{
    std::cout << "Entering set_controller_id_valid_mac_address_update test" << std::endl;
    dm_easy_mesh_t meshObj;
    unsigned char valid_mac[6] = {0x1A, 0x1B, 0x2C, 0x3D, 0x4E, 0x5E};
    std::cout << "Invoking set_controller_id with valid MAC: ";
    for (int i = 0; i < 6; i++) {
        std::cout << std::hex << static_cast<int>(valid_mac[i]) << " ";
    }
    std::cout << std::dec << std::endl;
    meshObj.set_controller_id(valid_mac);
    EXPECT_EQ(memcmp(meshObj.m_network.m_net_info.ctrl_id.mac, valid_mac, sizeof(valid_mac)), 0);    
    std::cout << "Exiting set_controller_id_valid_mac_address_update test" << std::endl;
}

/**
 * @brief Test set_controller_id API with a null pointer.
 *
 * This test verifies that the dm_easy_mesh_t::set_controller_id method correctly handles receiving a null pointer by throwing an exception, thus ensuring proper input validation.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 443@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                              | Test Data                                          | Expected Result                                                       | Notes       |
 * | :--------------: | ---------------------------------------------------------------------------------------- | -------------------------------------------------- | --------------------------------------------------------------------- | ----------- |
 * | 01               | Invoke set_controller_id with a null pointer to test input validation and error handling. | input: null_mac = nullptr, object: dm_easy_mesh_t instance | API should throw an exception upon receiving a null pointer.          | Should Fail |
 */
TEST(dm_easy_mesh_t, set_controller_id_null_pointer)
{
    std::cout << "Entering set_controller_id_null_pointer test" << std::endl;
    dm_easy_mesh_t meshObj;
    unsigned char* null_mac = nullptr;
    std::cout << "Invoking set_controller_id with a null pointer." << std::endl;
    EXPECT_ANY_THROW(meshObj.set_controller_id(null_mac));
    std::cout << "Exiting set_controller_id_null_pointer test" << std::endl;
}

/**
 * @brief Verify that set_controller_id throws an exception when provided with an incomplete MAC address
 *
 * This test verifies that the set_controller_id API correctly identifies an invalid MAC address (incomplete or erroneous) 
 * and throws an exception. The test ensures that any attempt to set a controller identifier with a faulty MAC address is properly handled.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 444@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                         | Test Data                                                                                   | Expected Result                                           | Notes            |
 * | :--------------: | ------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | --------------------------------------------------------- | ---------------- |
 * | 01               | Create an instance of dm_easy_mesh_t and prepare an invalid MAC array | invalid_mac = 0x00,0x1B,0x2C,0x3D,0x4E,0x5E; object = dm_easy_mesh_t instance created         | Instance is created and invalid MAC address is available  | Should be successful |
 * | 02               | Invoke set_controller_id using the invalid MAC address and verify that an exception is thrown | input: invalid_mac = 0x00,0x1B,0x2C,0x3D,0x4E,0x5E; output: Exception thrown by the API | Exception is thrown by set_controller_id call             | Should Fail      |
 */
TEST(dm_easy_mesh_t, set_controller_id_incomplete_mac_address)
{
    std::cout << "Entering set_controller_id_incomplete_mac_ddress test" << std::endl;
    dm_easy_mesh_t meshObj;
    unsigned char invalid_mac[6] = {0x00, 0x1B, 0x2C, 0x3D, 0x4E, 0x5E};
    std::cout << "Invoking set_controller_id with an invalid MAC address: 00:1B:2C:3D:4E:5E";    
    EXPECT_ANY_THROW(meshObj.set_controller_id(invalid_mac));
    std::cout << "Exiting set_controller_id_incomplete_mac_address test" << std::endl;
}

/**
 * @brief Test set_controller_intf_media with valid media types
 *
 * This test verifies that the dm_easy_mesh_t API correctly sets the media type in the network information structure when provided with valid media types. It iterates through a predefined array of valid media values, invokes the set_controller_intf_media API, and asserts that the underlying media field is updated accordingly.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 445@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |@n
 * | :----: | --------- | ---------- |-------------- | ----- |@n
 * | 01 | Initialize dm_easy_mesh_t instance and define valid media types array | None | dm_easy_mesh_t object is created and validMedia array is initialized | Should be successful |@n
 * | 02 | Invoke set_controller_intf_media for each valid media type and perform assertion | input media = em_media_type_ieee8023ab, em_media_type_ieee80211b_24, em_media_type_ieee80211g_24, em_media_type_ieee80211a_5, em_media_type_ieee80211n_24, em_media_type_ieee80211n_5, em_media_type_ieee80211ac_5, em_media_type_ieee80211ad_60, em_media_type_ieee80211af; output m_network.m_net_info.media | The media field is equal to the input media value as verified by EXPECT_EQ | Should Pass |@n
 * | 03 | Log test exit messages | None | Test completes with proper log messages indicating successful execution | Should be successful |
 */
TEST(dm_easy_mesh_t, set_controller_intf_media_valid_media_types) {
    std::cout << "Entering set_controller_intf_media_valid_media_types test" << std::endl;
    dm_easy_mesh_t obj;
    em_media_type_t validMedia[] = {
        em_media_type_ieee8023ab,
        em_media_type_ieee80211b_24,
        em_media_type_ieee80211g_24,
        em_media_type_ieee80211a_5,
        em_media_type_ieee80211n_24,
        em_media_type_ieee80211n_5,
        em_media_type_ieee80211ac_5,
        em_media_type_ieee80211ad_60,
        em_media_type_ieee80211af
    };
    for(auto media : validMedia) {
        std::cout << "Invoking set_controller_intf_media with media: 0x" << std::hex << media << std::dec << std::endl;
        obj.set_controller_intf_media(media);
		EXPECT_EQ(media, obj.m_network.m_net_info.media);
        std::cout << "Successfully set media to: 0x" << std::hex << media << std::dec << std::endl;
    }
    std::cout << "Exiting set_controller_intf_media_valid_media_types test" << std::endl;
}

/**
 * @brief Test that set_controller_intf_media throws an exception with an invalid media type
 *
 * This test verifies that the set_controller_intf_media API correctly handles an invalid media type. By providing an out-of-range media type (0xFF), the test ensures that the API properly throws an exception, demonstrating robust error handling for unsupported media values.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 446@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                 | Test Data                                                      | Expected Result                                             | Notes         |
 * | :--------------: | ------------------------------------------------------------------------------------------- | -------------------------------------------------------------- | ----------------------------------------------------------- | ------------- |
 * | 01               | Setup test environment by instantiating dm_easy_mesh_t and initializing invalid media value.  | invalidMedia = 0xFF                                            | Instance created and invalid media value set.               | Should be successful |
 * | 02               | Invoke set_controller_intf_media with the invalid media type and check for thrown exception.  | input: invalidMedia = 0xFF, output: exception expected           | API throws an exception indicating invalid input handling.  | Should Fail   |
 */
TEST(dm_easy_mesh_t, set_controller_intf_media_invalid_media_type) {
    std::cout << "Entering set_controller_intf_media_invalid_media_type test" << std::endl;
    dm_easy_mesh_t obj;    
    em_media_type_t invalidMedia = static_cast<em_media_type_t>(0xFF);
    std::cout << "Invoking set_controller_intf_media with invalid media: 0xFF"  << std::endl;
    EXPECT_ANY_THROW(obj.set_controller_intf_media(invalidMedia));
    std::cout << "Exiting set_controller_intf_media_invalid_media_type test" << std::endl;    
}

/**
 * @brief Validates that set_ctrl_al_interface_mac correctly stores a valid MAC address.
 *
 * This test ensures that when a valid MAC address is provided to the set_ctrl_al_interface_mac function,
 * the MAC address is properly set within the mesh object's network information. The test verifies the stored
 * MAC address by comparing it with the provided MAC using memcmp.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 447@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke set_ctrl_al_interface_mac with a valid MAC address and verify that the MAC is correctly stored in the object's network information. | input: mac = 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC | The mesh object's stored MAC (mesh.m_network.m_net_info.colocated_agent_id.mac) matches the input MAC (memcmp returns 0) | Should Pass |
 */
TEST(dm_easy_mesh_t, set_ctrl_al_interface_mac_valid_mac_provided)
{
    std::cout << "Entering set_ctrl_al_interface_mac_valid_mac_provided test" << std::endl;
    dm_easy_mesh_t mesh;
    unsigned char mac[6] = { 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC };
    std::cout << "Invoking set_ctrl_al_interface_mac with MAC: ";
    for (int i = 0; i < 6; i++) {
        std::cout << "0x" << std::hex << static_cast<int>(mac[i]);
        if(i < 5) std::cout << ", ";
    }
    std::cout << std::dec << std::endl;
    mesh.set_ctrl_al_interface_mac(mac);
    EXPECT_EQ(memcmp(mesh.m_network.m_net_info.colocated_agent_id.mac, mac, sizeof(mac)), 0);
    std::cout << "Exiting set_ctrl_al_interface_mac_valid_mac_provided test" << std::endl;
}

/**
 * @brief Verify that calling set_ctrl_al_interface_mac with a null MAC pointer throws an exception
 *
 * This test verifies that the set_ctrl_al_interface_mac API throws an exception when provided with a null MAC pointer.
 * It ensures that the API can properly detect and handle invalid input.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 448@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                        | Test Data                                      | Expected Result                                        | Notes      |
 * | :--------------: | ------------------------------------------------------------------ | ---------------------------------------------- | ------------------------------------------------------ | ---------- |
 * | 01               | Invoke set_ctrl_al_interface_mac with a null MAC pointer             | null_mac = nullptr                             | API throws an exception and the error is caught by EXPECT_ANY_THROW | Should Fail |
 */
TEST(dm_easy_mesh_t, set_ctrl_al_interface_mac_null_mac_provided)
{
    std::cout << "Entering set_ctrl_al_interface_mac_null_mac_provided test" << std::endl;
    dm_easy_mesh_t mesh;
    unsigned char *null_mac = nullptr;
    std::cout << "Invoking set_ctrl_al_interface_mac with MAC: nullptr" << std::endl;
    EXPECT_ANY_THROW(mesh.set_ctrl_al_interface_mac(null_mac));
    std::cout << "Exiting set_ctrl_al_interface_mac_null_mac_provided test" << std::endl;
}

/**
 * @brief Test that set_ctrl_al_interface_name sets the control AL interface name correctly when provided with a valid non-empty string.
 *
 * This test verifies that when a valid non-empty string ("eth0") is provided to the set_ctrl_al_interface_name API, the API correctly updates the control AL interface name in the network information structure. The expected behavior is that the retrieved name matches the supplied input.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 449@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                 | Test Data                                         | Expected Result                                       | Notes         |
 * | :--------------: | ------------------------------------------------------------------------------------------- | ------------------------------------------------- | ----------------------------------------------------- | ------------- |
 * | 01               | Instantiate the dm_easy_mesh_t object to ensure proper object construction.                 | No input parameters                               | Object created successfully                           | Should be successful |
 * | 02               | Invoke set_ctrl_al_interface_name API with a valid non-empty string "eth0".                 | input name = "eth0"                               | API sets control AL interface name to "eth0"          | Should Pass   |
 * | 03               | Verify that the control AL interface name is correctly stored using EXPECT_STREQ.             | output name value from object: "eth0"             | Stored name matches "eth0" as asserted by EXPECT_STREQ | Should Pass   |
 */
TEST(dm_easy_mesh_t, set_ctrl_al_interface_name_valid_non_empty)
{
    std::cout << "Entering set_ctrl_al_interface_name_valid_non_empty test" << std::endl;
    dm_easy_mesh_t mesh;    
    char name[] = "eth0";
    std::cout << "Invoking set_ctrl_al_interface_name with name: " << name << std::endl;
    mesh.set_ctrl_al_interface_name(name);
    std::cout << "Retrieved control AL interface name: " << mesh.m_network.m_net_info.colocated_agent_id.name << std::endl;
    EXPECT_STREQ(mesh.m_network.m_net_info.colocated_agent_id.name, "eth0");
    std::cout << "Exiting set_ctrl_al_interface_name_valid_non_empty test" << std::endl;
}

/**
 * @brief Validates setting of control AL interface name with special characters in the name.
 *
 * This test verifies that the API correctly assigns the provided interface name containing special characters and alphanumeric values. The function set_ctrl_al_interface_name is invoked with a name ("eth0_net123") that includes underscores and numbers, and the outcome is checked to ensure that the internal state reflects the same name. This ensures that the function handles interface names with mixed characters appropriately.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 450@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke set_ctrl_al_interface_name with a string including special characters "eth0_net123" and verify that the control AL interface name is set correctly. | input: name = eth0_net123, output: expected name = eth0_net123 | The API should set the control AL interface name to "eth0_net123" and the internal state should reflect the same | Should Pass |
 */
TEST(dm_easy_mesh_t, set_ctrl_al_interface_name_with_special_characters)
{
    std::cout << "Entering set_ctrl_al_interface_name_with_special_characters test" << std::endl;
    dm_easy_mesh_t mesh;
    char name[] = "eth0_net123";
    std::cout << "Invoking set_ctrl_al_interface_name with name: " << name << std::endl;
    mesh.set_ctrl_al_interface_name(name);
    std::cout << "Retrieved control AL interface name: " << mesh.m_network.m_net_info.colocated_agent_id.name << std::endl;
    EXPECT_STREQ(mesh.m_network.m_net_info.colocated_agent_id.name, "eth0_net123");
    std::cout << "Exiting set_ctrl_al_interface_name_with_special_characters test" << std::endl;
}

/**
 * @brief Verify that setting an empty control AL interface name is handled correctly
 *
 * This test verifies that the set_ctrl_al_interface_name method in the dm_easy_mesh_t class correctly processes an empty string input. In this test, we create a dm_easy_mesh_t instance, invoke the set_ctrl_al_interface_name method with an empty string, and then check if the internal agent name is set to an empty string as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 451@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                | Test Data                                                              | Expected Result                                                      | Notes       |
 * | :--------------: | ---------------------------------------------------------- | ---------------------------------------------------------------------- | -------------------------------------------------------------------- | ----------- |
 * | 01               | Instantiate dm_easy_mesh_t, call set_ctrl_al_interface_name with an empty string, and verify the internal agent name is empty | name = ""; output (mesh.m_network.m_net_info.colocated_agent_id.name) = "" | The method should update the internal control AL interface name to an empty string and EXPECT_STREQ should pass | Should Pass |
 */
TEST(dm_easy_mesh_t, set_ctrl_al_interface_name_empty)
{
    std::cout << "Entering set_ctrl_al_interface_name_empty test" << std::endl;
    dm_easy_mesh_t mesh;
    char name[] = "";
    std::cout << "Invoking set_ctrl_al_interface_name with empty string" << std::endl;
    mesh.set_ctrl_al_interface_name(name);    
    std::cout << "Retrieved control AL interface name: \"" << mesh.m_network.m_net_info.colocated_agent_id.name << "\"" << std::endl;
    EXPECT_STREQ(mesh.m_network.m_net_info.colocated_agent_id.name, "");
    std::cout << "Exiting set_ctrl_al_interface_name_empty test" << std::endl;
}

/**
 * @brief Test for verifying that set_ctrl_al_interface_name correctly throws an exception when provided with a nullptr.
 *
 * This test checks whether the dm_easy_mesh_t::set_ctrl_al_interface_name API properly handles a null pointer input by throwing an exception. The function invocation with a nullptr is expected to trigger an exception, which is verified using EXPECT_ANY_THROW.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 452@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Call set_ctrl_al_interface_name with a nullptr to verify exception is thrown | mesh object created, input: interface name = nullptr | Exception is thrown and EXPECT_ANY_THROW passes | Should Pass |
 */
TEST(dm_easy_mesh_t, set_ctrl_al_interface_name_null_input)
{
    std::cout << "Entering set_ctrl_al_interface_name_null_input test" << std::endl;
    dm_easy_mesh_t mesh;
    std::cout << "Invoking set_ctrl_al_interface_name with NULL pointer" << std::endl;
    EXPECT_ANY_THROW(mesh.set_ctrl_al_interface_name(nullptr));
    std::cout << "Exiting set_ctrl_al_interface_name_null_input test" << std::endl;
}

/**
 * @brief Test to verify that setting a valid single configuration type updates the db configuration parameters correctly.
 *
 * This test checks that when a valid configuration type (db_cfg_type_network_list_update) and a corresponding criteria string ("net_id=1") are provided, the dm_easy_mesh_t object correctly updates its internal database configuration parameters. The test involves initializing the object, invoking the API with valid parameters, and asserting the expected outcomes.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 453@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                   | Test Data                                                                                     | Expected Result                                                                                      | Notes          |
 * | :--------------: | ------------------------------------------------------------- | --------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | -------------- |
 * | 01               | Initialize the dm_easy_mesh_t instance by calling init()      | instance = mesh                                                                               | Mesh internal state is properly initialized                                                          | Should be successful |
 * | 02               | Set the criteria string value for the configuration parameter | criteria = "net_id=1"                                                                           | Criteria string is assigned                                                                          | Should be successful |
 * | 03               | Invoke set_db_cfg_param API with valid configuration parameters | input1 = db_cfg_type_network_list_update, input2 = "net_id=1"                                   | API correctly updates db_cfg_type and db_cfg_criteria with provided values                           | Should Pass    |
 * | 04               | Validate the configuration parameters using assertions        | output1 = mesh.m_db_cfg_param.db_cfg_type, output2 = mesh.m_db_cfg_param.db_cfg_criteria[0]       | EXPECT_EQ validates db_cfg_type equals db_cfg_type_network_list_update and EXPECT_STREQ validates the criteria string | Should Pass    |
 */
TEST(dm_easy_mesh_t, set_db_cfg_param_ValidSingleCfgType)
{
    std::cout << "Entering set_db_cfg_param_ValidSingleCfgType test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    const char *criteria = "net_id=1";
    std::cout << "Invoking set_db_cfg_param(db_cfg_type_network_list_update, \"net_id=1\")" << std::endl;
    mesh.set_db_cfg_param(db_cfg_type_network_list_update, criteria);
    EXPECT_EQ(mesh.m_db_cfg_param.db_cfg_type, static_cast<unsigned int>(db_cfg_type_network_list_update));
    EXPECT_STREQ(mesh.m_db_cfg_param.db_cfg_criteria[0], criteria);
    std::cout << "Retrieved db_cfg_type: " << mesh.m_db_cfg_param.db_cfg_type << std::endl;
    std::cout << "Retrieved db_cfg_criteria[0]: " << mesh.m_db_cfg_param.db_cfg_criteria[0] << std::endl;
    mesh.deinit();
    std::cout << "Exiting set_db_cfg_param_ValidSingleCfgType test" << std::endl;
}

/**
 * @brief Verify that combining multiple configuration types results in an invalid configuration.
 *
 * This test checks that when an invalid combined configuration type is passed to set_db_cfg_param,
 * the internal configuration remains unchanged (i.e., 0). This ensures that the API does not accept
 * unintended combined values which could potentially lead to undefined behavior.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 454@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize the mesh object and invoke its init method, then set an invalid combined db_cfg_type and call set_db_cfg_param. | mesh.init(), invalid_type = db_cfg_type_network_list_update,db_cfg_type_device_list_update, parameter = "invalid" | The db_cfg_type field remains 0 and the EXPECT_EQ assertion passes. | Should Pass |
 */
TEST(dm_easy_mesh_t, set_db_cfg_param_InvalidCombinedCfgType)
{
    std::cout << "Entering set_db_cfg_param_InvalidCombinedCfgType test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    db_cfg_type_t invalid_type = static_cast<db_cfg_type_t>(db_cfg_type_network_list_update | db_cfg_type_device_list_update);
    std::cout << "Invoking set_db_cfg_param(invalid_combined_type, \"invalid\")" << std::endl;
    mesh.set_db_cfg_param(invalid_type, "invalid");
    EXPECT_EQ(mesh.m_db_cfg_param.db_cfg_type, 0u);
    std::cout << "Retrieved db_cfg_type: " << mesh.m_db_cfg_param.db_cfg_type << std::endl;
    mesh.deinit();
    std::cout << "Exiting set_db_cfg_param_InvalidCombinedCfgType test" << std::endl;
}

/**
 * @brief Validates that setting the database configuration parameter with configuration type none sets db_cfg_type to 0.
 *
 * This test initializes a dm_easy_mesh_t object, calls init(), then invokes set_db_cfg_param with parameters (db_cfg_type_none, "none") and verifies that mesh.m_db_cfg_param.db_cfg_type is set to 0u. This ensures the API correctly applies the configuration for a "none" scenario.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 455@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                      | Test Data                                                    | Expected Result                                                      | Notes      |
 * | :--------------: | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------------------------- | ---------- |
 * | 01               | Initialize dm_easy_mesh_t, invoke init(), call set_db_cfg_param with (db_cfg_type_none, "none"), and verify db_cfg_type equals 0u | input1 = db_cfg_type_none, input2 = "none", output1 = 0u       | The API sets mesh.m_db_cfg_param.db_cfg_type to 0u as verified by EXPECT_EQ | Should Pass |
 */
TEST(dm_easy_mesh_t, set_db_cfg_param_ZeroCfgTypeNone)
{
    std::cout << "Entering set_db_cfg_param_ZeroCfgTypeNone test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    std::cout << "Invoking set_db_cfg_param(db_cfg_type_none, \"none\")" << std::endl;
    mesh.set_db_cfg_param(db_cfg_type_none, "none");
    EXPECT_EQ(mesh.m_db_cfg_param.db_cfg_type, 0u);
    std::cout << "Retrieved db_cfg_type: " << mesh.m_db_cfg_param.db_cfg_type << std::endl;
    mesh.deinit();
    std::cout << "Exiting set_db_cfg_param_ZeroCfgTypeNone test" << std::endl;
}

/**
 * @brief Verify that calling set_db_cfg_param with a null criteria parameter correctly throws an exception.
 *
 * This test verifies that the set_db_cfg_param method of dm_easy_mesh_t properly handles invalid input by throwing an exception when a nullptr is provided as the criteria. It is critical to ensure that invalid inputs are not silently accepted, which might lead to undefined behavior.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 456@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                          | Test Data                                                        | Expected Result                                   | Notes             |
 * | :----:           | :----------------------------------------------------------------------------------- | :--------------------------------------------------------------- | :------------------------------------------------ | :---------------- |
 * | 01               | Initialize the dm_easy_mesh_t instance and invoke its init() method.                 | None                                                             | Instance is initialized successfully.           | Should be successful |
 * | 02               | Invoke set_db_cfg_param with db_cfg_type_policy_list_update and criteria as nullptr.   | db_cfg_type_policy_list_update, criteria = nullptr               | An exception is thrown indicating invalid criteria. | Should Pass       |
 */
TEST(dm_easy_mesh_t, set_db_cfg_param_NullCriteria)
{
    std::cout << "Entering set_db_cfg_param_NullCriteria test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    const char *criteria = nullptr;
    std::cout << "Invoking set_db_cfg_param criteria as nullptr" << std::endl;
    EXPECT_ANY_THROW(
    {
        mesh.set_db_cfg_param(db_cfg_type_policy_list_update, criteria);
    });
    mesh.deinit();
    std::cout << "Exiting set_db_cfg_param_NullCriteria test" << std::endl;
}

/**
 * @brief Test to verify that the set_em function assigns a valid pointer correctly.
 *
 * This test verifies that when a valid pointer (validEmPtr) is provided, the set_em method of dm_easy_mesh_t 
 * correctly assigns it to the member variable m_em. It ensures that the internal pointer state is updated 
 * as expected and that the API behaves as intended.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 457@n
 * **Priority:** High
 * 
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                              | Test Data                                                      | Expected Result                                        | Notes      |
 * | :--------------: | -------------------------------------------------------- | -------------------------------------------------------------- | ------------------------------------------------------ | ---------- |
 * | 01               | Invoke set_em on dm with validEmPtr as input         | input: validEmPtr = validEmPtr, output: m_em should equal validEmPtr | dmMesh.m_em equals validEmPtr and EXPECT_EQ passes    | Should Pass|
 */
TEST(dm_easy_mesh_t, set_em_valid_em) {
    std::cout << "Entering set_em_valid_em test" << std::endl;
    em_interface_t ruid;
    strncpy(ruid.name, "Validname", sizeof(ruid.name));
    unsigned char mac[6] = {0x1A, 0x1B, 0x2C, 0x3D, 0x4E, 0x5A};
    memcpy(ruid.mac, mac, sizeof(mac));
    ruid.media = em_media_type_ieee80211b_24;
    dm_easy_mesh_t dm;
    dm.m_colocated = true;
    em_ctrl_t mgr;
    em_t validEmPtr(&ruid ,em_freq_band_5, &dm, &mgr, em_profile_type_1, em_service_type_ctrl, false);    
    std::cout << "Invoking set_em with valid em pointer" << std::endl;
    dm.set_em(&validEmPtr);
    EXPECT_EQ(dm.m_em, &validEmPtr);
    std::cout << "Exiting set_em_valid_em test" << std::endl;
}

/**
 * @brief Test set_em with a null pointer to verify proper exception handling.
 *
 * This test verifies that the dm_easy_mesh_t::set_em method correctly handles a null pointer by throwing an exception. Ensuring that the API reacts appropriately to invalid input is critical for maintaining robust error handling and overall application stability.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 458@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create dm_easy_mesh_t object, assign a null pointer to em_t, and invoke set_em | dmMesh object, nullEmPtr = nullptr, API Call: dmMesh.set_em(nullEmPtr) | An exception is thrown as expected by the EXPECT_ANY_THROW assertion | Should Fail |
 */
TEST(dm_easy_mesh_t, set_em_null_em) {
    std::cout << "Entering set_em_null_em test" << std::endl;
    dm_easy_mesh_t dmMesh;
    em_t* nullEmPtr = nullptr;
    std::cout << "Invoking set_em with null pointer" << std::endl;
    EXPECT_ANY_THROW(dmMesh.set_em(nullEmPtr));
    std::cout << "Exiting set_em_null_em test" << std::endl;
}

/**
 * @brief This test verifies that the set_manufacturer API correctly sets a valid non-empty manufacturer name.
 *
 * This test calls the set_manufacturer method on a dm_easy_mesh_t object using "Apple" as input and ensures that the manufacturer's name in the device info structure is set correctly as "Apple". It verifies proper storage and retrieval of device manufacturer information.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 459@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                              | Test Data                                                         | Expected Result                                                              | Notes       |
 * | :--------------: | ------------------------------------------------------------------------ | ----------------------------------------------------------------- | ---------------------------------------------------------------------------- | ----------- |
 * | 01               | Invoke set_manufacturer with valid non-empty manufacturer string "Apple" and validate the stored manufacturer value | input: manufacturer = Apple, output: m_device_info.manufacturer = Apple | API returns correctly set manufacturer and ASSERT_STREQ verifies equality with "Apple" | Should Pass |
 */
TEST(dm_easy_mesh_t, set_manufacturer_valid_non_empty) {
    std::cout << "Entering set_manufacturer_valid_non_empty test" << std::endl;
    dm_easy_mesh_t obj;
    char manufacturer[] = "Apple";
    std::cout << "Invoking set_manufacturer with input: " << manufacturer << std::endl;
    obj.set_manufacturer(manufacturer);
    std::cout << "Retrieved manufacturer value: " << obj.m_device.m_device_info.manufacturer << std::endl;
    ASSERT_STREQ(obj.m_device.m_device_info.manufacturer, "Apple");
    std::cout << "Exiting set_manufacturer_valid_non_empty test" << std::endl;
}

/**
 * @brief Test the set_manufacturer API with an empty string input
 *
 * This test verifies that when set_manufacturer is called with an empty string,
 * the manufacturer information within the device object remains empty. Ensuring
 * that no unwanted characters or default values are set in such a scenario.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 460@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                           | Test Data                             | Expected Result                                                            | Notes       |
 * | :----:           | ----------------------------------------------------- | ------------------------------------- | -------------------------------------------------------------------------- | ----------- |
 * | 01               | Invoke set_manufacturer with an empty string as input | manufacturer = ""                     | The API should set the manufacturer to an empty string and ASSERT_STREQ passes | Should Pass |
 */
TEST(dm_easy_mesh_t, set_manufacturer_empty_string) {
    std::cout << "Entering set_manufacturer_empty_string test" << std::endl;
    dm_easy_mesh_t obj;
    char manufacturer[] = "";
    std::cout << "Invoking set_manufacturer with input: \"" << manufacturer << "\"" << std::endl;
    obj.set_manufacturer(manufacturer);
    std::cout << "Retrieved manufacturer value: \"" << obj.m_device.m_device_info.manufacturer << "\"" << std::endl;
    ASSERT_STREQ(obj.m_device.m_device_info.manufacturer, "");
    std::cout << "Exiting set_manufacturer_empty_string test" << std::endl;
}

/**
 * @brief Verify that the set_manufacturer API correctly handles special characters in the manufacturer string.
 *
 * This test checks if the dm_easy_mesh_t class's set_manufacturer function correctly accepts and stores a manufacturer name that contains special characters (e.g., '@'). The test validates that after setting the manufacturer name to "Sony@2023", the stored manufacturer value matches the expected value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 461@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                          | Expected Result                                               | Notes             |
 * | :--------------: | --------------------------------------------------------------------------- | ------------------------------------------------------------------ | ------------------------------------------------------------- | ----------------- |
 * | 01               | Print an entering log message before executing the test                     | N/A                                                                | "Entering set_manufacturer_special_characters test" is printed | Should be successful |
 * | 02               | Create a dm_easy_mesh_t object and invoke set_manufacturer with the input     | manufacturer = Sony@2023                                             | The manufacturer field in the device info is set to "Sony@2023"  | Should Pass       |
 * | 03               | Verify the retrieved manufacturer value using ASSERT_STREQ                  | expected manufacturer = Sony@2023, actual manufacturer from obj      | ASSERT_STREQ confirms that the manufacturer string equals "Sony@2023" | Should Pass       |
 * | 04               | Print an exiting log message after executing the test                       | N/A                                                                | "Exiting set_manufacturer_special_characters test" is printed   | Should be successful |
 */
TEST(dm_easy_mesh_t, set_manufacturer_special_characters) {
    std::cout << "Entering set_manufacturer_special_characters test" << std::endl;
    dm_easy_mesh_t obj;
    char manufacturer[] = "Sony@2023";
    std::cout << "Invoking set_manufacturer with input: " << manufacturer << std::endl;
    obj.set_manufacturer(manufacturer);
    std::cout << "Retrieved manufacturer value: " << obj.m_device.m_device_info.manufacturer << std::endl;
    ASSERT_STREQ(obj.m_device.m_device_info.manufacturer, "Sony@2023");
    std::cout << "Exiting set_manufacturer_special_characters test" << std::endl;
}

/**
 * @brief Validate that set_manufacturer throws an exception when invoked with a null pointer.
 *
 * This test verifies that calling the set_manufacturer API with a nullptr correctly triggers an exception.
 * It ensures the robustness of the API by confirming that invalid input is handled properly.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 462@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                        | Test Data                                                 | Expected Result                               | Notes         |
 * | :--------------: | ------------------------------------------------------------------ | --------------------------------------------------------- | --------------------------------------------- | ------------- |
 * | 01               | Invoke set_manufacturer on dm_easy_mesh_t with a null manufacturer   | Input: manufacturer = nullptr; Output: N/A                | API throws an exception as verified by EXPECT_ANY_THROW | Should Pass  |
 */
TEST(dm_easy_mesh_t, set_manufacturer_null_pointer) {
    std::cout << "Entering set_manufacturer_null_pointer test" << std::endl;
    dm_easy_mesh_t obj;    
    char* nullManufacturer = nullptr;
    std::cout << "Invoking set_manufacturer with input: nullptr" << std::endl;
    EXPECT_ANY_THROW(obj.set_manufacturer(nullManufacturer));
    std::cout << "Exiting set_manufacturer_null_pointer test" << std::endl;
}

/**
 * @brief Test that verifies setting a valid manufacturer model string using set_manufacturer_model
 *
 * This test validates whether the dm_easy_mesh_t object correctly stores the provided manufacturer model string. It ensures that after invoking the set_manufacturer_model API with a valid string, the internal device information reflects the same value.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 463@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Log the entry point of the test case |  | "Entering set_manufacturer_model_valid_manufacturer_model_string test" message logged | Should be successful |
 * | 02 | Instantiate dm_easy_mesh_t object and define input manufacturer model string | model = "Model_XYZ" | Object instantiated and model string initialized | Should be successful |
 * | 03 | Invoke set_manufacturer_model API with the valid manufacturer model string | input: model = "Model_XYZ" | The manufacturer model field in the object's device info is set to "Model_XYZ" | Should Pass |
 * | 04 | Validate manufacturer model by checking the set value using EXPECT_STREQ | expected: "Model_XYZ", actual: obj.m_device.m_device_info.manufacturer_model | The test assertion passes confirming the model string is correctly set | Should Pass |
 * | 05 | Log the exit point of the test case |  | "Exiting set_manufacturer_model_valid_manufacturer_model_string test" message logged | Should be successful |
 */
TEST(dm_easy_mesh_t, set_manufacturer_model_valid_manufacturer_model_string)
{
    std::cout << "Entering set_manufacturer_model_valid_manufacturer_model_string test" << std::endl;
    dm_easy_mesh_t obj;
    char model[] = "Model_XYZ";
    std::cout << "Invoking set_manufacturer_model with value: " << model << std::endl;
    obj.set_manufacturer_model(model);
    std::cout << "Retrieved manufacturer model: " << obj.m_device.m_device_info.manufacturer_model << std::endl;
    EXPECT_STREQ(model, obj.m_device.m_device_info.manufacturer_model);
    std::cout << "Exiting set_manufacturer_model_valid_manufacturer_model_string test" << std::endl;
}

/**
 * @brief Test to verify that setting an empty manufacturer model string works correctly.
 *
 * This test verifies that when an empty string is passed to the set_manufacturer_model API, the manufacturer model field of the device is correctly updated to the empty string. The test ensures that the API handles empty string inputs without errors.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 464@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Print initial test start message | None | Message "Entering set_manufacturer_model_empty_manufacturer_model_string test" printed | Should be successful |
 * | 02 | Create object and initialize empty string | dm_easy_mesh_t obj, emptyModel = "" | Object is created and empty string is initialized | Should be successful |
 * | 03 | Invoke set_manufacturer_model API with empty string | input: emptyModel = "" | API call sets manufacturer model to empty string | Should Pass |
 * | 04 | Retrieve and display manufacturer model | Output: manufacturer_model value | manufacturer_model is retrieved and should be an empty string | Should Pass |
 * | 05 | Assert manufacturer model using EXPECT_STREQ | input: emptyModel = "", manufacturer_model value from obj | EXPECT_STREQ verifies both strings are identical (empty) | Should Pass |
 * | 06 | Print test exit message | None | Message "Exiting set_manufacturer_model_empty_manufacturer_model_string test" printed | Should be successful |
 */
TEST(dm_easy_mesh_t, set_manufacturer_model_empty_manufacturer_model_string)
{
    std::cout << "Entering set_manufacturer_model_empty_manufacturer_model_string test" << std::endl;
    dm_easy_mesh_t obj;
    char emptyModel[] = "";
    std::cout << "Invoking set_manufacturer_model with empty string" << std::endl;
    obj.set_manufacturer_model(emptyModel);
    std::cout << "Retrieved manufacturer model: " << obj.m_device.m_device_info.manufacturer_model << std::endl;
    EXPECT_STREQ(emptyModel, obj.m_device.m_device_info.manufacturer_model);    
    std::cout << "Exiting set_manufacturer_model_empty_manufacturer_model_string test" << std::endl;
}

/**
 * @brief Test to verify that set_manufacturer_model throws an exception when a null pointer is provided
 *
 * This test verifies that the set_manufacturer_model function correctly handles invalid input 
 * by throwing an exception when a null pointer is passed. This ensures that the API does not accept 
 * invalid pointers and behaves reliably under erroneous conditions@n
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 465@n
 * **Priority:** High@n
 * @n
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * @n
 * **Test Procedure:**@n
 * | Variation / Step | Description                                        | Test Data                  | Expected Result                                             | Notes       |
 * | :--------------: | -------------------------------------------------- | -------------------------- | ----------------------------------------------------------- | ----------- |
 * | 01               | Invoke set_manufacturer_model with a null pointer  | input1 = nullptr           | API throws an exception as verified by EXPECT_ANY_THROW     | Should Fail |
 */
TEST(dm_easy_mesh_t, set_manufacturer_model_null_pointer)
{
    std::cout << "Entering set_manufacturer_model_null_pointer test" << std::endl;
    dm_easy_mesh_t obj;
    std::cout << "Invoking set_manufacturer_model with null pointer" << std::endl;
    EXPECT_ANY_THROW(obj.set_manufacturer_model(nullptr));
    std::cout << "Exiting set_manufacturer_model_null_pointer test" << std::endl;
}

/**
 * @brief Tests set_msg_id with the minimum value for msg_id.
 *
 * This test verifies that setting msg_id to the minimum possible value (0) works correctly. It validates that the API call instance.set_msg_id correctly assigns the value 0 to instance.msg_id, ensuring basic functionality as per design.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 466@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                   | Test Data                                   | Expected Result                                                  | Notes       |
 * | :--------------: | --------------------------------------------- | ------------------------------------------- | ---------------------------------------------------------------- | ----------- |
 * | 01               | Invoke set_msg_id with the minimum value (0)  | input: test_value = 0, output: msg_id = 0     | instance.msg_id equals 0 and the EXPECT_EQ assertion passes        | Should Pass |
 */
TEST(dm_easy_mesh_t, set_msg_id_min_value) {
    std::cout << "Entering set_msg_id_min_value test" << std::endl;
    dm_easy_mesh_t instance;
    unsigned short test_value = 0;
    std::cout << "Invoking set_msg_id with value: " << test_value << std::endl;
    instance.set_msg_id(test_value);
    std::cout << "Retrieved msg_id value: " << instance.msg_id << std::endl;
    EXPECT_EQ(instance.msg_id, test_value);    
    std::cout << "Exiting set_msg_id_min_value test" << std::endl;
}

/**
 * @brief Verify that the API 'set_msg_id' correctly sets the message ID with a mid-range value.
 *
 * This test verifies that invoking 'set_msg_id' with a mid-range value (12345) successfully updates the internal message ID of the dm_easy_mesh_t instance. It ensures that the value is stored correctly and can be retrieved as expected.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 467@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Log the entry message for the test. | No input parameters. | "Entering set_msg_id_mid_value test" is printed. | Should be successful |
 * | 02 | Create an instance of dm_easy_mesh_t. | Instance created. | Instance is successfully instantiated. | Should be successful |
 * | 03 | Define a mid-range value for the message ID. | test_value = 12345 | test_value is set to 12345. | Should be successful |
 * | 04 | Set the message ID using the set_msg_id API. | input: test_value = 12345, output: instance.msg_id = 12345 | Internal message ID is updated to 12345. | Should Pass |
 * | 05 | Print the retrieved message ID. | output: instance.msg_id = 12345 | Printed message shows msg_id as 12345. | Should be successful |
 * | 06 | Assert that the message ID is equal to the test value. | input: test_value = 12345, output: instance.msg_id = 12345 | EXPECT_EQ assertion passes confirming msg_id is 12345. | Should Pass |
 * | 07 | Log the exit message for the test. | No input parameters. | "Exiting set_msg_id_mid_value test" is printed. | Should be successful |
 */
TEST(dm_easy_mesh_t, set_msg_id_mid_value) {
    std::cout << "Entering set_msg_id_mid_value test" << std::endl;
    dm_easy_mesh_t instance;
    unsigned short test_value = 12345;
    std::cout << "Invoking set_msg_id with value: " << test_value << std::endl;
    instance.set_msg_id(test_value);
    std::cout << "Retrieved msg_id value: " << instance.msg_id << std::endl;
    EXPECT_EQ(instance.msg_id, test_value);    
    std::cout << "Exiting set_msg_id_mid_value test" << std::endl;
}

/**
 * @brief Validate setting maximum message ID value using set_msg_id API
 *
 * This test verifies that the set_msg_id function correctly assigns the maximum allowable unsigned short value (65535) to the msg_id field of the dm_easy_mesh_t instance. This ensures that boundary conditions are properly handled in the API implementation.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 468@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                   | Test Data                                       | Expected Result                                               | Notes       |
 * | :--------------: | --------------------------------------------------------------------------------------------- | ----------------------------------------------- | ------------------------------------------------------------- | ----------- |
 * | 01               | Invoke set_msg_id with the maximum unsigned short value (65535) and verify msg_id assignment. | input: test_value = 65535, output: msg_id = 65535 | instance.msg_id equals 65535 as verified by EXPECT_EQ assertion | Should Pass |
 */
TEST(dm_easy_mesh_t, set_msg_id_max_value) {
    std::cout << "Entering set_msg_id_max_value test" << std::endl;
    dm_easy_mesh_t instance;
    unsigned short test_value = 65535;
    std::cout << "Invoking set_msg_id with value: " << test_value << std::endl;
    instance.set_msg_id(test_value);
    std::cout << "Retrieved msg_id value: " << instance.msg_id << std::endl;
    EXPECT_EQ(instance.msg_id, test_value); 
    std::cout << "Exiting set_msg_id_max_value test" << std::endl;
}

/**
 * @brief Validate that set_primary_device_type correctly sets the primary device type to "Switch"
 *
 * This test verifies that providing a valid device type string ("Switch") to the set_primary_device_type method correctly updates the primary device type within the dm_easy_mesh_t object. It ensures that the API accepts valid input and updates the internal device information accordingly.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 469@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |@n
 * | :----: | --------- | ---------- |-------------- | ----- |@n
 * | 01 | Instantiate dm_easy_mesh_t object and prepare the test data | N/A | dm_easy_mesh_t object is created successfully | Should be successful |@n
 * | 02 | Call set_primary_device_type with the argument "Switch" to update the device type | input: switchType = "Switch", output: primary_device_type = "Switch" | The device's primary_device_type is updated to "Switch" and the EXPECT_STREQ check passes | Should Pass |
 */
TEST(dm_easy_mesh_t, set_primary_device_type_valid_switch) {
    std::cout << "Entering set_primary_device_type_valid_switch test" << std::endl;
    dm_easy_mesh_t mesh;
    char switchType[] = "Switch";
    std::cout << "Invoking set_primary_device_type with value: " << switchType << std::endl;
    mesh.set_primary_device_type(switchType);    
    std::cout << "Retrieved primary device type from m_device: " << mesh.m_device.m_device_info.primary_device_type << std::endl;
    EXPECT_STREQ("Switch", mesh.m_device.m_device_info.primary_device_type);
    std::cout << "Exiting set_primary_device_type_valid_switch test" << std::endl;
}

/**
 * @brief Validate that set_primary_device_type correctly handles NULL input.
 *
 * This test verifies that invoking the set_primary_device_type method with a NULL pointer triggers an exception. Ensuring that the method handles invalid inputs appropriately is vital for the robustness and reliability of the API.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 470@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                              | Test Data                             | Expected Result                                                      | Notes      |
 * | :--------------: | -------------------------------------------------------- | ------------------------------------- | -------------------------------------------------------------------- | ---------- |
 * | 01               | Invoke set_primary_device_type with a NULL pointer input | input: nullType = NULL                | Exception is thrown; EXPECT_ANY_THROW assertion is satisfied         | Should Pass |
 */
TEST(dm_easy_mesh_t, set_primary_device_type_null_input) {
    std::cout << "Entering set_primary_device_type_null_input test" << std::endl;
    dm_easy_mesh_t mesh;
    char* nullType = NULL;
    std::cout << "Invoking set_primary_device_type with value: " << "NULL" << std::endl;
    EXPECT_ANY_THROW(mesh.set_primary_device_type(nullType));
    //EXPECT_NE(nullptr, retrievedType);
    std::cout << "Exiting set_primary_device_type_null_input test" << std::endl;
}

/**
 * @brief Verify that setting an empty string as the primary device type correctly leaves the device type empty.
 *
 * This test verifies that invoking set_primary_device_type with an empty string does not alter the primary device type beyond setting it empty. The method should handle an empty string without errors and the resultant primary device type must be equal to an empty string.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 471@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                              | Test Data                                                     | Expected Result                                                                              | Notes      |
 * | :--------------: | -------------------------------------------------------- | ------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | ---------- |
 * | 01               | Invoke set_primary_device_type with an empty string input| input: emptyType = "", output: primary_device_type = ""         | The primary device type should be an empty string as verified by EXPECT_STREQ                    | Should Pass |
 */
TEST(dm_easy_mesh_t, set_primary_device_type_empty_string) {
    std::cout << "Entering set_primary_device_type_empty_string test" << std::endl;
    dm_easy_mesh_t mesh;
    char emptyType[] = "";
    std::cout << "Invoking set_primary_device_type with empty string" << std::endl;
    mesh.set_primary_device_type(emptyType);
    std::cout << "Primary device type after invoking with empty string: " << mesh.m_device.m_device_info.primary_device_type << std::endl;
    EXPECT_STREQ("", mesh.m_device.m_device_info.primary_device_type);    
    std::cout << "Exiting set_primary_device_type_empty_string test" << std::endl;
}

/**
 * @brief Verify that set_primary_device_type correctly truncates a very long input string to the maximum allowed length.
 *
 * This test provides a valid but very long string (1024 characters) to the set_primary_device_type method and checks that the stored string 
 * is truncated to the maximum allowed length (15 characters). This ensures that the API handles oversized inputs safely by limiting the stored data.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 472@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create an instance of dm_easy_mesh_t and prepare a very long string (1024 'A's) then invoke set_primary_device_type() | input: longStrLength = 1024, input: longType = "A, A, A, ... (1024 times)" | API should accept the input and store only the first 15 characters | Should Pass |
 * | 02 | Retrieve the stored primary device type from the instance and verify its length and content | output: stored = primary_device_type, expectedLength = 15, expectedContent = first 15 characters of longType | strlen(stored) equals 15 and strncmp(stored, longType, 15) returns 0 | Should Pass |
 */
TEST(dm_easy_mesh_t, set_primary_device_type_very_long_valid) {
    std::cout << "Entering set_primary_device_type_very_long_valid test" << std::endl;
    dm_easy_mesh_t mesh;
    const size_t longStrLength = 1024;
    char *longType = new char[longStrLength + 1];
    memset(longType, 'A', longStrLength);
    longType[longStrLength] = '\0';    
    std::cout << "Invoking set_primary_device_type with a very long string of length " << longStrLength << std::endl;
    mesh.set_primary_device_type(longType);    
    std::cout << "Retrieved primary device type from m_device with length: " << mesh.m_device.m_device_info.primary_device_type << std::endl;    
    const char* stored = mesh.m_device.m_device_info.primary_device_type;
    constexpr size_t maxLen = sizeof(em_small_string_t) - 1; // 15
    EXPECT_EQ(strlen(stored), maxLen);
    EXPECT_EQ(strncmp(stored, longType, maxLen), 0);
    delete[] longType;    
    std::cout << "Exiting set_primary_device_type_very_long_valid test" << std::endl;
}

/**
 * @brief Validate that set_serial_number correctly stores a valid serial number within allowed length
 *
 * This test verifies that when a valid serial number (within the allowed length) is provided to the set_serial_number API,
 * the device's internal serial number is correctly updated. The test checks that the stored serial number exactly matches the provided input.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 473@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                      | Test Data                                                      | Expected Result                                                              | Notes        |
 * | :--------------: | ---------------------------------------------------------------- | -------------------------------------------------------------- | ---------------------------------------------------------------------------- | ------------ |
 * | 01               | Initialize the device instance                                   | None                                                           | Device instance created successfully                                         | Should be successful |
 * | 02               | Prepare a valid serial number "SN123456"                         | validSerial = SN123456                                           | validSerial is set correctly                                                 | Should be successful |
 * | 03               | Invoke set_serial_number API with the valid serial               | input = validSerial = SN123456                                   | API call succeeds and updates internal serial number                         | Should Pass  |
 * | 04               | Verify the stored serial number matches "SN123456"               | device.m_device.m_device_info.serial_number, validSerial = SN123456 | EXPECT_STREQ assertion passes confirming stored serial equals validSerial      | Should Pass  |
 */
TEST(dm_easy_mesh_t, set_serial_number_valid_serial_number_within_allowed_length) {
    std::cout << "Entering set_serial_number_valid_serial_number_within_allowed_length test" << std::endl;
    dm_easy_mesh_t device;
    char validSerial[] = "SN123456";
    std::cout << "Invoking set_serial_number with serial: " << validSerial << std::endl;
    device.set_serial_number(validSerial);
    std::cout << "Retrieved serial number: " << device.m_device.m_device_info.serial_number << std::endl;
    EXPECT_STREQ(device.m_device.m_device_info.serial_number, validSerial);
    std::cout << "Exiting set_serial_number_valid_serial_number_within_allowed_length test" << std::endl;
}

/**
 * @brief Test dm_easy_mesh_t::set_serial_number API with a null pointer for the serial number.
 *
 * This test verifies that invoking set_serial_number with a null pointer properly triggers an exception,
 * ensuring that the API handles invalid inputs robustly.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 474@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                           | Test Data                              | Expected Result                             | Notes           |
 * | :--------------: | --------------------------------------------------------------------- | -------------------------------------- | ------------------------------------------- | --------------- |
 * | 01               | Log the entry message for the test                                    | N/A                                    | Entry message printed to console            | Should be successful |
 * | 02               | Instantiate a dm_easy_mesh_t object                                   | N/A                                    | Object is successfully created              | Should be successful |
 * | 03               | Log the message indicating the invocation of set_serial_number with NULL| N/A                                    | Invocation message printed to console       | Should be successful |
 * | 04               | Call set_serial_number with a NULL pointer                            | input: serial = NULL                   | Exception is thrown by the API              | Should Fail     |
 * | 05               | Log the exit message for the test                                     | N/A                                    | Exit message printed to console             | Should be successful |
 */
TEST(dm_easy_mesh_t, set_serial_number_null_pointer_serial_number) {
    std::cout << "Entering set_serial_number_null_pointer_serial_number test" << std::endl;
    dm_easy_mesh_t device;
    std::cout << "Invoking set_serial_number with serial: NULL" << std::endl;
    EXPECT_ANY_THROW(device.set_serial_number(NULL));
    std::cout << "Exiting set_serial_number_null_pointer_serial_number test" << std::endl;
}

/**
 * @brief Test set_serial_number with an empty serial string
 *
 * This test verifies that invoking the set_serial_number API on a device object with an empty serial number correctly assigns an empty string to the internal serial number field. The test checks whether the API properly handles the empty string input without error, and the assertion validates that the stored value remains empty.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 475@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                     | Test Data                                                     | Expected Result                                                                                          | Notes         |
 * | :--------------: | --------------------------------------------------------------- | ------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize the device object and empty serial number string     | N/A                                                           | Device object is properly instantiated and ready for the test                                            | Should be successful |
 * | 02               | Invoke set_serial_number with an empty string and verify the value| input: emptySerial = "", output: device.m_device.m_device_info.serial_number = "" | The method sets the internal serial number to an empty string and EXPECT_STREQ confirms the match         | Should Pass   |
 */
TEST(dm_easy_mesh_t, set_serial_number_empty_serial_number_string) {
    std::cout << "Entering set_serial_number_empty_serial_number_string test" << std::endl;
    dm_easy_mesh_t device;
    char emptySerial[] = "";
    std::cout << "Invoking set_serial_number with serial: " << "\"" << emptySerial << "\"" << std::endl;
    device.set_serial_number(emptySerial);
    std::cout << "Retrieved serial number: " << device.m_device.m_device_info.serial_number << std::endl;
    EXPECT_STREQ(device.m_device.m_device_info.serial_number, emptySerial);
    std::cout << "Exiting set_serial_number_empty_serial_number_string test" << std::endl;
}

/**
 * @brief Verify that set_software_version successfully sets a non-empty valid version string.
 *
 * This test verifies that the set_software_version method of dm_easy_mesh_t correctly updates the device's software version when provided with a valid, non-empty version string ("v1.0.0"). It ensures that the internal state of the device reflects the new software version as expected.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 476@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                               | Test Data                                                                 | Expected Result                                                       | Notes       |
 * | :--------------: | ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- | --------------------------------------------------------------------- | ----------- |
 * | 01               | Invoke set_software_version with a valid non-empty version "v1.0.0" and verify the update.  | input: version = "v1.0.0", output: device.m_device.m_device_info.software_ver expected = "v1.0.0" | The device software version is updated to "v1.0.0" and the assertion passes. | Should Pass |
 */
TEST(dm_easy_mesh_t, set_software_version_valid_non_empty)
{
    std::cout << "Entering set_software_version_valid_non_empty test" << std::endl;
    dm_easy_mesh_t deviceObj;
    char version[] = "v1.0.0";
    std::cout << "Invoking set_software_version with value: " << version << std::endl;
    deviceObj.set_software_version(version);
    std::cout << "Retrieved device software version: " << deviceObj.m_device.m_device_info.software_ver << std::endl;
    EXPECT_EQ(deviceObj.m_device.m_device_info.software_ver, std::string("v1.0.0"));
    std::cout << "Exiting set_software_version_valid_non_empty test" << std::endl;
}

/**
 * @brief Test verifies that the set_software_version API correctly handles an empty string input.
 *
 * This test case ensures that when an empty string is passed to the set_software_version API, the internal software version remains empty. It is important to verify that the function properly accepts boundary input data without introducing errors.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 477@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke set_software_version API with an empty string to set the software version. | input: emptyVersion = "", output: software_ver expected = "" | API sets the software version to an empty string, verified by EXPECT_EQ. | Should Pass |
 */
TEST(dm_easy_mesh_t, set_software_version_empty_string)
{
    std::cout << "Entering set_software_version_empty_string test" << std::endl;
    dm_easy_mesh_t deviceObj;
    char emptyVersion[] = "";
    std::cout << "Invoking set_software_version with value: (empty string)" << std::endl;
    deviceObj.set_software_version(emptyVersion);
    std::cout << "Retrieved device software version: '" << deviceObj.m_device.m_device_info.software_ver << "'" << std::endl;
    EXPECT_EQ(deviceObj.m_device.m_device_info.software_ver, std::string(""));
    std::cout << "Exiting set_software_version_empty_string test" << std::endl;
}

/**
 * @brief Test that set_software_version API throws an exception when provided with a null pointer
 *
 * This test verifies the behavior of the set_software_version method in the dm_easy_mesh_t class when a null pointer is passed as an argument. The objective is to ensure that the API correctly handles invalid input by throwing an exception.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 478@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                            | Test Data                                     | Expected Result                                     | Notes       |
 * | :--------------: | ---------------------------------------------------------------------- | --------------------------------------------- | --------------------------------------------------- | ----------- |
 * | 01               | Create a dm_easy_mesh_t object and invoke set_software_version with nullptr | input = nullptr, output = exception           | API is expected to throw an exception indicating error | Should Pass |
 */
TEST(dm_easy_mesh_t, set_software_version_null_pointer)
{
    std::cout << "Entering set_software_version_null_pointer test" << std::endl;
    dm_easy_mesh_t deviceObj;
    std::cout << "Invoking set_software_version with value: NULL" << std::endl;
    EXPECT_ANY_THROW(deviceObj.set_software_version(nullptr));
    std::cout << "Exiting set_software_version_null_pointer test" << std::endl;
}

/**
 * @brief Validate that dm_easy_mesh_t::set_network accepts a valid network configuration
 *
 * This test verifies that when provided with a valid dm_network_t configuration (including correct id, controller interface details, and colocated agent interface details), the set_network method successfully sets the internal m_network member of the dm_easy_mesh_t object. It checks for proper copying of string and MAC address values using EXPECT_STREQ and EXPECT_EQ assertions.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 479@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                                             | Test Data                                                                                                                                                                                                                                                     | Expected Result                                                                                                             | Notes           |
 * | :--------------: | ----------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- | --------------- |
 * | 01               | Initialize valid dm_network_t structure with id, controller interface details, and colocated agent interface details  | input: validNetwork.m_net_info.id = "Valid_Network", validNetwork.m_net_info.ctrl_id.name = "ctrl_iface", validNetwork.m_net_info.ctrl_id.mac = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55}, validNetwork.m_net_info.colocated_agent_id.name = "colocated_iface", validNetwork.m_net_info.colocated_agent_id.mac = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF} | dm_network_t object is properly setup with valid values                                                          | Should be successful |
 * | 02               | Invoke the set_network method on dm_easy_mesh_t object with the valid network configuration                                | input: dm_easy_mesh_t object, validNetwork                                                                                                                    | set_network method is called and internal m_network is updated with the valid configuration                                  | Should Pass     |
 * | 03               | Validate internal dm_network_t configuration of dm_easy_mesh_t object matches the provided valid network configuration     | expected: m_network.m_net_info.id = "Valid_Network", m_network.m_net_info.ctrl_id.name = "ctrl_iface", m_network.m_net_info.ctrl_id.mac same as validNetwork, m_network.m_net_info.colocated_agent_id.name = "colocated_iface", m_network.m_net_info.colocated_agent_id.mac same as validNetwork | All EXPECT_STREQ and EXPECT_EQ assertions pass verifying that the network configuration is correctly updated                   | Should Pass     |
 */
TEST(dm_easy_mesh_t, set_network_valid_network_configuration_input)
{
    std::cout << "Entering set_network_valid_network_configuration_input test" << std::endl;
    dm_network_t validNetwork;
    const char* validId = "Valid_Network";
    strcpy(validNetwork.m_net_info.id, validId);
    // Set valid controller interface details
    const char* ctrlName = "ctrl_iface";
    strcpy(validNetwork.m_net_info.ctrl_id.name, ctrlName);
    unsigned char ctrlMac[6] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
    memcpy(validNetwork.m_net_info.ctrl_id.mac, ctrlMac, sizeof(ctrlMac));
    // Set valid colocated agent interface details
    const char* colocatedName = "colocated_iface";
    strcpy(validNetwork.m_net_info.colocated_agent_id.name, colocatedName);
    unsigned char colocatedMac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    memcpy(validNetwork.m_net_info.colocated_agent_id.mac, colocatedMac, sizeof(colocatedMac));
    // Create dm_easy_mesh_t object using default constructor and invoke set_network
    dm_easy_mesh_t easyMesh;
    std::cout << "Invoking set_network method with valid dm_network_t values" << std::endl;
    easyMesh.set_network(validNetwork);
    // Validate that the internal m_network matches the provided network configuration
    EXPECT_STREQ(easyMesh.m_network.m_net_info.id, validId);
    EXPECT_STREQ(easyMesh.m_network.m_net_info.ctrl_id.name, ctrlName);
    EXPECT_EQ(memcmp(easyMesh.m_network.m_net_info.ctrl_id.mac, validNetwork.m_net_info.ctrl_id.mac, sizeof(validNetwork.m_net_info.ctrl_id.mac)), 0);
    EXPECT_STREQ(easyMesh.m_network.m_net_info.colocated_agent_id.name, validNetwork.m_net_info.colocated_agent_id.name);
    EXPECT_EQ(memcmp(easyMesh.m_network.m_net_info.colocated_agent_id.mac, validNetwork.m_net_info.colocated_agent_id.mac, sizeof(validNetwork.m_net_info.colocated_agent_id.mac)), 0);
    std::cout << "Exiting set_network_valid_network_configuration_input test" << std::endl;
}

/**
 * @brief Verify that set_network correctly handles malformed network information.
 *
 * This test ensures that when set_network is invoked with a dm_network_t containing invalid
 * or empty values (such as empty strings for IDs and zeroed MAC addresses), the internal network
 * configuration of the dm_easy_mesh_t object reflects these malformed inputs exactly.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 480@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create a dm_network_t object with malformed network details (empty id, empty controller name, and zero MAC addresses for both controller and agent) | Input: malformedNetwork: id = "", ctrl_id.name = "", ctrl_id.mac = [0,0,0,0,0,0], colocated_agent_id.name = "", colocated_agent_id.mac = [0,0,0,0,0,0] | A properly initialized dm_network_t object with the specified malformed values is created. | Should be successful |
 * | 02 | Invoke the set_network method with the malformed network information | Input: easyMesh.set_network(malformedNetwork) | The dm_easy_mesh_t object's internal network configuration matches the malformedNetwork values exactly. | Should Pass |
 * | 03 | Verify through assertions that the network configuration within dm_easy_mesh_t reflects the malformed inputs | Expected: id = "", ctrl_id.name = "", ctrl_id.mac = [0,0,0,0,0,0], colocated_agent_id.name = "", colocated_agent_id.mac = [0,0,0,0,0,0] | All EXPECT assertions pass confirming the network configuration is set as expected. | Should be successful |
 */
TEST(dm_easy_mesh_t, set_network_invalid_malformed_network_information_input)
{
    std::cout << "Entering set_network_invalid_malformed_network_information_input test" << std::endl;
    // Create a dm_network_t object with invalid/malformed network details.
    dm_network_t malformedNetwork;
    strcpy(malformedNetwork.m_net_info.id, "");    
    // Set controller interface with empty name and zero MAC
    strcpy(malformedNetwork.m_net_info.ctrl_id.name, "");
    unsigned char zeroMac[6] = {0, 0, 0, 0, 0, 0};
    memcpy(malformedNetwork.m_net_info.ctrl_id.mac, zeroMac, sizeof(zeroMac));
    // Set colocated agent interface with empty name and zero MAC
    strcpy(malformedNetwork.m_net_info.colocated_agent_id.name, "");
    memcpy(malformedNetwork.m_net_info.colocated_agent_id.mac, zeroMac, sizeof(zeroMac));
    // Create dm_easy_mesh_t object and invoke set_network
    dm_easy_mesh_t easyMesh;
    std::cout << "Invoking set_network method with malformed network information" << std::endl;
    easyMesh.set_network(malformedNetwork);
    // Verify that the easyMesh object's network configuration matches the malformed input exactly.
    EXPECT_STREQ(easyMesh.m_network.m_net_info.id, "");
    EXPECT_STREQ(easyMesh.m_network.m_net_info.ctrl_id.name, "");
    EXPECT_EQ(memcmp(easyMesh.m_network.m_net_info.ctrl_id.mac, zeroMac, sizeof(zeroMac)), 0);
    EXPECT_STREQ(easyMesh.m_network.m_net_info.colocated_agent_id.name, "");
    EXPECT_EQ(memcmp(easyMesh.m_network.m_net_info.colocated_agent_id.mac, zeroMac, sizeof(zeroMac)), 0);    
    std::cout << "Exiting set_network_invalid_malformed_network_information_input test" << std::endl;
}

/**
 * @brief Verify that set_num_network_ssid correctly sets the number of network SSIDs in a typical valid positive scenario
 *
 * This test verifies that the set_num_network_ssid method properly assigns the provided value to the member variable m_num_net_ssids. It creates an instance of dm_easy_mesh_t, assigns a valid positive input, invokes the method, and then confirms that m_num_net_ssids matches the input.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 481@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * |01| Create an instance of dm_easy_mesh_t and initialize input variable | input = 5, output: n/a | Instance created and input variable set to 5 | Should be successful |
 * |02| Call set_num_network_ssid method with input value | input = 5, output: m_num_net_ssids should become 5 | Member variable m_num_net_ssids is updated to 5 | Should Pass |
 * |03| Validate that m_num_net_ssids equals the input value | input = 5, output: EXPECT_EQ(obj.m_num_net_ssids, 5) | The assertion passes and m_num_net_ssids equals 5 | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_network_ssid_typical_valid_positive)
{
    std::cout << "Entering set_num_network_ssid_typical_valid_positive test" << std::endl;
    dm_easy_mesh_t obj;
    unsigned int input = 5;
    std::cout << "Invoking set_num_network_ssid with num = " << input << std::endl;
    obj.set_num_network_ssid(input);
    std::cout << "Method set_num_network_ssid invoked. Expected m_num_net_ssids = " << input 
              << ", Actual m_num_net_ssids = " << obj.m_num_net_ssids << std::endl;
    EXPECT_EQ(obj.m_num_net_ssids, input);
    std::cout << "Exiting set_num_network_ssid_typical_valid_positive test" << std::endl;
}

/**
 * @brief Test to verify that the set_num_network_ssid method handles the minimum boundary input.
 *
 * This test case verifies that the function set_num_network_ssid of dm_easy_mesh_t properly sets the m_num_net_ssids member variable when provided with the minimum boundary input value, which is 0. This is necessary to ensure the method behaves correctly for edge cases.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 482@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize the dm_easy_mesh_t object and prepare the minimum boundary input value for num_network_ssid | input = 0 | Object initialized with input value ready for API invocation | Should be successful |
 * | 02 | Call set_num_network_ssid with 0 and update the object's m_num_net_ssids | input = 0, output is m_num_net_ssids member of the object | m_num_net_ssids should be set to 0 | Should Pass |
 * | 03 | Verify that the m_num_net_ssids member variable equals the input value by using EXPECT_EQ | input = 0, output: EXPECT_EQ(obj.m_num_net_ssids, 0) | EXPECT_EQ should confirm that m_num_net_ssids equals 0 | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_network_ssid_min_boundary)
{
    std::cout << "Entering set_num_network_ssid_min_boundary test" << std::endl;
    dm_easy_mesh_t obj;
    unsigned int input = 0;
    std::cout << "Invoking set_num_network_ssid with num = " << input << std::endl;
    obj.set_num_network_ssid(input);
    std::cout << "Method set_num_network_ssid invoked. Expected m_num_net_ssids = " << input
              << ", Actual m_num_net_ssids = " << obj.m_num_net_ssids << std::endl;
    EXPECT_EQ(obj.m_num_net_ssids, input);
    std::cout << "Exiting set_num_network_ssid_min_boundary test" << std::endl;
}

/**
 * @brief Test the set_num_network_ssid() API with the maximum unsigned integer boundary value.
 *
 * This test verifies that the set_num_network_ssid() method correctly assigns the maximum 
 * unsigned integer value to the m_num_net_ssids member of the dm_easy_mesh_t object. It ensures
 * that the API can handle the upper boundary condition without errors.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 483@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                      | Test Data                                                     | Expected Result                                                                                                  | Notes       |
 * | :--------------: | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- | ----------- |
 * | 01               | Invoke set_num_network_ssid on a dm_easy_mesh_t object with input set to the maximum unsigned int | input = 4294967295, m_num_net_ssids = Expected to be set to 4294967295 | The member m_num_net_ssids should be equal to the input value after the API call | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_network_ssid_max_boundary)
{
    std::cout << "Entering set_num_network_ssid_max_boundary test" << std::endl;
    dm_easy_mesh_t obj;    
    unsigned int input = std::numeric_limits<unsigned int>::max();  // 4294967295 on typical systems
    std::cout << "Invoking set_num_network_ssid with num = " << input << std::endl;
    obj.set_num_network_ssid(input);    
    std::cout << "Method set_num_network_ssid invoked. Expected m_num_net_ssids = " << input
              << ", Actual m_num_net_ssids = " << obj.m_num_net_ssids << std::endl;
    EXPECT_EQ(obj.m_num_net_ssids, input);    
    std::cout << "Exiting set_num_network_ssid_max_boundary test" << std::endl;
}

/**
 * @brief Verify that set_num_policy correctly assigns a zero value to m_num_policy.
 *
 * This test checks if the set_num_policy method correctly updates the internal state (m_num_policy) of a dm_easy_mesh_t object when provided with a zero value. The objective is to ensure that the method handles a boundary input of zero appropriately.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 484@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                          | Test Data                                  | Expected Result                                               | Notes       |
 * | :--------------: | ---------------------------------------------------------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------------- | ----------- |
 * | 01               | Initialize dm_easy_mesh_t object, set policy_val to 0, invoke set_num_policy, then validate m_num_policy. | policy_val = 0, m_num_policy expected = 0  | m_num_policy equals 0 and assertion EXPECT_EQ passes.         | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_policy_set_policy_with_zero_value)
{
    std::cout << "Entering set_num_policy_set_policy_with_zero_value test" << std::endl;
    dm_easy_mesh_t mesh_obj;
    unsigned int policy_val = 0;
    std::cout << "Invoking set_num_policy with value: " << policy_val << std::endl;
    mesh_obj.set_num_policy(policy_val);
    std::cout << "m_num_policy after invocation: " << mesh_obj.m_num_policy << std::endl;    
    EXPECT_EQ(mesh_obj.m_num_policy, policy_val);    
    std::cout << "Exiting set_num_policy_set_policy_with_zero_value test" << std::endl;
}

/**
 * @brief Verifies that set_num_policy correctly updates the m_num_policy attribute with a positive value.
 *
 * This test is designed to ensure that when a positive policy value is provided to the set_num_policy method, the internal m_num_policy attribute of the dm_easy_mesh_t object is updated accordingly. This helps verify the proper functioning of the policy setting mechanism.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 485@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                                              | Test Data                           | Expected Result                                                   | Notes      |
 * | :----:           | -----------                                                                                                              | ----------                          | --------------                                                  | -----      |
 * | 01               | Create a dm_easy_mesh_t object, invoke set_num_policy with a positive value (100), and verify m_num_policy is updated.   | policy_val = 100, m_num_policy = 100| m_num_policy is equal to 100; EXPECT_EQ assertion passes          | Should Pass|
 */
TEST(dm_easy_mesh_t, set_num_policy_set_policy_with_positive_value)
{
    std::cout << "Entering set_num_policy_set_policy_with_positive_value test" << std::endl;
    dm_easy_mesh_t mesh_obj;    
    unsigned int policy_val = 100;
    std::cout << "Invoking set_num_policy with value: " << policy_val << std::endl;
    mesh_obj.set_num_policy(policy_val);    
    std::cout << "m_num_policy after invocation: " << mesh_obj.m_num_policy << std::endl;    
    EXPECT_EQ(mesh_obj.m_num_policy, policy_val);    
    std::cout << "Exiting set_num_policy_set_policy_with_positive_value test" << std::endl;
}

/**
 * @brief Verify that dm_easy_mesh_t::set_num_policy correctly sets m_num_policy to the maximum unsigned int value.
 *
 * This test case verifies that when the API set_num_policy is invoked with the maximum unsigned int value, it correctly updates the object's m_num_policy field.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 486@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Log entry message for test start | None | Message indicating the start of the test is printed | Should be successful |
 * | 02 | Create an instance of dm_easy_mesh_t | None | Instance of dm_easy_mesh_t is created | Should be successful |
 * | 03 | Set policy value to maximum unsigned int and invoke set_num_policy | policy_val = std::numeric_limits<unsigned int>::max() | m_num_policy is updated to policy_val | Should Pass |
 * | 04 | Verify m_num_policy matches the policy_val | input: mesh_obj.m_num_policy, expected: policy_val | m_num_policy equals policy_val (assertion passes) | Should Pass |
 * | 05 | Log exit message for test finish | None | Message indicating the test exit is printed | Should be successful |
 */
TEST(dm_easy_mesh_t, set_num_policy_set_policy_with_max_value)
{
    std::cout << "Entering set_num_policy_set_policy_with_max_value test" << std::endl;
    dm_easy_mesh_t mesh_obj;    
    unsigned int policy_val = std::numeric_limits<unsigned int>::max();
    std::cout << "Invoking set_num_policy with value: " << policy_val << std::endl;
    mesh_obj.set_num_policy(policy_val);   
    std::cout << "m_num_policy after invocation: " << mesh_obj.m_num_policy << std::endl;    
    EXPECT_EQ(mesh_obj.m_num_policy, policy_val);    
    std::cout << "Exiting set_num_policy_set_policy_with_max_value test" << std::endl;
}

/**
 * @brief Test for adding a new policy to the mesh object using set_policy.
 *
 * This test validates that a new policy is correctly added to the dm_easy_mesh_t object when set_policy is invoked.
 * It checks that the policy count increments and the policy attributes match the expected values.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 487@n
 * **Priority:** High
 * 
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object and device MAC address. | device_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF} | Mesh object is successfully initialized and device MAC is set. | Should be successful |
 * | 02 | Setup dm_policy_t policy with defined network ID and radio MAC address. | policy.m_policy.id.net_id = "net1", policy.m_policy.id.type = em_policy_id_type_steering_local, radio_mac = {1,2,3,4,5,6}, dev_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF} | Policy structure is correctly populated. | Should be successful |
 * | 03 | Call set_policy to add the new policy to the mesh. | policy object | Mesh.m_num_policy becomes 1 after API call. | Should Pass |
 * | 04 | Verify policy count and policy attributes using assertions. | mesh.m_num_policy, mesh.m_policy[0].m_policy.id.net_id = "net1" | EXPECT_EQ verifies m_num_policy equals 1 and EXPECT_STREQ verifies net_id equals "net1". | Should Pass |
 */
TEST(dm_easy_mesh_t, set_policy_AddNewPolicy)
{
    std::cout << "Entering set_policy_AddNewPolicy test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    unsigned char device_mac[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    memcpy(mesh.m_device.m_device_info.intf.mac, device_mac, 6);
    dm_policy_t policy{};
    strncpy(policy.m_policy.id.net_id, "net1", sizeof(policy.m_policy.id.net_id) - 1);
    policy.m_policy.id.type = em_policy_id_type_steering_local;
    unsigned char radio_mac[6] = {1,2,3,4,5,6};
    memcpy(policy.m_policy.id.radio_mac, radio_mac, 6);
    memcpy(policy.m_policy.id.dev_mac, device_mac, 6);
    std::cout << "Invoking set_policy with em_policy_id_type_steering_local policy type" << std::endl;
    mesh.set_policy(policy);
    EXPECT_EQ(mesh.m_num_policy, 1u);
    mesh.deinit();
    EXPECT_STREQ(mesh.m_policy[0].m_policy.id.net_id, "net1");
    std::cout << "Exiting set_policy_AddNewPolicy test" << std::endl;
}

/**
 * @brief Test for validating the set_policy API when replacing an existing policy.
 *
 * This test validates that when an existing policy is set and then replaced with new parameters,
 * the mesh correctly updates the policy rather than duplicating it. The test checks that only one
 * policy exists after replacement and that the new parameter (interval) is correctly applied.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 488@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                | Test Data                                                                                                                                                           | Expected Result                                                  | Notes         |
 * | :--------------: | ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------- | ------------- |
 * | 01               | Initialize mesh and assign device MAC address.                                             | Call: mesh.init(), device_mac = 0x10,0x20,0x30,0x40,0x50,0x60                                                                                                       | Mesh is initialized with the given device MAC assigned.        | Should be successful |
 * | 02               | Set initial policy p1 with net_id "netA", radio MAC, and device MAC.                         | p1: net_id = "netA", type = em_policy_id_type_channel_scan, radio_mac = 0x11,0x22,0x33,0x44,0x55,0x66, dev_mac = device_mac, interval = 0                           | Policy p1 is set and policy count becomes 1.                     | Should Pass   |
 * | 03               | Replace existing policy with new policy p2 having modified interval 123.                     | p2: copied from p1 with modification: interval = 123                                                                                                                | Existing policy is replaced with p2, updating the interval to 123. | Should Pass   |
 * | 04               | Validate the policy count and verify the updated interval in the mesh policy array.            | Assert: mesh.m_num_policy == 1, mesh.m_policy[0].m_policy.interval == 123                                                                                             | Both assertions pass confirming only one policy with interval 123. | Should Pass   |
 */
TEST(dm_easy_mesh_t, set_policy_ReplaceExistingPolicy)
{
    std::cout << "Entering set_policy_ReplaceExistingPolicy test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    unsigned char device_mac[6] = {0x10,0x20,0x30,0x40,0x50,0x60};
    memcpy(mesh.m_device.m_device_info.intf.mac, device_mac, 6);
    unsigned char radio_mac[6] = {0x11,0x22,0x33,0x44,0x55,0x66};
    dm_policy_t p1{};
    strncpy(p1.m_policy.id.net_id, "netA", sizeof(p1.m_policy.id.net_id) - 1);
    p1.m_policy.id.type = em_policy_id_type_channel_scan;
    memcpy(p1.m_policy.id.radio_mac, radio_mac, 6);
    memcpy(p1.m_policy.id.dev_mac, device_mac, 6);
    std::cout << "Invoking set_policy with em_policy_id_type_channel_scan policy type" << std::endl;
    mesh.set_policy(p1);
    dm_policy_t p2 = p1;
    p2.m_policy.interval = 123;
    std::cout << "Invoking set_policy with interval as 123" << std::endl;
    mesh.set_policy(p2);
    EXPECT_EQ(mesh.m_num_policy, 1u);
    mesh.deinit();
    EXPECT_EQ(mesh.m_policy[0].m_policy.interval, 123);
    std::cout << "Exiting set_policy_ReplaceExistingPolicy test" << std::endl;
}

/**
 * @brief Test that adding policies with different net IDs correctly adds a new policy
 *
 * This test verifies that when two policies with different network IDs are added to the mesh,
 * both policies are stored correctly and the total policy count is incremented to 2. The test
 * ensures that the set_policy API correctly distinguishes policies based on their unique net_id.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 489@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize mesh object and call its init() method | mesh = dm_easy_mesh_t, method: mesh.init() | Mesh object is successfully initialized | Should be successful |
 * | 02 | Set device MAC address for the mesh device info | device_mac = {1,1,1,1,1,1}, call: memcpy(mesh.m_device.m_device_info.intf.mac, device_mac, 6) | Mesh's device MAC is correctly set | Should be successful |
 * | 03 | Create policy p1 with net_id "net1" and initialize attributes | p1.m_policy.id.net_id = "net1", p1.m_policy.id.type = em_policy_id_type_qos_mgt, p1.m_policy.id.dev_mac = {1,1,1,1,1,1} | Policy p1 is correctly populated with net_id "net1" | Should be successful |
 * | 04 | Create policy p2 as a copy of p1 and update its net_id to "net2" | p2 copied from p1, p2.m_policy.id.net_id = "net2" | Policy p2 contains net_id "net2", distinct from p1 | Should be successful |
 * | 05 | Invoke set_policy API with both policies and verify policy count | Call: mesh.set_policy(p1) then mesh.set_policy(p2), Expectation: mesh.m_num_policy = 2 | mesh.m_num_policy equals 2, indicating both policies were added | Should Pass |
 */
TEST(dm_easy_mesh_t, set_policy_DifferentNetIdAddsNewPolicy)
{
    std::cout << "Entering set_policy_DifferentNetIdAddsNewPolicy test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    unsigned char device_mac[6] = {1,1,1,1,1,1};
    memcpy(mesh.m_device.m_device_info.intf.mac, device_mac, 6);
    dm_policy_t p1{};
    strncpy(p1.m_policy.id.net_id, "net1", sizeof(p1.m_policy.id.net_id) - 1);
    p1.m_policy.id.type = em_policy_id_type_qos_mgt;
    memcpy(p1.m_policy.id.dev_mac, device_mac, 6);
    dm_policy_t p2 = p1;
    strncpy(p2.m_policy.id.net_id, "net2", sizeof(p2.m_policy.id.net_id) - 1);
    std::cout << "Invoking set_policy with net_id net1" << std::endl;
    mesh.set_policy(p1);
    std::cout << "Invoking set_policy with net_id net2" << std::endl;
    mesh.set_policy(p2);
    mesh.deinit();
    EXPECT_EQ(mesh.m_num_policy, 2u);
    std::cout << "Exiting set_policy_DifferentNetIdAddsNewPolicy test" << std::endl;
}

/**
 * @brief Verify that the set_policy() method correctly adds a new policy when two policies with identical IDs but different types are provided
 *
 * This test validates that when two policies are created with the same network ID and device MAC address but with different policy types, the mesh instance correctly recognizes them as distinct policies and increments the policy count appropriately. The test ensures that the API does not override the existing policy if the policy type differs.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 490@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                              | Test Data                                                                                                                          | Expected Result                                                    | Notes         |
 * | :--------------: | ---------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ | ------------- |
 * | 01               | Initialize the dm_easy_mesh_t instance and set the device MAC address                      | mesh.init(), device_mac = 0xFF,0xEE,0xDD,0xCC,0xBB,0xAA                                                                            | Mesh initialization and MAC assignment complete                    | Should be successful |
 * | 02               | Create the first policy (p1) with net_id "netX" and type em_policy_id_type_channel_scan       | p1: net_id = "netX", type = em_policy_id_type_channel_scan, device_mac = 0xFF,0xEE,0xDD,0xCC,0xBB,0xAA                                | p1 is set and stored in mesh through set_policy() call               | Should Pass   |
 * | 03               | Create the second policy (p2) as a copy of p1 but change the policy type to traffic_separation | p2: net_id = "netX", type = em_policy_id_type_traffic_separation, device_mac = 0xFF,0xEE,0xDD,0xCC,0xBB,0xAA                        | p2 is set and mesh.m_num_policy increments to 2 after second set_policy() call | Should Pass   |
 */
TEST(dm_easy_mesh_t, set_policy_SameIdsDifferentTypeAddsNewPolicy)
{
    std::cout << "Entering set_policy_SameIdsDifferentTypeAddsNewPolicy test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    unsigned char device_mac[6] = {0xFF,0xEE,0xDD,0xCC,0xBB,0xAA};
    memcpy(mesh.m_device.m_device_info.intf.mac, device_mac, 6);
    dm_policy_t p1{};
    strncpy(p1.m_policy.id.net_id, "netX", sizeof(p1.m_policy.id.net_id) - 1);
    p1.m_policy.id.type = em_policy_id_type_channel_scan;
    memcpy(p1.m_policy.id.dev_mac, device_mac, 6);
    dm_policy_t p2 = p1;
    p2.m_policy.id.type = em_policy_id_type_traffic_separation;
    std::cout << "Invoking set_policy with em_policy_id_type_channel_scan policy type" << std::endl;
    mesh.set_policy(p1);
    std::cout << "Invoking set_policy with em_policy_id_type_traffic_separation type" << std::endl;
    mesh.set_policy(p2);
    mesh.deinit();
    EXPECT_EQ(mesh.m_num_policy, 2u);
    std::cout << "Exiting set_policy_SameIdsDifferentTypeAddsNewPolicy test" << std::endl;
}

/**
 * @brief Verifies that set_num_ap_mld correctly sets the m_num_ap_mld member to zero.
 *
 * This test validates that when a zero value is provided to the set_num_ap_mld API, the m_num_ap_mld
 * member variable of the dm_easy_mesh_t object is set to 0. This ensures proper handling of edge case
 * input values.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 491@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                    | Test Data                       | Expected Result                                | Notes              |
 * | :--------------: | ---------------------------------------------- | ------------------------------- | ---------------------------------------------- | ------------------ |
 * | 01               | Instantiate dm_easy_mesh_t object              | -                               | Object created successfully                    | Should be successful |
 * | 02               | Invoke set_num_ap_mld with a zero value        | input_value = 0                 | m_num_ap_mld member updated to 0                | Should Pass        |
 * | 03               | Validate m_num_ap_mld is set to 0               | retrieved_value = 0             | Retrieved value equals 0 as expected            | Should Pass        |
 */
TEST(dm_easy_mesh_t, set_num_ap_mld_zero_value) {
    std::cout << "Entering set_num_ap_mld_zero_value test" << std::endl;
    dm_easy_mesh_t obj;
    unsigned int input_value = 0;
    std::cout << "Invoking set_num_ap_mld with input: " << input_value << std::endl;
    obj.set_num_ap_mld(input_value);
    unsigned int retrieved_value = obj.m_num_ap_mld;
    std::cout << "Retrieved m_num_ap_mld value: " << retrieved_value << std::endl;
    EXPECT_EQ(retrieved_value, 0);    
    std::cout << "Exiting set_num_ap_mld_zero_value test" << std::endl;
}

/**
 * @brief Tests that set_num_ap_mld method correctly assigns a positive value to m_num_ap_mld.
 *
 * This test verifies that the dm_easy_mesh_t object properly stores the positive integer value (10) provided to the set_num_ap_mld function. The objective is to ensure that the API correctly handles and updates the internal member variable m_num_ap_mld when a valid positive input is provided.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 492@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                | Test Data                                          | Expected Result                                              | Notes        |
 * | :--------------: | ---------------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ | ------------ |
 * | 01               | Initialize dm_easy_mesh_t object and declare input value   | input_value = 10                                   | Object is created and input value is prepared                | Should be successful |
 * | 02               | Invoke set_num_ap_mld with the provided positive input     | input_value = 10, output not directly retrievable  | set_num_ap_mld function processes input and updates m_num_ap_mld| Should Pass  |
 * | 03               | Retrieve m_num_ap_mld and verify it equals the input value   | m_num_ap_mld = 10 (expected after invocation)      | EXPECT_EQ confirms m_num_ap_mld is equal to 10                | Should Pass  |
 */
TEST(dm_easy_mesh_t, set_num_ap_mld_positive_value) {
    std::cout << "Entering set_num_ap_mld_positive_value test" << std::endl;
    dm_easy_mesh_t obj;
    unsigned int input_value = 10;
    std::cout << "Invoking set_num_ap_mld with input: " << input_value << std::endl;
    obj.set_num_ap_mld(input_value);
    unsigned int retrieved_value = obj.m_num_ap_mld;
    std::cout << "Retrieved m_num_ap_mld value: " << retrieved_value << std::endl;
    EXPECT_EQ(retrieved_value, 10);
    std::cout << "Exiting set_num_ap_mld_positive_value test" << std::endl;
}

/**
 * @brief Validate that the set_num_ap_mld API correctly handles the maximum unsigned integer value.
 *
 * This test verifies that the set_num_ap_mld method of the dm_easy_mesh_t class correctly assigns and retains the maximum possible unsigned integer value (4294967295u). The test confirms that both the assignment and the retrieval of the value are working as expected.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 493@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                | Test Data                                                       | Expected Result                                                       | Notes         |
 * | :--------------: | ---------------------------------------------------------- | --------------------------------------------------------------- | --------------------------------------------------------------------- | ------------- |
 * | 01               | Log entry at start of test execution                       | N/A                                                             | Should display the "Entering set_num_ap_mld_max_unsigned_int test" msg | Should be successful |
 * | 02               | Instantiate the dm_easy_mesh_t object                      | N/A                                                             | Object instantiated successfully                                      | Should be successful |
 * | 03               | Invoke set_num_ap_mld with maximum unsigned int value      | input_value = 4294967295u                                         | Internal m_num_ap_mld is set to 4294967295u                             | Should Pass   |
 * | 04               | Retrieve the value of m_num_ap_mld                         | Output: m_num_ap_mld, retrieved_value printed as 4294967295u      | Retrieved value is 4294967295u                                          | Should Pass   |
 * | 05               | Verify the correctness using an assertion                  | Using assertion: EXPECT_EQ(retrieved_value, 4294967295u)          | Assertion passes validating that retrieved_value equals 4294967295u     | Should Pass   |
 * | 06               | Log exit from test execution                               | N/A                                                             | Should display the "Exiting set_num_ap_mld_max_unsigned_int test" msg   | Should be successful |
 */
TEST(dm_easy_mesh_t, set_num_ap_mld_max_unsigned_int) {
    std::cout << "Entering set_num_ap_mld_max_unsigned_int test" << std::endl;
    dm_easy_mesh_t obj;
    unsigned int input_value = 4294967295u;
    std::cout << "Invoking set_num_ap_mld with input: " << input_value << std::endl;
    obj.set_num_ap_mld(input_value);
    unsigned int retrieved_value = obj.m_num_ap_mld;
    std::cout << "Retrieved m_num_ap_mld value: " << retrieved_value << std::endl;
    EXPECT_EQ(retrieved_value, 4294967295u);
    std::cout << "Exiting set_num_ap_mld_max_unsigned_int test" << std::endl;
}

/**
 * @brief Verify that setting the number of AP MLD sets to zero correctly updates the dm_easy_mesh_t instance
 *
 * This test checks whether the API dm_easy_mesh_t::set_num_ap_mld properly sets the m_num_ap_mld member of the dm_easy_mesh_t instance to zero. The objective is to validate that the function accepts a zero value and that the instance reflects this correctly after the call.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 494@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                   | Test Data                                             | Expected Result                                                      | Notes           |
 * | :----:           | ------------------------------------------------------------- | ----------------------------------------------------- | -------------------------------------------------------------------- | --------------- |
 * | 01               | Print entry log and create a dm_easy_mesh_t instance          | N/A                                                 | Instance created successfully                                        | Should be successful |
 * | 02               | Set the test variable testValue to zero                       | testValue = 0                                         | Variable set with value 0                                            | Should be successful |
 * | 03               | Invoke dm_easy_mesh_t::set_num_ap_mld with the instance and value 0 | dmInstance = valid instance, num = 0                 | m_num_ap_mld member of instance is updated to 0                      | Should Pass     |
 * | 04               | Validate m_num_ap_mld value using EXPECT_EQ                     | input: m_num_ap_mld, expected: 0                      | EXPECT_EQ confirms m_num_ap_mld equals 0                              | Should Pass     |
 */
TEST(dm_easy_mesh_t, set_num_ap_mld_sets_to_zero) {
    std::cout << "Entering set_num_ap_mld_sets_to_zero test" << std::endl;
    dm_easy_mesh_t dmInstance;
    std::cout << "Created dm_easy_mesh_t instance." << std::endl;
    unsigned int testValue = 0;
    std::cout << "Invoking set_num_ap_mld with num = " << testValue << std::endl;
    dm_easy_mesh_t::set_num_ap_mld(static_cast<void*>(&dmInstance), testValue);
    std::cout << "Retrieved m_num_ap_mld value: " << dmInstance.m_num_ap_mld << std::endl;
    EXPECT_EQ(dmInstance.m_num_ap_mld, testValue);
    std::cout << "Exiting set_num_ap_mld_sets_to_zero test" << std::endl;
}

/**
 * @brief Verify that dm_easy_mesh_t::set_num_ap_mld correctly sets the number of AP MLD sets to a positive value.
 *
 * This test creates an instance of dm_easy_mesh_t, initializes a positive test value,
 * and invokes the set_num_ap_mld function to update the instance's m_num_ap_mld member.
 * The internal member is then verified to match the positive input value to ensure proper functionality.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 495@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                   | Test Data                                             | Expected Result                                                         | Notes             |
 * | :--------------: | ------------------------------------------------------------- | ----------------------------------------------------- | ----------------------------------------------------------------------- | ----------------- |
 * | 01               | Log entering the test                                         | None                                                  | "Entering set_num_ap_mld_sets_to_positive_value test" logged             | Should be successful |
 * | 02               | Create an instance of dm_easy_mesh_t                           | Instance created                                      | dm_easy_mesh_t instance is successfully created                         | Should be successful |
 * | 03               | Initialize testValue to positive value (5)                    | testValue = 5                                         | testValue variable is set to 5                                          | Should be successful |
 * | 04               | Invoke set_num_ap_mld with dmInstance pointer and testValue     | input: dmInstance pointer, testValue = 5              | m_num_ap_mld is updated to 5 in the instance                              | Should Pass         |
 * | 05               | Verify m_num_ap_mld equals the testValue                        | m_num_ap_mld = 5, testValue = 5                        | EXPECT_EQ assertion confirms m_num_ap_mld equals 5                      | Should Pass         |
 * | 06               | Log exiting the test                                          | None                                                  | "Exiting set_num_ap_mld_sets_to_positive_value test" logged               | Should be successful |
 */
TEST(dm_easy_mesh_t, set_num_ap_mld_sets_to_positive_value) {
    std::cout << "Entering set_num_ap_mld_sets_to_positive_value test" << std::endl;
    dm_easy_mesh_t dmInstance;
    std::cout << "Created dm_easy_mesh_t instance." << std::endl;
    unsigned int testValue = 5;
    std::cout << "Invoking set_num_ap_mld with num = " << testValue << std::endl;
    dm_easy_mesh_t::set_num_ap_mld(static_cast<void*>(&dmInstance), testValue);
    std::cout << "Retrieved m_num_ap_mld value: " << dmInstance.m_num_ap_mld << std::endl;
    EXPECT_EQ(dmInstance.m_num_ap_mld, testValue);
    std::cout << "Exiting set_num_ap_mld_sets_to_positive_value test" << std::endl;
}

/**
 * @brief Verify that dm_easy_mesh_t::set_num_ap_mld correctly sets the m_num_ap_mld member to UINT_MAX.
 *
 * This test creates an instance of dm_easy_mesh_t, invokes the set_num_ap_mld function with UINT_MAX, and confirms that
 * the m_num_ap_mld field of the instance is updated correctly. This ensures that the API handles boundary values as expected.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 496@n
 * **Priority:** High
 * 
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                         | Test Data                                                       | Expected Result                                  | Notes             |
 * | :--------------: | ------------------------------------------------------------------- | ---------------------------------------------------------------- | ------------------------------------------------ | ----------------- |
 * | 01               | Instantiate a dm_easy_mesh_t object                                 | dmInstance is created using the default constructor              | Object instantiated successfully                 | Should be successful |
 * | 02               | Call set_num_ap_mld with testValue set to UINT_MAX                   | input: pointer to dmInstance, testValue = UINT_MAX                 | Function sets m_num_ap_mld to UINT_MAX            | Should Pass       |
 * | 03               | Validate that m_num_ap_mld equals UINT_MAX after the API call        | output: dmInstance.m_num_ap_mld, expected value = UINT_MAX           | EXPECT_EQ(dmInstance.m_num_ap_mld, UINT_MAX) passes | Should Pass       |
 */
TEST(dm_easy_mesh_t, set_num_ap_mld_sets_to_max_unsigned_int) {
    std::cout << "Entering set_num_ap_mld_sets_to_max_unsigned_int test" << std::endl;
    dm_easy_mesh_t dmInstance;
    std::cout << "Created dm_easy_mesh_t instance." << std::endl;
    unsigned int testValue = UINT_MAX;
    std::cout << "Invoking set_num_ap_mld with num = " << testValue << std::endl;
    dm_easy_mesh_t::set_num_ap_mld(static_cast<void*>(&dmInstance), testValue);
    std::cout << "Retrieved m_num_ap_mld value: " << dmInstance.m_num_ap_mld << std::endl;
    EXPECT_EQ(dmInstance.m_num_ap_mld, testValue);
    std::cout << "Exiting set_num_ap_mld_sets_to_max_unsigned_int test" << std::endl;
}

/**
 * @brief Test set_num_ap_mld with NULL dm pointer to validate error handling
 *
 * This test verifies that invoking set_num_ap_mld with a NULL dm pointer and num = 3 triggers an exception. This is to ensure that the API robustly handles invalid pointer inputs.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 497@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke set_num_ap_mld with a NULL dm and num = 3 | dm = NULL, num = 3 | API throws an exception; assertion passes | Should Fail |
 */
TEST(dm_easy_mesh_t, set_num_ap_mld_null_dm) {
    std::cout << "Entering set_num_ap_mld_null_dm test" << std::endl;
    std::cout << "Invoking set_num_ap_mld with NULL dm and num = 3" << std::endl;
    EXPECT_ANY_THROW(dm_easy_mesh_t::set_num_ap_mld(NULL, 3));
    std::cout << "Exiting set_num_ap_mld_null_dm test" << std::endl;
}

/**
 * @brief Test that the set_num_bss method correctly assigns zero to the m_num_bss member.
 *
 * This test verifies that when set_num_bss is called with a value of zero on a dm_easy_mesh_t object, the member variable m_num_bss is updated to zero. The test confirms the API behaves as expected when zero is provided as the input.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 498@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                         | Test Data                                             | Expected Result                                         | Notes           |
 * | :--------------: | --------------------------------------------------- | ----------------------------------------------------- | ------------------------------------------------------- | --------------- |
 * | 01               | Print entry message and create a dm_easy_mesh_t object | N/A                                                 | Entry message printed and object created successfully   | Should be successful |
 * | 02               | Initialize variable 'value' to 0                    | value = 0                                             | Variable 'value' is set to 0                             | Should be successful |
 * | 03               | Print message indicating invocation of set_num_bss with value | value = 0                                             | Message printed showing value 0                          | Should be successful |
 * | 04               | Invoke set_num_bss with value 0 on the object        | input: obj, input value = 0, output: m_num_bss updated | m_num_bss is updated to 0, EXPECT_EQ check passes         | Should Pass     |
 * | 05               | Print the retrieved m_num_bss value from the object  | N/A                                                 | Printed value matches 0                                  | Should be successful |
 * | 06               | Assert that m_num_bss is equal to 0                  | output: obj.m_num_bss, expected value = 0             | EXPECT_EQ(obj.m_num_bss, 0u) passes                      | Should Pass     |
 * | 07               | Print exit message                                  | N/A                                                 | Exit message printed                                     | Should be successful |
 */
TEST(dm_easy_mesh_t, set_num_bss_zero)
{
    std::cout << "Entering set_num_bss_zero test" << std::endl;    
    dm_easy_mesh_t obj;
    unsigned int value = 0;
    std::cout << "Invoking set_num_bss with value: " << value << std::endl;    
    obj.set_num_bss(value);
    std::cout << "Retrieved member m_num_bss value after set: " << obj.m_num_bss << std::endl;    
    EXPECT_EQ(obj.m_num_bss, 0u);    
    std::cout << "Exiting set_num_bss_zero test" << std::endl;
}

/**
 * @brief Test to verify that setting the number of BSS in dm_easy_mesh_t updates the member variable correctly.
 *
 * This test creates an instance of dm_easy_mesh_t and sets its number of BSS value using the set_num_bss API with an input value of 5. 
 * It then checks if the internal member variable m_num_bss reflects the updated value as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 499@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                   | Test Data                                | Expected Result                                                                   | Notes           |
 * | :---------------:|---------------------------------------------------------------|------------------------------------------|------------------------------------------------------------------------------------|-----------------|
 * | 01               | Create an instance of dm_easy_mesh_t and initialize test data.  | N/A                                      | Object is instantiated successfully.                                             | Should be successful |
 * | 02               | Invoke the set_num_bss API with a value of 5.                   | input: value = 5                         | The m_num_bss member is updated to 5 after the function call.                      | Should Pass     |
 * | 03               | Verify that m_num_bss equals 5 using EXPECT_EQ.                 | output: m_num_bss = 5, expected: 5         | EXPECT_EQ confirms that m_num_bss is equal to 5.                                   | Should Pass     |
 */
TEST(dm_easy_mesh_t, set_num_bss_positive)
{
    std::cout << "Entering set_num_bss_positive test" << std::endl;    
    dm_easy_mesh_t obj;
    unsigned int value = 5;
    std::cout << "Invoking set_num_bss with value: " << value << std::endl;    
    obj.set_num_bss(value);
    std::cout << "Retrieved member m_num_bss value after set: " << obj.m_num_bss << std::endl;    
    EXPECT_EQ(obj.m_num_bss, 5u);    
    std::cout << "Exiting set_num_bss_positive test" << std::endl;
}

/**
 * @brief Test to validate that set_num_bss correctly assigns the maximum unsigned int value.
 *
 * This test verifies that when set_num_bss is invoked with the maximum value defined by std::numeric_limits<unsigned int>::max(),
 * the internal member m_num_bss of dm_easy_mesh_t is correctly updated to that maximum value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 500@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                      | Test Data                                                                 | Expected Result                                                                                   | Notes         |
 * | :--------------: | ---------------------------------------------------------------- | ------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- | ------------- |
 * | 01               | Instantiate a dm_easy_mesh_t object                              | None                                                                      | dm_easy_mesh_t object is successfully created                                                      | Should be successful |
 * | 02               | Set variable 'value' to the maximum unsigned int value           | value = std::numeric_limits<unsigned int>::max()                          | Variable 'value' holds the maximum unsigned int value                                            | Should be successful |
 * | 03               | Invoke set_num_bss API using the maximum unsigned int value        | input1 = value = std::numeric_limits<unsigned int>::max()                   | The member m_num_bss of the object is updated to std::numeric_limits<unsigned int>::max()          | Should Pass   |
 * | 04               | Validate the updated member m_num_bss using EXPECT_EQ              | output1 = m_num_bss, expected = std::numeric_limits<unsigned int>::max()    | EXPECT_EQ confirms that m_num_bss equals std::numeric_limits<unsigned int>::max()                   | Should Pass   |
 */
TEST(dm_easy_mesh_t, set_num_bss_max_uint)
{
    std::cout << "Entering set_num_bss_max_uint test" << std::endl;    
    dm_easy_mesh_t obj;
    unsigned int value = std::numeric_limits<unsigned int>::max();
    std::cout << "Invoking set_num_bss with value: " << value << std::endl;    
    obj.set_num_bss(value);
    std::cout << "Retrieved member m_num_bss value after set: " << obj.m_num_bss << std::endl;   
    EXPECT_EQ(obj.m_num_bss, std::numeric_limits<unsigned int>::max());    
    std::cout << "Exiting set_num_bss_max_uint test" << std::endl;
}

/**
 * @brief Verifies that dm_easy_mesh_t::set_num_bss correctly sets the number of BSS
 *
 * This test case ensures that when a valid dm_easy_mesh_t instance and a typical valid number (3) are supplied to set_num_bss, the instance's m_num_bss is updated correctly. It validates the correct functionality of the setter in a typical positive scenario@n
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 501@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                        | Test Data                                                       | Expected Result                                          | Notes         |
 * | :--------------: | ------------------------------------------------------------------ | --------------------------------------------------------------- | -------------------------------------------------------- | ------------- |
 * | 01               | Initialize a dm_easy_mesh_t instance                               | instance pointer = valid                                          | Instance is created successfully                         | Should be successful |
 * | 02               | Define input value for number of BSS and log the value               | num = 3                                                         | Input value is set correctly                             | Should be successful |
 * | 03               | Invoke set_num_bss with the instance pointer and num                 | input: mesh_instance pointer, num = 3; output: m_num_bss updated  | mesh_instance.m_num_bss is updated to 3                  | Should Pass   |
 * | 04               | Verify that m_num_bss equals the expected value using an assertion   | expected m_num_bss = 3, actual m_num_bss from instance            | ASSERT_EQ passes showing m_num_bss equals 3              | Should Pass   |
 */
TEST(dm_easy_mesh_t, set_num_bss_valid_typical_positive) {
    std::cout << "Entering set_num_bss_valid_typical_positive test" << std::endl;
    dm_easy_mesh_t mesh_instance;
    unsigned int num = 3;
    std::cout << "Invoking set_num_bss with num = " << num << std::endl;
    dm_easy_mesh_t::set_num_bss(&mesh_instance, num);
    std::cout << "After invocation, mesh_instance.m_num_bss = " << mesh_instance.m_num_bss << std::endl;
    EXPECT_EQ(mesh_instance.m_num_bss, num);
    std::cout << "Exiting set_num_bss_valid_typical_positive test" << std::endl;
}

/**
 * @brief Tests that the set_num_bss API correctly handles a zero value.
 *
 * This test validates that invoking dm_easy_mesh_t::set_num_bss with a num value of 0 causes the m_num_bss member of the dm_easy_mesh_t instance to be set to 0. This verifies proper handling of a boundary value input.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 502@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create an instance of dm_easy_mesh_t, initialize num with 0, invoke set_num_bss API using these parameters, and verify that m_num_bss is updated correctly. | mesh_instance: instance of dm_easy_mesh_t, num = 0, output: m_num_bss expected to be 0 | m_num_bss equals 0; the API call returns void and the assertion EXPECT_EQ passes | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_bss_valid_zero_value) {
    std::cout << "Entering set_num_bss_valid_zero_value test" << std::endl;
    dm_easy_mesh_t mesh_instance;    
    unsigned int num = 0;
    std::cout << "Invoking set_num_bss with num = " << num << std::endl;
    dm_easy_mesh_t::set_num_bss(&mesh_instance, num);    
    std::cout << "After invocation, mesh_instance.m_num_bss = " << mesh_instance.m_num_bss << std::endl;
    EXPECT_EQ(mesh_instance.m_num_bss, num);    
    std::cout << "Exiting set_num_bss_valid_zero_value test" << std::endl;
}

/**
 * @brief Validates set_num_bss API with the maximum boundary value
 *
 * This test verifies that the set_num_bss function correctly sets the m_num_bss member of a dm_easy_mesh_t instance when provided with the maximum unsigned int value. It ensures that the API handles boundary values as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 503@n
 * **Priority:** High@n
 * @n
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * @n
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Instantiate dm_easy_mesh_t and set test variable num | mesh_instance created, num = std::numeric_limits<unsigned int>::max() | dm_easy_mesh_t instance is created and num is set correctly | Should be successful |
 * | 02 | Invoke set_num_bss with the maximum boundary value and verify m_num_bss member | input: pointer to mesh_instance, num = std::numeric_limits<unsigned int>::max(), output: mesh_instance.m_num_bss | mesh_instance.m_num_bss equals std::numeric_limits<unsigned int>::max() and EXPECT_EQ check passes | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_bss_valid_max_boundary_value) {
    std::cout << "Entering set_num_bss_valid_max_boundary_value test" << std::endl;
    dm_easy_mesh_t mesh_instance;    
    unsigned int num = std::numeric_limits<unsigned int>::max();
    std::cout << "Invoking set_num_bss with num = " << num << std::endl;
    dm_easy_mesh_t::set_num_bss(&mesh_instance, num);    
    std::cout << "After invocation, mesh_instance.m_num_bss = " << mesh_instance.m_num_bss << std::endl;
    EXPECT_EQ(mesh_instance.m_num_bss, num);    
    std::cout << "Exiting set_num_bss_valid_max_boundary_value test" << std::endl;
}

/**
 * @brief Validate that set_num_bss throws an exception when a NULL dm pointer is provided.
 *
 * This test verifies that calling set_num_bss with a NULL dm pointer and a valid num value results in an exception being thrown.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 504@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                          | Test Data              | Expected Result                          | Notes       |
 * | :---------------: | -------------------------------------------------------------------- | ---------------------- | ---------------------------------------- | ----------- |
 * | 01                | Invoke set_num_bss with NULL dm pointer and num = 5 to verify exception throwing | dm = NULL, num = 5     | API throws an exception as validated by EXPECT_ANY_THROW | Should Fail |
 */
TEST(dm_easy_mesh_t, set_num_bss_null_mesh_instance) {
    std::cout << "Entering set_num_bss_null_mesh_instance test" << std::endl;    
    unsigned int num = 5;
    std::cout << "Invoking set_num_bss with NULL dm pointer and num = " << num << std::endl;        
    EXPECT_ANY_THROW(dm_easy_mesh_t::set_num_bss(NULL, num));
    std::cout << "Exiting set_num_bss_null_mesh_instance test" << std::endl;
}

/**
 * @brief Validate that dm_easy_mesh_t::set_num_op_class correctly sets the number of operational classes.
 *
 * This test verifies that when a valid unsigned integer value is provided to the set_num_op_class API,
 * the internal member m_num_opclass is correctly updated to match the input. This ensures that the API
 * functions as expected in a typical positive scenario.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:**505@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                      | Test Data                                       | Expected Result                                  | Notes       |
 * | :--------------: | ------------------------------------------------------------------------------------------------ | ----------------------------------------------- | ------------------------------------------------ | ----------- |
 * | 01               | Invoke set_num_op_class with a valid value and verify that m_num_opclass is updated accordingly. | value = 5, m_num_opclass expected = 5             | m_num_opclass equals 5 after the API call         | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_op_class_typical_positive)
{
    std::cout << "Entering set_num_op_class_typical_positive test" << std::endl;
    dm_easy_mesh_t obj;
    unsigned int value = 5;
    std::cout << "Invoking set_num_op_class with value: " << value << std::endl;
    obj.set_num_op_class(value);
    std::cout << "Value of m_num_opclass after invocation: " << obj.m_num_opclass << std::endl;
    ASSERT_EQ(obj.m_num_opclass, value);
    std::cout << "Exiting set_num_op_class_typical_positive test" << std::endl;
}

/**
 * @brief Validate that set_num_op_class correctly assigns zero to m_num_opclass.
 *
 * This test verifies that when a zero value is passed to the set_num_op_class API of the dm_easy_mesh_t object, 
 * the internal variable m_num_opclass is correctly updated to 0. Testing this boundary condition ensures that the API 
 * functions correctly for lower limit inputs.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 506@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Print entry message indicating the start of the test | N/A | "Entering set_num_op_class_zero test" is printed | Should be successful |
 * | 02 | Instantiate dm_easy_mesh_t object and set test variable value to 0 | value = 0, object created | Object is instantiated and value is set to 0 | Should be successful |
 * | 03 | Invoke set_num_op_class API with the zero value | input: value = 0, output: m_num_opclass updated | m_num_opclass is set to 0 after API call | Should Pass |
 * | 04 | Check the internal state with ASSERT_EQ to validate the API result | input: expected = 0, actual: m_num_opclass | ASSERT_EQ verifies that m_num_opclass equals 0 | Should Pass |
 * | 05 | Print exit message signaling the end of the test | N/A | "Exiting set_num_op_class_zero test" is printed | Should be successful |
 */
TEST(dm_easy_mesh_t, set_num_op_class_zero)
{
    std::cout << "Entering set_num_op_class_zero test" << std::endl;
    dm_easy_mesh_t obj;
    unsigned int value = 0;
    std::cout << "Invoking set_num_op_class with value: " << value << std::endl;
    obj.set_num_op_class(value);
    std::cout << "Value of m_num_opclass after invocation: " << obj.m_num_opclass << std::endl;
    ASSERT_EQ(obj.m_num_opclass, value);
    std::cout << "Exiting set_num_op_class_zero test" << std::endl;
}

/**
 * @brief Test setting operational class to maximum unsigned integer value
 *
 * This test verifies that the set_num_op_class API correctly assigns the maximum
 * value possible for an unsigned integer to the dm_easy_mesh_t object's m_num_opclass member.
 * It ensures that the API handles boundary input correctly without causing any errors.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 507@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Instantiate dm_easy_mesh_t object and set maximum unsigned int value | object = dm_easy_mesh_t, value = std::numeric_limits<unsigned int>::max() | Object instantiated and value variable holds the maximum unsigned int value | Should be successful |
 * | 02 | Invoke set_num_op_class() with the maximum value and verify m_num_opclass is updated accordingly | input: value = std::numeric_limits<unsigned int>::max(), output: m_num_opclass = std::numeric_limits<unsigned int>::max() | obj.m_num_opclass equals maximum unsigned int value | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_op_class_maximum_value)
{
    std::cout << "Entering set_num_op_class_maximum_value test" << std::endl;
    dm_easy_mesh_t obj;
    unsigned int value = std::numeric_limits<unsigned int>::max();
    std::cout << "Invoking set_num_op_class with value: " << value << std::endl;
    obj.set_num_op_class(value);
    std::cout << "Value of m_num_opclass after invocation: " << obj.m_num_opclass << std::endl;
    ASSERT_EQ(obj.m_num_opclass, value);
    std::cout << "Exiting set_num_op_class_maximum_value test" << std::endl;
}

/**
 * @brief Validate that the dm_easy_mesh_t::set_num_op_class correctly updates the m_num_opclass field.
 *
 * This test ensures that when set_num_op_class is invoked with a valid opClass value, the m_num_opclass
 * member of the dm_easy_mesh_t instance is properly updated. It verifies that the API works as expected 
 * in a typical scenario by checking both the updated member value and the logging behavior.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 508@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                              | Test Data                                         | Expected Result                                    | Notes           |
 * | :--------------: | ---------------------------------------------------------------------------------------- | ------------------------------------------------- | -------------------------------------------------- | --------------- |
 * | 01               | Log entry into the test function and instantiate dm_easy_mesh_t instance                   | None                                              | Test entry logged and instance created successfully | Should be successful |
 * | 02               | Assign a valid opClass value and log the input                                              | opClassValue = 5                                  | Logging shows opClassValue set to 5                | Should be successful |
 * | 03               | Invoke set_num_op_class API with the instance pointer and opClass value                     | instance pointer, opClassValue = 5                | m_num_opclass field updated to 5                   | Should Pass     |
 * | 04               | Assert that dm_easy_mesh_t instance's m_num_opclass equals the opClass value obtained         | instance pointer with m_num_opclass, expected opClassValue = 5 | EXPECT_EQ passes with m_num_opclass == 5           | Should Pass     |
 * | 05               | Log exit from the test function                                                             | None                                              | Test exit logged successfully                      | Should be successful |
 */
TEST(dm_easy_mesh_t, set_num_op_class_valid_typical) {
    std::cout << "Entering set_num_op_class_valid_typical test" << std::endl;
    dm_easy_mesh_t dmInstance;
    unsigned int opClassValue = 5;
    std::cout << "Invoking set_num_op_class with value: " << opClassValue << std::endl;
    dm_easy_mesh_t::set_num_op_class(&dmInstance, opClassValue);
    std::cout << "Value in dmInstance.m_num_opclass after setting: " << dmInstance.m_num_opclass << std::endl;
    EXPECT_EQ(dmInstance.m_num_opclass, opClassValue);    
    std::cout << "Exiting set_num_op_class_valid_typical test" << std::endl;
}

/**
 * @brief Verify that set_num_op_class correctly handles a zero value input.
 *
 * This test verifies that invoking the set_num_op_class API with a value of zero updates
 * the dm_easy_mesh_t instance properly. The test confirms that the member variable m_num_opclass
 * in the instance is set to 0 as expected, ensuring the API behaves correctly for boundary value testing.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 509@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                               | Test Data                                           | Expected Result                                                   | Notes       |
 * | :----:           | --------------------------------------------------------- | --------------------------------------------------- | ----------------------------------------------------------------- | ----------- |
 * | 01               | Call set_num_op_class with opClassValue set to 0          | input: dmInstance address, opClassValue = 0         | dmInstance.m_num_opclass equals 0 using EXPECT_EQ                  | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_op_class_valid_zero) {
    std::cout << "Entering set_num_op_class_valid_zero test" << std::endl;
    dm_easy_mesh_t dmInstance;
    unsigned int opClassValue = 0;
    std::cout << "Invoking set_num_op_class with value: " << opClassValue << std::endl;
    dm_easy_mesh_t::set_num_op_class(&dmInstance, opClassValue);
    std::cout << "Value in dmInstance.m_num_opclass after setting: " << dmInstance.m_num_opclass << std::endl;
    EXPECT_EQ(dmInstance.m_num_opclass, opClassValue);    
    std::cout << "Exiting set_num_op_class_valid_zero test" << std::endl;
}

/**
 * @brief Verify that set_num_op_class function assigns the maximum unsigned integer value correctly.
 *
 * This test validates that the set_num_op_class method of the dm_easy_mesh_t class correctly sets the m_num_opclass member to UINT_MAX when provided with the maximum unsigned integer. It ensures proper handling of boundary input values.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 510@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result |Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke set_num_op_class with UINT_MAX and validate the assignment to the member variable | dmInstance pointer: address of dmInstance, opClassValue = UINT_MAX, expected m_num_opclass = UINT_MAX | dmInstance.m_num_opclass should equal UINT_MAX and the assertion should pass | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_op_class_valid_max_unsigned) {
    std::cout << "Entering set_num_op_class_valid_max_unsigned test" << std::endl;
    dm_easy_mesh_t dmInstance;
    unsigned int opClassValue = UINT_MAX;
    std::cout << "Invoking set_num_op_class with value: " << opClassValue << std::endl;
    dm_easy_mesh_t::set_num_op_class(&dmInstance, opClassValue);
    std::cout << "Value in dmInstance.m_num_opclass after setting: " << dmInstance.m_num_opclass << std::endl;
    EXPECT_EQ(dmInstance.m_num_opclass, opClassValue);  
    std::cout << "Exiting set_num_op_class_valid_max_unsigned test" << std::endl;
}

/**
 * @brief Validate that set_num_op_class throws an exception when provided with an invalid DM pointer.
 *
 * This test verifies that the set_num_op_class API correctly handles an invalid DM pointer (nullptr)
 * by throwing an exception when invoked with a valid opClass value. The objective is to ensure robust
 * error handling in pointer validations.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 511@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                        | Test Data                                  | Expected Result                                                  | Notes       |
 * | :--------------: | ------------------------------------------------------------------ | ------------------------------------------ | ---------------------------------------------------------------- | ----------- |
 * | 01               | Invoke set_num_op_class with an invalid DM pointer (nullptr) and a valid opClass value | dm_pointer = nullptr, opClassValue = 5      | API call throws an exception as validated by EXPECT_ANY_THROW      | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_op_class_invalid_dm_pointer) {
    std::cout << "Entering set_num_op_class_invalid_dm_pointer test" << std::endl;
    unsigned int opClassValue = 5;
    std::cout << "Invoking set_num_op_class with nullptr and value: " << opClassValue << std::endl;
    EXPECT_ANY_THROW(dm_easy_mesh_t::set_num_op_class(nullptr, opClassValue));    
    std::cout << "Exiting set_num_op_class_invalid_dm_pointer test" << std::endl;
}

/**
 * @brief Test to verify that setting the number of radios to 0 via set_num_radios correctly updates the internal counter.
 *
 * This test verifies the behavior of dm_easy_mesh_t::set_num_radios when provided a value of 0. It checks that the internal member variable m_num_radios accurately reflects the input value. This is important to ensure proper handling of boundary conditions for the number of radios.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 512@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                   | Test Data                                 | Expected Result                                                              | Notes          |
 * | :--------------: | ------------------------------------------------------------- | ----------------------------------------- | ---------------------------------------------------------------------------- | -------------- |
 * | 01               | Instantiate dm_easy_mesh_t object                             | N/A                                       | Object is instantiated successfully                                          | Should be successful |
 * | 02               | Call set_num_radios with a value of 0                           | input_value = 0                           | m_num_radios is updated to 0                                                 | Should Pass    |
 * | 03               | Verify that m_num_radios is equal to 0 using an assertion         | output: m_num_radios = 0                    | EXPECT_EQ assertion confirms that m_num_radios equals 0                      | Should Pass    |
 */
TEST(dm_easy_mesh_t, set_num_radios_set_to_0) {
    std::cout << "Entering set_num_radios_set_to_0 test" << std::endl;
    dm_easy_mesh_t testObj;
    unsigned int input_value = 0;
    std::cout << "Invoking set_num_radios with value: " << input_value << std::endl;
    testObj.set_num_radios(input_value);    
    std::cout << "Retrieved m_num_radios value: " << testObj.m_num_radios << std::endl;
    EXPECT_EQ(testObj.m_num_radios, 0u);    
    std::cout << "Exiting set_num_radios_set_to_0 test" << std::endl;
}

/**
 * @brief Validate that set_num_radios correctly sets the number of radios when given a positive value.
 *
 * This test verifies that invoking set_num_radios with a positive integer (5) correctly updates the internal 
 * m_num_radios member of the dm_easy_mesh_t object. The test checks that after calling the method, the m_num_radios 
 * variable matches the expected positive value. It is essential to ensure that the API correctly handles and assigns 
 * positive values without issues.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 513@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                  | Test Data                                 | Expected Result                                             | Notes       |
 * | :--------------: | -------------------------------------------------------------------------------------------- | ----------------------------------------- | ----------------------------------------------------------- | ----------- |
 * | 01               | Instantiate dm_easy_mesh_t, set the input value to 5, and call set_num_radios with this value. | input_value = 5, output m_num_radios = 5  | m_num_radios should be updated to 5 as verified by EXPECT_EQ | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_radios_set_to_positive_value) {
    std::cout << "Entering set_num_radios_set_to_positive_value test" << std::endl;
    dm_easy_mesh_t testObj;
    unsigned int input_value = 5;
    std::cout << "Invoking set_num_radios with value: " << input_value << std::endl;
    testObj.set_num_radios(input_value);
    std::cout << "Retrieved m_num_radios value: " << testObj.m_num_radios << std::endl;
    EXPECT_EQ(testObj.m_num_radios, 5u);
    std::cout << "Exiting set_num_radios_set_to_positive_value test" << std::endl;
}

/**
 * @brief Verify that set_num_radios assigns UINT_MAX correctly
 *
 * This test verifies that the set_num_radios API correctly assigns the maximum unsigned integer value (UINT_MAX) to the object's internal member m_num_radios. It ensures that the API handles extreme boundary input correctly.
 *
 * **Test Group ID:** Basic: 01 / Module (L2): 02 / Stress (L2): 03@n
 * **Test Case ID:** 514@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                        | Test Data                                          | Expected Result                      | Notes       |
 * | :--------------: | ------------------------------------------------------------------ | -------------------------------------------------- | ------------------------------------ | ----------- |
 * | 01               | Call set_num_radios with UINT_MAX and verify m_num_radios is set to UINT_MAX | input_value = UINT_MAX, expected_m_num_radios = UINT_MAX | m_num_radios equals UINT_MAX | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_radios_set_to_UINT_MAX) {
    std::cout << "Entering set_num_radios_set_to_UINT_MAX test" << std::endl;
    dm_easy_mesh_t testObj;
    unsigned int input_value = UINT_MAX;
    std::cout << "Invoking set_num_radios with value: " << input_value << std::endl;
    testObj.set_num_radios(input_value);    
    std::cout << "Retrieved m_num_radios value: " << testObj.m_num_radios << std::endl;
    EXPECT_EQ(testObj.m_num_radios, UINT_MAX);    
    std::cout << "Exiting set_num_radios_set_to_UINT_MAX test" << std::endl;
}

/**
 * @brief Validate that the set_num_radios API correctly assigns the provided number of radios.
 *
 * This test verifies that the set_num_radios function properly stores the provided test value into the m_num_radios member of the dm_easy_mesh_t structure. The test ensures that a typical valid input is processed correctly and the internal state of the object is updated as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 515@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Instantiate dm_easy_mesh_t object and set test value for radios | dm object created, test_num = 3 | dm object is successfully created and test_num is initialized to 3 | Should be successful |
 * | 02 | Invoke set_num_radios with the test value | input1 = &dm, input2 = 3 | The dm.m_num_radios is updated to 3 | Should Pass |
 * | 03 | Verify that m_num_radios matches the expected test value | output = dm.m_num_radios (expected 3) | EXPECT_EQ(dm.m_num_radios, 3) returns true | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_radios_valid_typical)
{
    std::cout << "Entering set_num_radios_valid_typical test" << std::endl;
    dm_easy_mesh_t dm;
    unsigned int test_num = 3;
    std::cout << "Invoking set_num_radios with num: " << test_num << std::endl;
    dm_easy_mesh_t::set_num_radios(&dm, test_num);
    std::cout << "Expected m_num_radios: " << test_num << std::endl;
    std::cout << "Retrieved m_num_radios: " << dm.m_num_radios << std::endl;
    EXPECT_EQ(dm.m_num_radios, test_num);
    std::cout << "Exiting set_num_radios_valid_typical test" << std::endl;
}

/**
 * @brief Validate that set_num_radios correctly handles the maximum unsigned integer.
 *
 * This test verifies that calling set_num_radios with the maximum unsigned integer (UINT_MAX)
 * properly sets the m_num_radios member variable. It ensures that the API can accept and process
 * the highest possible valid unsigned integer value without errors.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 516@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create a dm_easy_mesh_t instance, invoke set_num_radios with test_num set to UINT_MAX, and verify that m_num_radios equals UINT_MAX. | dm instance, input: test_num = UINT_MAX, output: m_num_radios should equal UINT_MAX | m_num_radios is set to UINT_MAX and the assertion passes. | Should Pass |
 */
TEST(dm_easy_mesh_t, set_num_radios_valid_max_unsigned)
{
    std::cout << "Entering set_num_radios_valid_max_unsigned test" << std::endl;
    dm_easy_mesh_t dm;
    unsigned int test_num = UINT_MAX;
    std::cout << "Invoking set_num_radios with num: " << test_num << std::endl;
    dm_easy_mesh_t::set_num_radios(&dm, test_num);
    std::cout << "Expected m_num_radios: " << test_num << std::endl;
    std::cout << "Retrieved m_num_radios: " << dm.m_num_radios << std::endl;
    EXPECT_EQ(dm.m_num_radios, test_num);
    std::cout << "Exiting set_num_radios_valid_max_unsigned test" << std::endl;
}

/**
 * @brief Validate set_num_radios handles nullptr for dm input
 *
 * This test verifies that when a nullptr is passed as the dm pointer to the set_num_radios API along with a valid num value, the API throws an exception as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 517@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                 | Test Data                                  | Expected Result                         | Notes      |
 * | :--------------: | ----------------------------------------------------------- | ------------------------------------------ | --------------------------------------- | ---------- |
 * | 01               | Invoke set_num_radios with a nullptr for dm pointer and num = 5 | dm pointer = nullptr, test_num = 5           | Exception is thrown as per API contract | Should Fail |
 */
TEST(dm_easy_mesh_t, set_num_radios_invalid_dm_nullptr)
{
    std::cout << "Entering set_num_radios_invalid_dm_nullptr test" << std::endl;
    unsigned int test_num = 5;
    std::cout << "Invoking set_num_radios with NULL dm pointer and num: " << test_num << std::endl;
    EXPECT_ANY_THROW(
	{
		dm_easy_mesh_t::set_num_radios(nullptr, test_num);
	});
    std::cout << "Exiting set_num_radios_invalid_dm_nullptr test" << std::endl;
}

/**
 * @brief Validate that dm_easy_mesh_t is properly initialized.
 *
 * This test case creates an instance of dm_easy_mesh_t and calls its init() method to verify that it returns 0, indicating a successful initialization.
 *
 * **Test Group ID:** Basic: 01  
 * **Test Case ID:** 518@n  
 * **Priority:** High  
 *
 * **Pre-Conditions:** None  
 * **Dependencies:** None  
 * **User Interaction:** None  
 *
 * **Test Procedure:**  
 * | Variation / Step | Description                                             | Test Data                                  | Expected Result                                                 | Notes      |
 * | :--------------: | ------------------------------------------------------- | ------------------------------------------ | -------------------------------------------------------------- | ---------- |
 * | 01               | Create an instance of dm_easy_mesh_t and invoke init()   | No input; output: ret from init() = 0        | init() returns 0 and EXPECT_EQ(ret, 0) assertion passes          | Should Pass|
 */
TEST(dm_easy_mesh_t, init_proper_initialization_success) {
    std::cout << "Entering init_proper_initialization_success test" << std::endl;
    dm_easy_mesh_t easyMesh;
    std::cout << "Invoking dm_easy_mesh_t::init() method" << std::endl;
    int ret = easyMesh.init();
    std::cout << "Return value from init(): " << ret << std::endl;
    EXPECT_EQ(ret, 0);	
	//To prevent memory leak
    easyMesh.deinit();
    std::cout << "Exiting init_proper_initialization_success test" << std::endl;
}

/**
 * @brief Verify that the destructor of dm_easy_mesh_t is invoked properly when the object goes out of scope
 *
 * This test verifies that an instance of dm_easy_mesh_t, created via the default constructor, is correctly destroyed when it goes out of scope. The test logs the entry and exit of the test, ensuring that the destructor is executed as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 519@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                        | Test Data                                   | Expected Result                                                                     | Notes           |
 * | :--------------: | ------------------------------------------------------------------ | ------------------------------------------- | ----------------------------------------------------------------------------------- | --------------- |
 * | 01               | Log the entry message for test execution                           | std::cout << "Entering destructor_destruction_of_instance test" | Entry message is printed to the console                                             | Should be successful |
 * | 02               | Invoke the default constructor of dm_easy_mesh_t to create an instance | dm_easy_mesh_t obj; (no input arguments)    | Object is successfully constructed                                                  | Should Pass     |
 * | 03               | Allow the object to go out of scope to trigger the destructor         | Object goes out of scope                    | Destructor is invoked automatically and the instance is destroyed                  | Should Pass     |
 * | 04               | Log the exit message to signal completion of the test                | std::cout << "Exiting destructor_destruction_of_instance test"   | Exit message is printed to the console                                             | Should be successful |
 */
TEST(dm_easy_mesh_t, destructor_destruction_of_instance)
{
    std::cout << "Entering destructor_destruction_of_instance test" << std::endl;    
    {
        std::cout << "Invoking default constructor of dm_easy_mesh_t" << std::endl;
        dm_easy_mesh_t obj;
        std::cout << "Invoking destructor of dm_easy_mesh_t by leaving scope" << std::endl;
    } // Destructor ~dm_easy_mesh_t is invoked here.    
    std::cout << "Exiting destructor_destruction_of_instance test" << std::endl;
}

/**
 * @brief Verify that a newly constructed instance is properly reset.
 *
 * This test case validates that for a newly constructed dm_easy_mesh_t instance, calling the reset() function correctly sets all numeric members to 0 and boolean members to false.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 520@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Instantiate dm_easy_mesh_t and log its default state | instance is freshly constructed, m_num_preferences = default, m_colocated = default | The default state matches construction values before reset() is called | Should be successful |
 * | 02 | Invoke reset() on the instance and validate states | instance.reset() is called, m_num_preferences expected value = 0, m_colocated expected value = false | All numeric members are reset to 0 and boolean members are reset to false with EXPECT_EQ checks passing | Should Pass |
 */
TEST(dm_easy_mesh_t, reset_reset_on_newly_constructed_instance)
{
    std::cout << "Entering reset_reset_on_newly_constructed_instance test" << std::endl;
    dm_easy_mesh_t instance;    
    // Log initial default state of a few members
    std::cout << "Default state before reset(): " << std::endl;
    std::cout << "m_num_preferences = " << instance.m_num_preferences << std::endl;
    std::cout << "m_colocated = " << instance.m_colocated << std::endl;     
    std::cout << "Invoking reset()" << std::endl;
    instance.reset();    
    // Log state after calling reset()
    std::cout << "State after reset(): " << std::endl;
    std::cout << "m_num_preferences = " << instance.m_num_preferences << std::endl;
    std::cout << "m_colocated = " << instance.m_colocated << std::endl;
    // Expected: All numeric members should be reset to 0, booleans to false
    EXPECT_EQ(instance.m_num_preferences, 0u);
    EXPECT_EQ(instance.m_colocated, false);
    std::cout << "Exiting reset_reset_on_newly_constructed_instance test" << std::endl;
}

/**
 * @brief Verify that dm_easy_mesh_t::reset() correctly restores the default state of the instance
 *
 * This test modifies the internal state of a dm_easy_mesh_t object by setting m_num_preferences to 5 and m_colocated to true. 
 * It then calls the reset() method and verifies that all members return to their default values. The test ensures that the
 * reset() API functions as expected by restoring default values after internal state modifications.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 521@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                        | Test Data                                                                            | Expected Result                                                                               | Notes             |
 * | :--------------: | ------------------------------------------------------------------ | ------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------- | ----------------- |
 * | 01               | Log entering the test                                              | N/A                                                                                  | Console output indicates entry into the test                                                  | Should be successful |
 * | 02               | Modify instance state before reset()                               | instance.m_num_preferences = 5, instance.m_colocated = true                          | Instance internal state is modified from default values                                         | Should be successful |
 * | 03               | Log modified state before calling reset()                          | N/A                                                                                  | Console output displays the modified state of m_num_preferences and m_colocated                  | Should be successful |
 * | 04               | Invoke reset() to restore default values                           | API call: instance.reset()                                                           | Instance state is reset to default: m_num_preferences = 0 and m_colocated = false                | Should Pass       |
 * | 05               | Log state after reset()                                              | N/A                                                                                  | Console output displays the default state after reset()                                         | Should be successful |
 * | 06               | Verify state returned to default using assertions                  | EXPECT_EQ(instance.m_num_preferences, 0u), EXPECT_EQ(instance.m_colocated, false)      | Assertions pass confirming that default values are restored                                     | Should Pass       |
 * | 07               | Log exiting the test                                               | N/A                                                                                  | Console output indicates exit from the test                                                    | Should be successful |
 */
TEST(dm_easy_mesh_t, reset_after_modifying_internal_state)
{
    std::cout << "Entering reset_reset_after_modifying_internal_state test" << std::endl;
    dm_easy_mesh_t instance;
    instance.m_num_preferences = 5;
    instance.m_colocated = true;    
    // Log modified state before reset
    std::cout << "Modified state before reset(): " << std::endl;
    std::cout << "m_num_preferences = " << instance.m_num_preferences << std::endl;
    std::cout << "m_colocated = " << instance.m_colocated << std::endl;
    // Invoke reset() to restore default values.
    std::cout << "Invoking reset()" << std::endl;
    instance.reset();   
    // Log state after reset
    std::cout << "State after reset(): " << std::endl;
    std::cout << "m_num_preferences = " << instance.m_num_preferences << std::endl;
    std::cout << "m_colocated = " << instance.m_colocated << std::endl;
    // Expected: All members should return to their default values.
    EXPECT_EQ(instance.m_num_preferences, 0u);
    EXPECT_EQ(instance.m_colocated, false);
    std::cout << "Exiting reset_reset_after_modifying_internal_state test" << std::endl;
}

/**
 * @brief Verify that reset_cmd_ctx() resets the command context and leaves other member variables unaffected.
 *
 * This test initializes the m_cmd_ctx field with non-zero values and sets m_num_preferences to a distinct value.
 * It then calls reset_cmd_ctx() and confirms that m_cmd_ctx is zeroed out, while m_num_preferences retains its value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 522@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize the test object and set m_cmd_ctx with arbitrary non-zero values | m_cmd_ctx = 0xAB (all bytes) | m_cmd_ctx is initialized with non-zero values | Should be successful |
 * | 02 | Set m_num_preferences to a distinct non-zero value | m_num_preferences = 100 | m_num_preferences is set to 100 | Should be successful |
 * | 03 | Invoke reset_cmd_ctx() to reset the command context | Function call: reset_cmd_ctx() | m_cmd_ctx is reset (zeroed out) | Should Pass |
 * | 04 | Verify that m_cmd_ctx has been reset to zero by comparing with a zeroed reference | Compare m_cmd_ctx with zero_ctx (all bytes 0) | m_cmd_ctx equals zero_ctx (all zeros) | Should Pass |
 * | 05 | Verify that m_num_preferences remains unaffected | m_num_preferences remains 100 | m_num_preferences equals 100U | Should Pass |
 */
TEST(dm_easy_mesh_t, reset_cmd_ctx_resets_cmd_ctx_leaves_other_members_unaffected)
{
    std::cout << "Entering reset_cmd_ctx_resets_cmd_ctx_leaves_other_members_unaffected test" << std::endl;
    dm_easy_mesh_t testObj;
    // Initialize m_cmd_ctx with arbitrary non-zero values
    std::cout << "Setting m_cmd_ctx memory to non-zero values." << std::endl;
    memset(&testObj.m_cmd_ctx, 0xAB, sizeof(testObj.m_cmd_ctx));
    // Set other member variables to distinct non-zero values
    testObj.m_num_preferences = 100;
    std::cout << "m_num_preferences initialized with value: " << testObj.m_num_preferences << std::endl;
    // Invoke reset_cmd_ctx()
    std::cout << "Invoking reset_cmd_ctx()" << std::endl;
    testObj.reset_cmd_ctx();
    // Prepare a zeroed reference context
    em_cmd_ctx_t zero_ctx;
    memset(&zero_ctx, 0, sizeof(zero_ctx));
    // Verify m_cmd_ctx has been zeroed
    std::cout << "Verifying m_cmd_ctx has been reset to zero." << std::endl;
    EXPECT_EQ(memcmp(&testObj.m_cmd_ctx, &zero_ctx, sizeof(em_cmd_ctx_t)), 0);
    // Verify other members remain unaffected
    std::cout << "Verifying m_num_preferences retains its initialized value: " << testObj.m_num_preferences << std::endl;
    EXPECT_EQ(testObj.m_num_preferences, 100U);
    std::cout << "Exiting reset_cmd_ctx_resets_cmd_ctx_leaves_other_members_unaffected test" << std::endl;
}

/**
 * @brief Test that resetting the database configuration type using valid single bit enumeration values clears the corresponding bit.
 *
 * This test verifies that for every valid configuration type (single-bit enumeration), invoking the reset_db_cfg_type method correctly resets the corresponding bit in the object's db_cfg_param. The test initializes the object, sets all bits in db_cfg_type, and then iterates over a list of valid types. For each type, it calls reset_db_cfg_type and asserts that the bit corresponding to that type is cleared.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 523@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                        | Test Data                                                | Expected Result                                                                           | Notes          |
 * | :--------------: | ------------------------------------------------------------------ | -------------------------------------------------------- | ----------------------------------------------------------------------------------------- | -------------- |
 * | 01               | Initialize the dm_easy_mesh_t object and call its init() method      | No input, output: object initialized                     | The object is properly initialized                                                        | Should be successful |
 * | 02               | Set db_cfg_type to all ones (0xFFFFFFFF) to simulate all bits set     | db_cfg_type = 0xFFFFFFFF                                   | db_cfg_type is set to 0xFFFFFFFF                                                            | Should be successful |
 * | 03               | For each valid db_cfg_type value, invoke reset_db_cfg_type method     | input: type = valid enumeration from validTypes array; output: db_cfg_type after reset | The corresponding bit in db_cfg_type is cleared (resulting bit is 0), assertion passes         | Should Pass    |
 * | 04               | Log pre and post values of db_cfg_type for debugging purposes         | output: printed values before and after function call     | Console output shows before and after values of db_cfg_type                                 | Should be successful |
 */
TEST(dm_easy_mesh_t, reset_db_cfg_type_ValidInput_SingleBitEnums)
{
    std::cout << "Entering reset_db_cfg_type_ValidInput_SingleBitEnums test" << std::endl;
    dm_easy_mesh_t obj;
	obj.init();
    // Pretend all bits are set
    obj.m_db_cfg_param.db_cfg_type = 0xFFFFFFFF;
    db_cfg_type_t validTypes[] = {
        db_cfg_type_network_list_update,
        db_cfg_type_network_list_delete,
        db_cfg_type_device_list_update,
        db_cfg_type_device_list_delete,
        db_cfg_type_radio_list_update,
        db_cfg_type_radio_list_delete,
        db_cfg_type_op_class_list_update,
        db_cfg_type_op_class_list_delete,
        db_cfg_type_bss_list_update,
        db_cfg_type_bss_list_delete,
        db_cfg_type_sta_list_update,
        db_cfg_type_sta_list_delete,
        db_cfg_type_network_ssid_list_update,
        db_cfg_type_network_ssid_list_delete,
        db_cfg_type_radio_cap_list_update,
        db_cfg_type_radio_cap_list_delete,
        db_cfg_type_1905_security_list_update,
        db_cfg_type_1905_security_list_delete,
        db_cfg_type_sta_metrics_update,
        db_cfg_type_policy_list_update,
        db_cfg_type_policy_list_delete,
        db_cfg_type_scan_result_list_update,
        db_cfg_type_scan_result_list_delete
    };
    for (auto type : validTypes) {
        unsigned int before = obj.m_db_cfg_param.db_cfg_type;
        std::cout << "Invoking reset_db_cfg_type with value: " << type << std::endl;
        obj.reset_db_cfg_type(type);
        unsigned int after = obj.m_db_cfg_param.db_cfg_type;
        EXPECT_EQ(after & type, 0u);
        std::cout << "Before db_cfg_type : " << before << std::endl;
        std::cout << "After  db_cfg_type : " << after << std::endl;
    }
    obj.deinit();
    std::cout << "Exiting reset_db_cfg_type_ValidInput_SingleBitEnums test" << std::endl;
}

/**
 * @brief Verify that reset_db_cfg_type does not modify the configuration when given an invalid non-supported enum value.
 *
 * This test checks that passing an unsupported enum value (0xFFFFFFFF) to reset_db_cfg_type does not alter the current 
 * configuration (db_cfg_type). The test ensures that the API preserves the original configuration when invalid input is provided.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 524@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object, call init(), and set db_cfg_type to a known value. | input: db_cfg_param.db_cfg_type = 0xAAAAAAAA | The object's db_cfg_type is initialized to 0xAAAAAAAA. | Should be successful |
 * | 02 | Invoke reset_db_cfg_type with an invalid non-supported enum value (0xFFFFFFFF) and verify that the configuration remains unchanged. | input: invalidType = 0xFFFFFFFF, before = 0xAAAAAAAA | The API call does not change db_cfg_type; before and after values remain 0xAAAAAAAA. | Should Pass |
 */
TEST(dm_easy_mesh_t, reset_db_cfg_type_InvalidInput_NonSupportedEnum)
{
    std::cout << "Entering reset_db_cfg_type_InvalidInput_NonSupportedEnum test" << std::endl;
    dm_easy_mesh_t obj;
    obj.init();
    obj.m_db_cfg_param.db_cfg_type = 0xAAAAAAAA;
    unsigned int before = obj.m_db_cfg_param.db_cfg_type;
    db_cfg_type_t invalidType = static_cast<db_cfg_type_t>(0xFFFFFFFF);
    std::cout << "Invoking reset_db_cfg_type with invalid value: " << invalidType << std::endl;
    obj.reset_db_cfg_type(invalidType);
    unsigned int after = obj.m_db_cfg_param.db_cfg_type;
    EXPECT_EQ(before, after);
    std::cout << "Before db_cfg_type : " << before << std::endl;
    std::cout << "After  db_cfg_type : " << after << std::endl;
    obj.deinit();
    std::cout << "Exiting reset_db_cfg_type_InvalidInput_NonSupportedEnum test" << std::endl;
}

/**
 * @brief Test reset_db_cfg_type function for handling invalid combined enum values
 *
 * Test reset_db_cfg_type function is invoked with combined enum values from valid individual types resulting in an invalid input.
 * This test checks that the reset_db_cfg_type function does not change the current db_cfg_type when provided with such invalid input.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 525@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object and call init() method. | No inputs; object creation | Object created and initialized successfully | Should be successful |
 * | 02 | Set the db_cfg_type parameter to an invalid value (0xFFFFFFFF). | input: db_cfg_type = 0xFFFFFFFF | db_cfg_type is set to 0xFFFFFFFF | Should be successful |
 * | 03 | Capture current db_cfg_type before invoking reset_db_cfg_type. | output: before = 0xFFFFFFFF | Value correctly captured in variable 'before' | Should be successful |
 * | 04 | Prepare combined enum value by ORing db_cfg_type_network_list_update and db_cfg_type_network_list_delete. | input: combinedType = (db_cfg_type_network_list_update, db_cfg_type_network_list_delete) | combinedType is computed correctly | Should Pass |
 * | 05 | Invoke reset_db_cfg_type with the combined enum value. | input: combinedType (value from step 04) | Function is called with invalid combined enum value | Should Pass |
 * | 06 | Capture db_cfg_type after invoking reset_db_cfg_type. | output: after = current db_cfg_type | Value captured in variable 'after' remains unchanged | Should Pass |
 * | 07 | Verify that db_cfg_type remains unchanged by asserting before equals after. | input: before = 0xFFFFFFFF, after = 0xFFFFFFFF | EXPECT_EQ(before, after) assertion passes indicating no change | Should Pass |
 */
TEST(dm_easy_mesh_t, reset_db_cfg_type_InvalidInput_CombinedEnumValues)
{
    std::cout << "Entering reset_db_cfg_type_InvalidInput_CombinedEnumValues test" << std::endl;
    dm_easy_mesh_t obj;
    obj.init();
    obj.m_db_cfg_param.db_cfg_type = 0xFFFFFFFF;
    unsigned int before = obj.m_db_cfg_param.db_cfg_type;
    db_cfg_type_t combinedType = static_cast<db_cfg_type_t>(db_cfg_type_network_list_update | db_cfg_type_network_list_delete);
    std::cout << "Invoking reset_db_cfg_type with combined value: " << combinedType << std::endl;
    obj.reset_db_cfg_type(combinedType);
    unsigned int after = obj.m_db_cfg_param.db_cfg_type;
    EXPECT_EQ(before, after);
    std::cout << "Before db_cfg_type : " << before << std::endl;
    std::cout << "After  db_cfg_type : " << after << std::endl;
    obj.deinit();
    std::cout << "Exiting reset_db_cfg_type_InvalidInput_CombinedEnumValues test" << std::endl;
}

/**
 * @brief Test the reset_db_cfg_type API with an invalid input parameter (db_cfg_type_none)
 *
 * This test verifies that calling reset_db_cfg_type with the invalid input "db_cfg_type_none"
 * does not change the database configuration type value. The test initializes the object,
 * assigns a specific invalid value, and confirms via an assertion that the value remains unchanged.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 526@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object and set db_cfg_type to an invalid value | input: db_cfg_type = 0x12345678 | Object is initialized with db_cfg_type set to 0x12345678 successfully | Should be successful |
 * | 02 | Invoke reset_db_cfg_type with db_cfg_type_none | input: parameter = db_cfg_type_none | API is invoked and internal db_cfg_type value should remain unchanged | Should Pass |
 * | 03 | Verify that the db_cfg_type remains equal to the initial value after the API call | input: before value = 0x12345678, after value from reset_db_cfg_type | EXPECT_EQ check confirms that the value remains unchanged | Should Pass |
 */
TEST(dm_easy_mesh_t, reset_db_cfg_type_InvalidInput_None)
{
    std::cout << "Entering reset_db_cfg_type_InvalidInput_None test" << std::endl;
    dm_easy_mesh_t obj;
	obj.init();
    obj.m_db_cfg_param.db_cfg_type = 0x12345678;
    unsigned int before = obj.m_db_cfg_param.db_cfg_type;
    std::cout << "Invoking reset_db_cfg_type with db_cfg_type_none" << std::endl;
    obj.reset_db_cfg_type(db_cfg_type_none);
    EXPECT_EQ(obj.m_db_cfg_param.db_cfg_type, before);
    std::cout << "Before db_cfg_type : " << before << std::endl;
    std::cout << "After  db_cfg_type : " << obj.m_db_cfg_param.db_cfg_type << std::endl;
    obj.deinit();
    std::cout << "Exiting reset_db_cfg_type_InvalidInput_None test" << std::endl;
}

/**
 * @brief Verify that a valid interface returns the correct MAC address.
 *
 * This test checks that the dm_easy_mesh_t::mac_address_from_name API correctly retrieves the MAC address for a valid interface name ("brlan0"). It ensures the API returns a success code (0) and that the returned MAC address is printed out.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 527@n
 * **Priority:** (High)
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                           | Test Data                                                      | Expected Result                    |Notes           |
 * | :--------------: | --------------------------------------------------------------------- | -------------------------------------------------------------- | ----------------------------------- | -------------- |
 * | 01               | Log entry into the test function                                      | N/A                                                            | "Entering mac_address_from_name_ValidInterface test" printed  | Should be successful |
 * | 02               | Initialize MAC address structure and interface name                   | mac = {0}, ifname = "brlan0"                                     | Variables initialized as expected  | Should be successful |
 * | 03               | Invoke mac_address_from_name API with given interface                 | input: ifname = "brlan0", output: mac (initially zeros)          | Function returns 0                 | Should Pass    |
 * | 04               | Validate the API return value using EXPECT_EQ                         | input: ret value = 0                                             | Return value equals 0              | Should Pass    |
 * | 05               | Print the retrieved MAC address to the console                        | output: mac bytes printed in hexadecimal format                | MAC address displayed correctly    | Should be successful |
 * | 06               | Log exit log message from the test                                    | N/A                                                            | "Exiting mac_address_from_name_ValidInterface test" printed | Should be successful |
 */
TEST(dm_easy_mesh_t, mac_address_from_name_ValidInterface)
{
    std::cout << "Entering mac_address_from_name_ValidInterface test" << std::endl;    
    mac_address_t mac = {0};
    const char *ifname = "brlan0";
    std::cout << "Invoking mac_address_from_name(\"" << ifname << "\")" << std::endl;
    int ret = dm_easy_mesh_t::mac_address_from_name(ifname, mac);
    EXPECT_EQ(ret, 0);
    std::cout << "Return value : " << ret << std::endl;
    std::cout << "Retrieved MAC: ";
    for (int i = 0; i < 6; i++) {
        std::cout << std::hex << static_cast<int>(mac[i]) << " ";
    }
    std::cout << std::dec << std::endl;
    std::cout << "Exiting mac_address_from_name_ValidInterface test" << std::endl;
}

/**
 * @brief Test mac_address_from_name() with an invalid interface name to verify correct error handling
 *
 * This test ensures that calling mac_address_from_name() with an invalid network interface ("invalid_if_123")
 * correctly identifies the error condition and returns -1. It validates that the API does not alter the MAC
 * address when provided with an invalid interface name.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 528@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                               | Test Data                                         | Expected Result                    | Notes             |
 * | :--------------: | ----------------------------------------------------------------------------------------- | ------------------------------------------------- | ---------------------------------- | ----------------- |
 * |       01         | Initialize the test by setting an invalid interface name and zeroing the MAC array          | ifname = invalid_if_123, mac = {0,0,0,0,0,0}        | Variables are correctly initialized | Should be successful |
 * |       02         | Call mac_address_from_name() with the invalid interface and verify that it returns an error   | ifname = invalid_if_123, mac = {0,0,0,0,0,0}        | Function returns -1                | Should Fail       |
 */
TEST(dm_easy_mesh_t, mac_address_from_name_InvalidInterface)
{
    std::cout << "Entering mac_address_from_name_InvalidInterface test" << std::endl;
    mac_address_t mac = {0};
    const char *ifname = "invalid_if_123";
    std::cout << "Invoking mac_address_from_name(\"" << ifname << "\")" << std::endl;
    int ret = dm_easy_mesh_t::mac_address_from_name(ifname, mac);
    EXPECT_EQ(ret, -1);
    std::cout << "Return value : " << ret << std::endl;
    std::cout << "MAC after call: ";
    for (int i = 0; i < 6; i++) {
        std::cout << static_cast<int>(mac[i]) << " ";
    }
    std::cout << std::endl;
    std::cout << "Exiting mac_address_from_name_InvalidInterface test" << std::endl;
}

/**
 * @brief Verify that macbytes_to_string returns correctly formatted MAC string for a valid MAC input.
 *
 * This test checks that the macbytes_to_string API correctly converts a given valid MAC address (provided as an array of bytes) into a colon-separated string representation. It ensures that the returned pointer is the same as the provided output buffer and that the string content matches the expected MAC address format.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 529@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                       | Test Data                                                             | Expected Result                                                                                  | Notes       |
 * | :--------------: | ------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ | ----------- |
 * | 01               | Invoke macbytes_to_string with a valid MAC address and verify its conversion to a formatted string | mac = {0x00,0x11,0x22,0x33,0x44,0x55}, mac_str = {0}                   | Returned pointer equals mac_str and mac_str matches expected "00:11:22:33:44:55"                 | Should Pass |
 */
TEST(dm_easy_mesh_t, macbytes_to_string_ValidMac)
{
    std::cout << "Entering macbytes_to_string_ValidMac test" << std::endl;
    mac_address_t mac = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
    char mac_str[32] = {0};
    std::cout << "Invoking macbytes_to_string(mac, mac_str)" << std::endl;
    char *ret = dm_easy_mesh_t::macbytes_to_string(mac, mac_str);
    EXPECT_EQ(ret, mac_str);
    EXPECT_STREQ(mac_str, "00:11:22:33:44:55");
    std::cout << "Returned string pointer : " << ret << std::endl;
    std::cout << "MAC string              : " << mac_str << std::endl;
    std::cout << "Exiting macbytes_to_string_ValidMac test" << std::endl;
}

/**
 * @brief Verify that dm_easy_mesh_t::macbytes_to_string correctly handles a NULL MAC pointer
 *
 * This test ensures that when a NULL pointer is provided as the MAC address input, the function returns the unchanged output string.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 530@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * |01| Initialize mac_str with "unchanged" | mac_str = "unchanged" | mac_str is correctly set to "unchanged" | Should be successful |
 * |02| Call macbytes_to_string with a NULL MAC pointer and mac_str | input1 = nullptr, input2 = mac_str ("unchanged") | Function returns mac_str and mac_str remains "unchanged" | Should Pass |
 */
TEST(dm_easy_mesh_t, macbytes_to_string_NullMac)
{
    std::cout << "Entering macbytes_to_string_NullMac test" << std::endl;
    char mac_str[32];
    strcpy(mac_str, "unchanged");
    std::cout << "Invoking macbytes_to_string(NULL, mac_str)" << std::endl;
    char *ret = dm_easy_mesh_t::macbytes_to_string(nullptr, mac_str);
    EXPECT_EQ(ret, mac_str);
    EXPECT_STREQ(mac_str, "unchanged");
    std::cout << "Returned string pointer : " << ret << std::endl;
    std::cout << "MAC string after call   : " << mac_str << std::endl;
    std::cout << "Exiting macbytes_to_string_NullMac test" << std::endl;
}

/**
 * @brief Test conversion of a colon-separated MAC string to a MAC bytes array.
 *
 * This test verifies that dm_easy_mesh_t::string_to_macbytes correctly converts a colon-separated MAC address string into its corresponding byte array representation.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 531@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke string_to_macbytes with a valid colon-separated MAC string and verify the resulting bytes | input: mac_str = "aa:bb:cc:dd:ee:ff", output: mac_address_t mac = {0} | The byte array mac should be converted correctly: mac[0]=0xaa, mac[1]=0xbb, mac[2]=0xcc, mac[3]=0xdd, mac[4]=0xee, mac[5]=0xff; ASSERT_EQ checks should pass | Should Pass |
 */
TEST(dm_easy_mesh_t, string_to_macbytes_ColonSeparated)
{
    std::cout << "Entering string_to_macbytes_ColonSeparated test" << std::endl;
    char mac_str[] = "aa:bb:cc:dd:ee:ff";
    mac_address_t mac = {0};
    std::cout << "Invoking string_to_macbytes(\"" << mac_str << "\")" << std::endl;
    dm_easy_mesh_t::string_to_macbytes(mac_str, mac);
    EXPECT_EQ(mac[0], 0xaa);
    EXPECT_EQ(mac[1], 0xbb);
    EXPECT_EQ(mac[2], 0xcc);
    EXPECT_EQ(mac[3], 0xdd);
    EXPECT_EQ(mac[4], 0xee);
    EXPECT_EQ(mac[5], 0xff);
    std::cout << "Retrieved MAC bytes: ";
    for (int i = 0; i < 6; i++)
        std::cout << std::hex << static_cast<int>(mac[i]) << " ";
    std::cout << std::dec << std::endl;
    std::cout << "Exiting string_to_macbytes_ColonSeparated test" << std::endl;
}

/**
 * @brief Validate conversion of MAC string without separators to byte array.
 *
 * This test verifies that the function dm_easy_mesh_t::string_to_macbytes correctly converts a MAC address given as a continuous string ("001122334455") into its corresponding byte array representation. The test checks each byte of the resulting array against the expected hexadecimal values to ensure accurate conversion.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 532@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize test variables mac_str and mac_address_t. | mac_str = "001122334455", mac = {0,0,0,0,0,0} | Variables are properly initialized. | Should be successful |
 * | 02 | Invoke dm_easy_mesh_t::string_to_macbytes to convert string to MAC bytes. | input: mac_str = "001122334455", input: mac (all bytes = 0) | mac array updated with converted MAC bytes based on input string. | Should Pass |
 * | 03 | Verify each element of mac array matches the expected hexadecimal values. | Expected output: mac[0]=0x00, mac[1]=0x11, mac[2]=0x22, mac[3]=0x33, mac[4]=0x44, mac[5]=0x55 | All EXPECT_EQ assertions pass confirming conversion correctness. | Should Pass |
 */
TEST(dm_easy_mesh_t, string_to_macbytes_NoSeparator)
{
    std::cout << "Entering string_to_macbytes_NoSeparator test" << std::endl;
    char mac_str[] = "001122334455";
    mac_address_t mac = {0};
    std::cout << "Invoking string_to_macbytes(\"" << mac_str << "\")" << std::endl;
    dm_easy_mesh_t::string_to_macbytes(mac_str, mac);
    EXPECT_EQ(mac[0], 0x00);
    EXPECT_EQ(mac[1], 0x11);
    EXPECT_EQ(mac[2], 0x22);
    EXPECT_EQ(mac[3], 0x33);
    EXPECT_EQ(mac[4], 0x44);
    EXPECT_EQ(mac[5], 0x55);
    std::cout << "Retrieved MAC bytes: ";
    for (int i = 0; i < 6; i++)
        std::cout << std::hex << static_cast<int>(mac[i]) << " ";
    std::cout << std::dec << std::endl;
    std::cout << "Exiting string_to_macbytes_NoSeparator test" << std::endl;
}

/**
 * @brief Test conversion of an empty string to MAC address bytes
 *
 * This test verifies that the function string_to_macbytes correctly handles an empty string input without causing a crash. It checks that the function execution completes normally even though the input string is empty.@n
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 533@n
 * **Priority:** High@n
 * @n
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * @n
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                        | Test Data                          | Expected Result                                                          | Notes       |
 * | :--------------: | ------------------------------------------------------------------ | ---------------------------------- | ----------------------------------------------------------------------- | ----------- |
 * | 01               | Invoke string_to_macbytes with an empty string                     | mac_str = "", mac = {0,0,0,0,0,0}    | Function completes without crashing; assertion EXPECT_TRUE(true) passes | Should Pass |
 */
TEST(dm_easy_mesh_t, string_to_macbytes_EmptyString)
{
    std::cout << "Entering string_to_macbytes_EmptyString test" << std::endl;
    char mac_str[] = "";
    mac_address_t mac = {0};
    std::cout << "Invoking string_to_macbytes(empty string)" << std::endl;
    dm_easy_mesh_t::string_to_macbytes(mac_str, mac);
    // No crash expected
    EXPECT_TRUE(true);
    std::cout << "Retrieved MAC bytes: ";
    for (int i = 0; i < 6; i++)
        std::cout << static_cast<int>(mac[i]) << " ";
    std::cout << std::endl;
    std::cout << "Exiting string_to_macbytes_EmptyString test" << std::endl;
}

/**
 * @brief Verify that dm_easy_mesh_t::string_to_macbytes handles an invalid MAC address string gracefully
 *
 * This test validates that when an invalid MAC address string ("zz:zz:zz:zz:zz:zz") is provided to the 
 * string_to_macbytes API, the function completes execution without crashing. The output content is 
 * undefined due to the invalid input but the correctness is determined by the absence of a crash and normal function return.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 534@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                     | Test Data                                                       | Expected Result                                                   | Notes         |
 * | :--------------: | --------------------------------------------------------------- | --------------------------------------------------------------- | ----------------------------------------------------------------- | ------------- |
 * | 01               | Call string_to_macbytes with an invalid MAC string               | mac_str = "zz:zz:zz:zz:zz:zz", mac = {0}                         | Function completes without crash; return value is not explicitly checked | Should Pass   |
 */
TEST(dm_easy_mesh_t, string_to_macbytes_InvalidString)
{
    std::cout << "Entering string_to_macbytes_InvalidString test" << std::endl;
    char mac_str[] = "zz:zz:zz:zz:zz:zz";
    mac_address_t mac = {0};
    std::cout << "Invoking string_to_macbytes(\"" << mac_str << "\")" << std::endl;
    dm_easy_mesh_t::string_to_macbytes(mac_str, mac);
    // No crash expected; content is undefined but function completes
    EXPECT_TRUE(true);
    std::cout << "Retrieved MAC bytes after invalid input: ";
    for (int i = 0; i < 6; i++)
        std::cout << static_cast<int>(mac[i]) << " ";
    std::cout << std::endl;
    std::cout << "Exiting string_to_macbytes_InvalidString test" << std::endl;
}

/**
 * @brief Validate that the security mode string for EM_AUTH_OPEN is correctly converted to "OPEN"
 *
 * This test verifies that the dm_easy_mesh_t::securitymode_to_str function properly converts the security mode EM_AUTH_OPEN into the corresponding string "OPEN". The test ensures that the API handles the input, formats the output string correctly, and passes the string comparison check.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 535@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                      | Expected Result                                                         | Notes      |
 * | :--------------: | --------------------------------------------------------------------------- | -------------------------------------------------------------- | ----------------------------------------------------------------------- | ---------- |
 * | 01               | Invoke securitymode_to_str with input EM_AUTH_OPEN and validate output "OPEN" | input1 = EM_AUTH_OPEN, output buffer: sec_str (initialized to 0), size = 64 | sec_str should be equal to "OPEN" as checked by EXPECT_STREQ              | Should Pass |
 */
TEST(dm_easy_mesh_t, securitymode_to_str_Open)
{
    std::cout << "Entering securitymode_to_str_Open test" << std::endl;
    char sec_str[64] = {0};
    std::cout << "Invoking securitymode_to_str(EM_AUTH_OPEN)" << std::endl;
    dm_easy_mesh_t::securitymode_to_str(EM_AUTH_OPEN, sec_str, sizeof(sec_str));
    EXPECT_STREQ(sec_str, "OPEN");
    std::cout << "Retrieved security string: " << sec_str << std::endl;
    std::cout << "Exiting securitymode_to_str_Open test" << std::endl;
}

/**
 * @brief Verifies that the security mode conversion function returns the correct string.
 *
 * This test evaluates whether dm_easy_mesh_t::securitymode_to_str, when provided with the input EM_AUTH_SAE_AKM24, correctly populates the output character array with the expected string "WPA-WPA3-Personal_AKM24". It ensures that the security mode to string conversion logic works as intended.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 536@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke dm_easy_mesh_t::securitymode_to_str with EM_AUTH_SAE_AKM24 and verify output | authMode = EM_AUTH_SAE_AKM24, outputBuffer = sec_str, outputBuffer size = 64, expected string = "WPA-WPA3-Personal_AKM24" | Function correctly converts the security mode to string and EXPECT_STREQ passes | Should Pass |
 */
TEST(dm_easy_mesh_t, securitymode_to_str_WPA_WPA3_AKM24)
{
    std::cout << "Entering securitymode_to_str_WPA_WPA3_AKM24 test" << std::endl;
    char sec_str[64] = {0};
    std::cout << "Invoking securitymode_to_str(EM_AUTH_SAE_AKM24)" << std::endl;
    dm_easy_mesh_t::securitymode_to_str(EM_AUTH_SAE_AKM24, sec_str, sizeof(sec_str));
    EXPECT_STREQ(sec_str, "WPA-WPA3-Personal_AKM24");
    std::cout << "Retrieved security string: " << sec_str << std::endl;
    std::cout << "Exiting securitymode_to_str_WPA_WPA3_AKM24 test" << std::endl;
}

/**
 * @brief Test the behavior of dm_easy_mesh_t::securitymode_to_str when an invalid mode is passed.
 *
 * This test validates that passing an invalid mode value to securitymode_to_str does not alter the security string.
 * It ensures that when an undefined mode is provided, the function retains the original buffer content.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 537@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke dm_easy_mesh_t::securitymode_to_str with an invalid mode | input: mode=999, sec_str initial="UNCHANGED", buffer_size=64 | sec_str remains "UNCHANGED" and EXPECT_STREQ(sec_str, "UNCHANGED") passes | Should Pass |
 */
TEST(dm_easy_mesh_t, securitymode_to_str_InvalidMode)
{
    std::cout << "Entering securitymode_to_str_InvalidMode test" << std::endl;
    char sec_str[64];
    strcpy(sec_str, "UNCHANGED");
    std::cout << "Invoking securitymode_to_str(invalid mode)" << std::endl;
    dm_easy_mesh_t::securitymode_to_str(999, sec_str, sizeof(sec_str));
    EXPECT_STREQ(sec_str, "UNCHANGED");
    std::cout << "Retrieved security string: " << sec_str << std::endl;
    std::cout << "Exiting securitymode_to_str_InvalidMode test" << std::endl;
}

/**
 * @brief Tests the conversion from string "OPEN" to its corresponding security mode value.
 *
 * This test verifies that invoking the str_to_securitymode API with the input "OPEN" correctly updates the mode variable to the predefined EM_AUTH_OPEN value. It ensures that the API processes valid input strings and produces the expected output.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 538@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * |01| Print entering test | None | "Entering str_to_securitymode_Open test" is printed | Should be successful |
 * |02| Initialize mode and security string | mode = 0xFFFF, sec_str = "OPEN" | Mode is initialized to 0xFFFF and sec_str is "OPEN" | Should be successful |
 * |03| Invoke str_to_securitymode API | mode = address of mode, sec_str = "OPEN", len = 4 | mode is updated to EM_AUTH_OPEN and EXPECT_EQ assertion passes | Should Pass |
 * |04| Print retrieved security mode | None | The updated security mode value is printed | Should be successful |
 * |05| Print exiting test | None | "Exiting str_to_securitymode_Open test" is printed | Should be successful |
 */
TEST(dm_easy_mesh_t, str_to_securitymode_Open)
{
    std::cout << "Entering str_to_securitymode_Open test" << std::endl;
    unsigned short mode = 0xFFFF;
    char sec_str[] = "OPEN";
    std::cout << "Invoking str_to_securitymode(\"OPEN\")" << std::endl;
    dm_easy_mesh_t::str_to_securitymode(&mode, sec_str, strlen(sec_str));
    EXPECT_EQ(mode, EM_AUTH_OPEN);
    std::cout << "Retrieved security mode: " << mode << std::endl;
    std::cout << "Exiting str_to_securitymode_Open test" << std::endl;
}

/**
 * @brief Verify that the "WPA-WPA3-Personal_DPP" string is correctly converted to the corresponding security mode.
 *
 * This test case calls the str_to_securitymode API with the input string "WPA-WPA3-Personal_DPP" and verifies that the mode is correctly converted to the enum value EM_AUTH_DPP_AKM. It ensures that the API can handle and correctly process a combination of WPA and WPA3 modes with DPP.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 539@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                              | Test Data                                                              | Expected Result                                  | Notes              |
 * | :--------------: | -------------------------------------------------------- | ---------------------------------------------------------------------- | ------------------------------------------------ | ------------------ |
 * | 01               | Initialize test variables with initial values            | mode = 0xFFFF, sec_str = "WPA-WPA3-Personal_DPP", length = 22            | Variables are correctly initialized             | Should be successful |
 * | 02               | Invoke the str_to_securitymode API with the provided input | mode pointer, sec_str, strlen(sec_str)                                 | mode is updated to EM_AUTH_DPP_AKM                | Should Pass        |
 * | 03               | Verify the mode value using EXPECT_EQ assertion          | Expected mode = EM_AUTH_DPP_AKM                                        | Assertion passes if mode equals EM_AUTH_DPP_AKM   | Should Pass        |
 */
TEST(dm_easy_mesh_t, str_to_securitymode_WPA_WPA3_DPP)
{
    std::cout << "Entering str_to_securitymode_WPA_WPA3_DPP test" << std::endl;
    unsigned short mode = 0xFFFF;
    char sec_str[] = "WPA-WPA3-Personal_DPP";
    std::cout << "Invoking str_to_securitymode(\"WPA-WPA3-Personal_DPP\")" << std::endl;
    dm_easy_mesh_t::str_to_securitymode(&mode, sec_str, strlen(sec_str));
    EXPECT_EQ(mode, EM_AUTH_DPP_AKM);
    std::cout << "Retrieved security mode: " << mode << std::endl;
    std::cout << "Exiting str_to_securitymode_WPA_WPA3_DPP test" << std::endl;
}

/**
 * @brief Verify that str_to_securitymode does not modify the security mode when provided with an invalid string.
 *
 * This test validates that calling dm_easy_mesh_t::str_to_securitymode with an invalid security string leaves the mode variable unchanged.
 * The function is expected not to update the mode if the input string does not correspond to any valid security mode.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 540@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Log entering the test | N/A | "Entering str_to_securitymode_InvalidString test" is printed | Should be successful |
 * | 02 | Initialize mode with a default value | mode = 1234 | mode is set to 1234 | Should be successful |
 * | 03 | Prepare an invalid security string | sec_str = "INVALID_SECURITY", len = 16 | sec_str contains "INVALID_SECURITY" and length is computed correctly | Should be successful |
 * | 04 | Invoke str_to_securitymode API | mode = 1234, sec_str = "INVALID_SECURITY", len = 16 | Mode remains unchanged (1234) and assertion passes | Should Pass |
 * | 05 | Log the retrieved security mode | mode = 1234 | "Retrieved security mode (unchanged): 1234" is printed | Should be successful |
 * | 06 | Log exiting the test | N/A | "Exiting str_to_securitymode_InvalidString test" is printed | Should be successful |
 */
TEST(dm_easy_mesh_t, str_to_securitymode_InvalidString)
{
    std::cout << "Entering str_to_securitymode_InvalidString test" << std::endl;
    unsigned short mode = 1234;
    char sec_str[] = "INVALID_SECURITY";
    std::cout << "Invoking str_to_securitymode(\"INVALID_SECURITY\")" << std::endl;
    dm_easy_mesh_t::str_to_securitymode(&mode, sec_str, strlen(sec_str));
    EXPECT_EQ(mode, 1234);
    std::cout << "Retrieved security mode (unchanged): " << mode << std::endl;
    std::cout << "Exiting str_to_securitymode_InvalidString test" << std::endl;
}

/**
 * @brief Verify conversion of a valid input byte array to its corresponding hex string
 *
 * This test validates that the dm_easy_mesh_t::hex API correctly converts the provided byte array
 * {0x12, 0xAB, 0x00} to its lowercase hexadecimal string representation "12ab00". It ensures that the
 * API returns a non-null pointer and that the converted string matches the expected output.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 541@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                               | Test Data                                                           | Expected Result                                                             | Notes       |
 * | :--------------: | --------------------------------------------------------- | ------------------------------------------------------------------- | --------------------------------------------------------------------------- | ----------- |
 * | 01               | Call dm_easy_mesh_t::hex API with valid parameters        | in_len = 3, input = {0x12, 0xAB, 0x00}, out_len = 16, output buffer allocated | Return value is not null; output string equals "12ab00" as verified by EXPECT_NE and EXPECT_STREQ | Should Pass |
 */
TEST(dm_easy_mesh_t, hex_ValidInput)
{
    std::cout << "Entering hex_ValidInput test" << std::endl;
    unsigned char input[] = {0x12, 0xAB, 0x00};
    char output[16];
    std::cout << "Invoking hex(in_len=3, out_len=16)" << std::endl;
    char *ret = dm_easy_mesh_t::hex(3, input, sizeof(output), output);
    EXPECT_NE(ret, nullptr);
    EXPECT_STREQ(output, "12ab00");
    std::cout << "Hex output: " << output << std::endl;
    std::cout << "Exiting hex_ValidInput test" << std::endl;
}

/**
 * @brief Test dm_easy_mesh_t::hex API with zero input length to verify proper handling of empty input.
 *
 * This test verifies that invoking the hex function with an input length of 0 returns a valid pointer and produces an empty string as output. It ensures that the API correctly handles the edge case where there is no valid input data.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 542@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Invoke hex() API with input length of 0 to generate an empty output | in_len = 0, input[0] = 0, output buffer size = 4 | Return pointer is valid and output string equals empty | Should Pass |
 */
TEST(dm_easy_mesh_t, hex_ZeroLengthInput)
{
    std::cout << "Entering hex_ZeroLengthInput test" << std::endl;
    unsigned char input[1] = {0};
    char output[4];
    std::cout << "Invoking hex(in_len=0)" << std::endl;
    char *ret = dm_easy_mesh_t::hex(0, input, sizeof(output), output);
    EXPECT_NE(ret, nullptr);
    EXPECT_STREQ(output, "");
    std::cout << "Hex output (empty): \"" << output << "\"" << std::endl;
    std::cout << "Exiting hex_ZeroLengthInput test" << std::endl;
}

/**
 * @brief Validate hex API behavior when provided with a NULL output buffer
 *
 * This test case verifies that the hex API correctly handles the case where the output buffer is passed as NULL.
 * The test ensures that under undefined behavior (NULL output buffer), the API returns a NULL pointer.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 543@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                               | Test Data                                                   | Expected Result                                         | Notes        |
 * | :--------------: | ------------------------------------------------------------------------- | ----------------------------------------------------------- | ------------------------------------------------------- | ------------ |
 * | 01               | Invoke the hex API with a valid input array and a NULL output buffer      | input_len = 2, input = {0x11, 0x22}, capacity = 10, output = nullptr | API returns a NULL pointer as verified by EXPECT_EQ(ret, nullptr) | Should Pass  |
 */
TEST(dm_easy_mesh_t, hex_NullOutputBuffer)
{
    std::cout << "Entering hex_NullOutputBuffer test" << std::endl;
    unsigned char input[] = {0x11, 0x22};
    std::cout << "Invoking hex with NULL output buffer (undefined behavior)" << std::endl;
    char *ret = dm_easy_mesh_t::hex(2, input, 10, nullptr);
	EXPECT_EQ(ret, nullptr);
    std::cout << "Exiting hex_NullOutputBuffer test" << std::endl;
}

/**
 * @brief Verify valid hexadecimal string conversion to byte array
 *
 * This test checks that the dm_easy_mesh_t::unhex function correctly converts a valid hexadecimal string ("12ab00") into its corresponding byte array output. The test validates that the API returns a non-null pointer and that the converted bytes are equal to 0x12, 0xAB, and 0x00 respectively. This is essential to ensure the API's correct functionality when provided with valid input data.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 544@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize input and output buffers | input = "12ab00", output[8] = {0} | Buffers are properly allocated and zero-initialized | Should be successful |
 * | 02 | Invoke dm_easy_mesh_t::unhex API with valid input | in_len = 6, input = "12ab00", out_len = 8, output pointer | Returns a non-null pointer indicating successful conversion | Should Pass |
 * | 03 | Validate the conversion output bytes | output[0] = expected 0x12, output[1] = expected 0xAB, output[2] = expected 0x00 | Converted bytes match the expected hexadecimal values | Should Pass |
 */
TEST(dm_easy_mesh_t, unhex_ValidInput)
{
    std::cout << "Entering unhex_ValidInput test" << std::endl;
    char input[] = "12ab00";
    unsigned char output[8] = {0};
    std::cout << "Invoking unhex(in_len=6, out_len=8)" << std::endl;
    unsigned char *ret = dm_easy_mesh_t::unhex(strlen(input), input, sizeof(output), output);
    EXPECT_NE(ret, nullptr);
    EXPECT_EQ(output[0], 0x12);
    EXPECT_EQ(output[1], 0xAB);
    EXPECT_EQ(output[2], 0x00);
    std::cout << "Unhex output bytes: "
              << std::hex
              << static_cast<int>(output[0]) << " "
              << static_cast<int>(output[1]) << " "
              << static_cast<int>(output[2]) << std::dec << std::endl;
    std::cout << "Exiting unhex_ValidInput test" << std::endl;
}

/**
 * @brief Validate unhex conversion with lowercase hexadecimal string
 *
 * This test verifies that the unhex function correctly converts a lowercase hexadecimal
 * string into its corresponding byte array. It ensures that the function returns a non-null pointer
 * and that the output bytes match the expected hexadecimal values.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 545@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                | Test Data                                        | Expected Result                                                                        | Notes      |
 * | :--------------: | ------------------------------------------ | ------------------------------------------------ | -------------------------------------------------------------------------------------- | ---------- |
 * | 01               | Invoke unhex with input "deadbe"           | input = "deadbe", output buffer size = 4         | Returns non-null pointer; output[0]=0xDE, output[1]=0xAD, output[2]=0xBE; values pass check | Should Pass|
 */
TEST(dm_easy_mesh_t, unhex_LowercaseHex)
{
    std::cout << "Entering unhex_LowercaseHex test" << std::endl;
    char input[] = "deadbe";
    unsigned char output[4] = {0};
    std::cout << "Invoking unhex(\"deadbe\")" << std::endl;
    unsigned char *ret = dm_easy_mesh_t::unhex(strlen(input), input, sizeof(output), output);
    EXPECT_NE(ret, nullptr);
    EXPECT_EQ(output[0], 0xDE);
    EXPECT_EQ(output[1], 0xAD);
    EXPECT_EQ(output[2], 0xBE);
    std::cout << "Unhex output bytes: "
              << std::hex
              << static_cast<int>(output[0]) << " "
              << static_cast<int>(output[1]) << " "
              << static_cast<int>(output[2]) << std::dec << std::endl;
    std::cout << "Exiting unhex_LowercaseHex test" << std::endl;
}

/**
 * @brief Test for unhex function with an odd length input verifying only complete hex pairs are processed
 *
 * This test passes an odd length string "abc" to the unhex function to ensure that it processes only the first complete hex pair.@n
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 546@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                              | Test Data                                                      | Expected Result                                      | Notes           |
 * | :--------------: | ---------------------------------------------------------------------------------------- | -------------------------------------------------------------- | ---------------------------------------------------- | --------------- |
 * | 01               | Print entry message "Entering unhex_OddLengthInput test"                                 | -                                                              | Message printed to standard output                   | Should be successful |
 * | 02               | Initialize input string with "abc" (odd length) and an output buffer of size 2             | input = abc, output buffer size = 2                             | Variables initialized correctly                      | Should be successful |
 * | 03               | Print message before API call "Invoking unhex with odd input length"                       | -                                                              | Message printed to standard output                   | Should be successful |
 * | 04               | Invoke dm_easy_mesh_t::unhex with input length, input, output size, and output buffer         | input length = 3, input = abc, output buffer size = 2, output = {0} | Return pointer is not nullptr                         | Should Pass     |
 * | 05               | Verify that the first byte of the output buffer equals 0xAB                               | output[0] expected = 0xAB                                        | Assertion passes (output[0] equals 0xAB)               | Should Pass     |
 * | 06               | Print the hex value of the first output byte                                               | output[0] value printed in hex                                  | Output correctly printed in hexadecimal              | Should be successful |
 * | 07               | Print exit message "Exiting unhex_OddLengthInput test"                                     | -                                                              | Message printed to standard output                   | Should be successful |
 */
TEST(dm_easy_mesh_t, unhex_OddLengthInput)
{
    std::cout << "Entering unhex_OddLengthInput test" << std::endl;
    char input[] = "abc"; // odd length
    unsigned char output[2] = {0};
    std::cout << "Invoking unhex with odd input length" << std::endl;
    unsigned char *ret = dm_easy_mesh_t::unhex(strlen(input), input, sizeof(output), output);
    EXPECT_NE(ret, nullptr);
    EXPECT_EQ(output[0], 0xAB); // only first byte processed
    std::cout << "Unhex output byte: "
              << std::hex << static_cast<int>(output[0]) << std::dec << std::endl;
    std::cout << "Exiting unhex_OddLengthInput test" << std::endl;
}

/**
 * @brief Verify that unhex returns nullptr when provided with a NULL input pointer.
 *
 * This test case verifies that the dm_easy_mesh_t::unhex API correctly handles a NULL input string by returning a nullptr. 
 * The test ensures that under these invalid input conditions, the function does not attempt to process the input and signals the error as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 547@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                        | Test Data                                            | Expected Result                                                   | Notes        |
 * | :--------------: | -------------------------------------------------- | ---------------------------------------------------- | ----------------------------------------------------------------- | ------------ |
 * | 01               | Call dm_easy_mesh_t::unhex with a NULL input pointer | len = 4, hex = nullptr, outSize = sizeof(output), output = output | Function returns nullptr and assertion EXPECT_EQ(ret, nullptr) passes | Should Pass  |
 */
TEST(dm_easy_mesh_t, unhex_NullInputString)
{
    std::cout << "Entering unhex_NullInputString test" << std::endl;
    unsigned char output[2];
    std::cout << "Invoking unhex with NULL input pointer" << std::endl;
    unsigned char *ret = dm_easy_mesh_t::unhex(4, nullptr, sizeof(output), output);
	EXPECT_EQ(ret, nullptr);
    std::cout << "Exiting unhex_NullInputString test" << std::endl;
}

/**
 * @brief Verify that dm_easy_mesh_t::unhex correctly decodes uppercase hexadecimal characters.
 *
 * This test verifies if the unhex function decodes an uppercase hexadecimal string "AABBCC" into its corresponding byte array {0xAA, 0xBB, 0xCC}. It is critical to ensure that the function handles uppercase hex characters correctly for proper data encoding.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 548@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                          | Test Data                                          | Expected Result                                                    | Notes       |
 * | :--------------: | -------------------------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------------ | ----------- |
 * | 01               | Invoke unhex with an uppercase hex string "AABBCC" and decode bytes. | input = "AABBCC", output array size = 3, expected output = 0xAA,0xBB,0xCC | Function returns a pointer and populates the output array with {0xAA, 0xBB, 0xCC}. | Should Pass |
 */
TEST(dm_easy_mesh_t, unhex_UppercaseHexCharacters)
{
    std::cout << "Entering unhex_UppercaseHexCharacters test" << std::endl;
    char input[] = "AABBCC";
    unsigned char output[3] = {0};
    std::cout << "Invoking unhex with uppercase hex input: " << input << std::endl;
    unsigned char *ret = dm_easy_mesh_t::unhex(strlen(input), input, sizeof(output), output);
    // Expected behavior: should decode correctly to {0xAA, 0xBB, 0xCC}
    // Current implementation fails, so this EXPECT will fail.
    EXPECT_EQ(output[0], 0xAA);
    EXPECT_EQ(output[1], 0xBB);
    EXPECT_EQ(output[2], 0xCC);
    std::cout << "Unhex output bytes: "
              << std::hex
              << static_cast<int>(output[0]) << " "
              << static_cast<int>(output[1]) << " "
              << static_cast<int>(output[2]) << std::dec << std::endl;
    std::cout << "Exiting unhex_UppercaseHexCharacters test" << std::endl;
}

/**
 * @brief Checks for the presence of at least one associated STA in a positive scenario.
 *
 * This test verifies that once an associated STA is added to a dm_easy_mesh_t instance,
 * the API has_at_least_one_associated_sta returns true. The test initializes the mesh object,
 * creates and populates a STA information structure, adds the STA via put_sta_info, and finally
 * checks that the mesh successfully recognizes the associated STA.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 549@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                          | Test Data                                                                                                                                                                                                       | Expected Result                                               | Notes        |
 * | :--------------: | ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------- | ------------ |
 * | 01               | Initialize the dm_easy_mesh_t object by invoking the init() method.                                  | Instance: mesh, Method: mesh.init(), Input: None                                                                                                                                                                | Mesh instance is correctly initialized.                      | Should be successful |
 * | 02               | Create and populate the STA info structure, then invoke put_sta_info to add an associated STA.         | STA info: sta_info with sta_mac = 0x00,0x11,0x22,0x33,0x44,0x55; bssid = 0x66,0x77,0x88,0x99,0xAA,0xBB; radio = 0xCC,0xDD,0xEE,0xFF,0x00,0x11; associated = true; Method: mesh.put_sta_info(&sta_info, em_target_sta_map_consolidated) | STA info is successfully added to the mesh.                   | Should Pass  |
 * | 03               | Invoke has_at_least_one_associated_sta and verify that it returns true via the EXPECT_TRUE assertion. | Method: mesh.has_at_least_one_associated_sta(), Expected return value: true                                                                                                                                       | API returns true indicating at least one associated STA exists. | Should Pass  |
 */
TEST(dm_easy_mesh_t, has_at_least_one_associated_sta_Positive)
{
    std::cout << "Entering has_at_least_one_associated_sta_Positive test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    // Create STA info
    em_sta_info_t sta_info = {};
    unsigned char sta_mac[6] = {0x00,0x11,0x22,0x33,0x44,0x55};
    unsigned char bssid[6]   = {0x66,0x77,0x88,0x99,0xAA,0xBB};
    unsigned char radio[6]   = {0xCC,0xDD,0xEE,0xFF,0x00,0x11};
    memcpy(sta_info.id, sta_mac, 6);
    memcpy(sta_info.bssid, bssid, 6);
    memcpy(sta_info.radiomac, radio, 6);
    sta_info.associated = true;
    std::cout << "Invoking put_sta_info to add an associated STA" << std::endl;
	mesh.put_sta_info(&sta_info, em_target_sta_map_consolidated);
    //mesh.put_sta_info(&sta_info, em_target_sta_map_assoc);
    std::cout << "Invoking has_at_least_one_associated_sta" << std::endl;
    bool result = mesh.has_at_least_one_associated_sta();
    std::cout << "Result: " << result << std::endl;
    EXPECT_TRUE(result);
    mesh.deinit();
    std::cout << "Exiting has_at_least_one_associated_sta_Positive test" << std::endl;
}

/**
 * @brief Verify that the mesh does not report any associated STA when only non-associated STA info is provided
 *
 * This test verifies that when a non-associated STA is added via put_sta_info, the mesh's method has_at_least_one_associated_sta correctly returns false. The objective is to ensure that the API does not erroneously report an associated station when none exists.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 550@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result |Notes |
 * | :--------------: | ----------- | --------- | ------------- | ----- |
 * | 01 | Invoke mesh.init() to initialize the mesh object | No input parameters | Mesh is initialized successfully | Should Pass |
 * | 02 | Prepare a STA info structure with STA MAC, BSSID, Radio MAC and associated flag set to false | sta_mac = 0xAA,0xBB,0xCC,0xDD,0xEE,0xFF; bssid = 0x11,0x22,0x33,0x44,0x55,0x66; radio = 0x77,0x88,0x99,0xAA,0xBB,0xCC; associated = false | STA info structure is populated correctly | Should be successful |
 * | 03 | Invoke put_sta_info to add the non-associated STA to the mesh | Input: pointer to sta_info, target = em_target_sta_map_assoc | STA info is added to the mesh without marking it as associated | Should Pass |
 * | 04 | Invoke has_at_least_one_associated_sta to check for any associated STA | No input parameters; output: result from API call | API returns false indicating no associated STA | Should Fail |
 */
TEST(dm_easy_mesh_t, has_at_least_one_associated_sta_Negative)
{
    std::cout << "Entering has_at_least_one_associated_sta_Negative test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    // Create STA info that is NOT associated
    em_sta_info_t sta_info = {};
    unsigned char sta_mac[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    unsigned char bssid[6]   = {0x11,0x22,0x33,0x44,0x55,0x66};
    unsigned char radio[6]   = {0x77,0x88,0x99,0xAA,0xBB,0xCC};
    memcpy(sta_info.id, sta_mac, 6);
    memcpy(sta_info.bssid, bssid, 6);
    memcpy(sta_info.radiomac, radio, 6);
    sta_info.associated = false;
    std::cout << "Invoking put_sta_info to add a non-associated STA" << std::endl;
    mesh.put_sta_info(&sta_info, em_target_sta_map_assoc);
    std::cout << "Invoking has_at_least_one_associated_sta" << std::endl;
    bool result = mesh.has_at_least_one_associated_sta();
    std::cout << "Result: " << result << std::endl;
    EXPECT_FALSE(result);
    mesh.deinit();
    std::cout << "Exiting has_at_least_one_associated_sta_Negative test" << std::endl;
}

/**
 * @brief Validate that the has_at_least_one_associated_sta method returns false when invoked on an empty map
 *
 * This test creates an instance of dm_easy_mesh_t, initializes it, and then invokes the has_at_least_one_associated_sta method.
 * The objective is to confirm that no associated station exists in an empty map, ensuring that the API returns false as expected.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 551@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                           | Test Data                                                     | Expected Result                                                   | Notes           |
 * | :--------------: | ------------------------------------------------------------------------------------- | ------------------------------------------------------------- | ----------------------------------------------------------------- | --------------- |
 * | 01               | Create a dm_easy_mesh_t instance and initialize it                                     | mesh object created, call: mesh.init()                         | Mesh is initialized to an empty state                             | Should be successful |
 * | 02               | Invoke has_at_least_one_associated_sta on the empty map and verify that it returns false   | call: result = mesh.has_at_least_one_associated_sta()           | Function returns false and EXPECT_FALSE(result) assertion passes  | Should Pass     |
 */
TEST(dm_easy_mesh_t, has_at_least_one_associated_sta_EmptyMap)
{
    std::cout << "Entering has_at_least_one_associated_sta_EmptyMap test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    std::cout << "Invoking has_at_least_one_associated_sta on empty map" << std::endl;
    bool result = mesh.has_at_least_one_associated_sta();
    std::cout << "Result: " << result << std::endl;
    EXPECT_FALSE(result);
    mesh.deinit();
    std::cout << "Exiting has_at_least_one_associated_sta_EmptyMap test" << std::endl;
}

/**
 * @brief Verifies that the dm_easy_mesh_t configuration is correctly populated and printed.
 *
 * This test sets up a dm_easy_mesh_t instance with predefined network, SSID, radio, and BSS data, then calls the print_config method and validates that the data is correctly stored and printed. This ensures that the print_config function outputs the configuration without altering the internal state.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 552@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t instance with network, SSIDs, radios, and BSS configuration | network id = "TestNetwork", SSIDs = "SSID_1, SSID_2", radio transmit_power_limit = 20, band = em_freq_band_24, radio mac = {0x00,0x11,0x22,0x33,0x44,0x55}, BSS mac = {0x66,0x77,0x88,0x99,0xAA,0xBB} | Mesh instance is properly populated with provided configuration | Should be successful |
 * | 02 | Invoke print_config method to output the configuration | Method call: mesh.print_config() | Console outputs mesh configuration details | Should Pass |
 * | 03 | Check configuration values using memory assertions | EXPECT_STREQ for network id and SSIDs; EXPECT_EQ for radio transmit_power_limit and band | All assertions pass confirming correct configuration | Should Pass |
 */
TEST(dm_easy_mesh_t, print_config_Positive)
{
    std::cout << "Entering print_config_Positive test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    // Populate network info
    strcpy(mesh.m_network.m_net_info.id, "TestNetwork");
    // Populate SSIDs
    mesh.m_num_net_ssids = 2;
    strcpy(mesh.m_network_ssid[0].m_network_ssid_info.ssid, "SSID_1");
    strcpy(mesh.m_network_ssid[1].m_network_ssid_info.ssid, "SSID_2");
    // Populate radios
    mesh.m_num_radios = 1;
    unsigned char radio_mac[6] = {0x00,0x11,0x22,0x33,0x44,0x55};
    memcpy(mesh.m_radio[0].m_radio_info.intf.mac, radio_mac, 6);
    mesh.m_radio[0].m_radio_info.transmit_power_limit = 20;
    mesh.m_radio[0].m_radio_info.band = em_freq_band_24;
    // Populate BSS
    mesh.m_num_bss = 1;
    unsigned char bss_mac[6] = {0x66,0x77,0x88,0x99,0xAA,0xBB};
    memcpy(mesh.m_bss[0].m_bss_info.ruid.mac, radio_mac, 6);
    memcpy(mesh.m_bss[0].m_bss_info.bssid.mac, bss_mac, 6);
    std::cout << "Invoking print_config" << std::endl;
    mesh.print_config();
    // Simple memory assertions
    EXPECT_STREQ(mesh.m_network.m_net_info.id, "TestNetwork");
    EXPECT_STREQ(mesh.m_network_ssid[0].m_network_ssid_info.ssid, "SSID_1");
    EXPECT_STREQ(mesh.m_network_ssid[1].m_network_ssid_info.ssid, "SSID_2");
    EXPECT_EQ(mesh.m_radio[0].m_radio_info.transmit_power_limit, 20);
    EXPECT_EQ(mesh.m_radio[0].m_radio_info.band, em_freq_band_24);
    mesh.deinit();
    std::cout << "Exiting print_config_Positive test" << std::endl;
}

/**
 * @brief Verify that print_config handles empty configuration correctly
 *
 * This test verifies the negative scenario where the mesh configuration is empty.
 * The mesh object is initialized, its network ID is set to an empty string, and the
 * counts for SSIDs, radios, and BSS are set to zero. Then, print_config is invoked,
 * and the test asserts that the configuration remains empty, ensuring that the API
 * correctly handles a scenario with no configuration data.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 553@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize mesh object and invoke init() method | dm_easy_mesh_t instance creation; call init() | Mesh object is successfully initialized | Should be successful |
 * | 02 | Set empty network configuration by clearing network ID and setting counts to zero | network id = "", m_num_net_ssids = 0, m_num_radios = 0, m_num_bss = 0 | Mesh configuration updated to empty values | Should be successful |
 * | 03 | Invoke print_config() on the mesh with empty configuration | Call print_config() on the mesh instance | Function executes without error and processes empty configuration | Should Fail |
 * | 04 | Verify that the mesh configuration remains empty using assertions | EXPECT_STREQ(mesh.m_network.m_net_info.id, ""), EXPECT_EQ(mesh.m_num_net_ssids, 0), EXPECT_EQ(mesh.m_num_radios, 0), EXPECT_EQ(mesh.m_num_bss, 0) | All assertion checks pass confirming the empty configuration | Should be successful |
 */
TEST(dm_easy_mesh_t, print_config_Negative)
{
    std::cout << "Entering print_config_Negative test" << std::endl;
    dm_easy_mesh_t mesh;
    mesh.init();
    // Leave network id empty
    strcpy(mesh.m_network.m_net_info.id, "");
    // No SSIDs, no radios, no BSS
    mesh.m_num_net_ssids = 0;
    mesh.m_num_radios = 0;
    mesh.m_num_bss = 0;
    std::cout << "Invoking print_config with empty data" << std::endl;
    mesh.print_config();
    // Check that empty values exist
    EXPECT_STREQ(mesh.m_network.m_net_info.id, "");
    EXPECT_EQ(mesh.m_num_net_ssids, 0);
    EXPECT_EQ(mesh.m_num_radios, 0);
    EXPECT_EQ(mesh.m_num_bss, 0);
    mesh.deinit();
    std::cout << "Exiting print_config_Negative test" << std::endl;
}

/**
 * @brief Verify that op class list is printed correctly and memory state remains valid
 *
 * This test initializes an instance of dm_easy_mesh_t, populates its op class list with two entries using sample data, and then invokes the print_op_class_list API. The test validates that the memory fields are correctly populated by verifying the values via assertions.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 554@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create a dm_easy_mesh_t instance and initialize it using init() | Instance created: dm; Method invoked: dm.init() | dm instance is initialized successfully | Should be successful |
 * | 02 | Populate first op class entry with predefined MAC address and attributes | m_num_opclass = 2, m_op_class[0].m_op_class_info.id.ruid = {0x00,0x11,0x22,0x33,0x44,0x55}, type = em_op_class_type_current, op_class = 6, channels[0] = 36 | First op class entry is populated with correct values | Should be successful |
 * | 03 | Populate second op class entry with predefined MAC address and attributes | m_op_class[1].m_op_class_info.id.ruid = {0x66,0x77,0x88,0x99,0xAA,0xBB}, type = em_op_class_type_capability, op_class = 12, channels[0] = 52 | Second op class entry is populated with correct values | Should be successful |
 * | 04 | Invoke print_op_class_list API function with the dm instance pointer | Input: &dm; (function call: dm_easy_mesh_t::print_op_class_list(&dm)) | op class list is printed to console without errors | Should Pass |
 * | 05 | Validate the memory fields with assertion checks | Expected: m_num_opclass = 2; for first entry: type = em_op_class_type_current, op_class = 6, channels[0] = 36; for second entry: type = em_op_class_type_capability, op_class = 12, channels[0] = 52 | All assertions pass confirming that memory values match expected results | Should Pass |
 */
TEST(dm_easy_mesh_t, print_op_class_list_Positive)
{
    std::cout << "Entering print_op_class_list_Positive test" << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    // Populate OpClass list
    dm.m_num_opclass = 2;
    // OpClass 0
    unsigned char mac0[6] = {0x00,0x11,0x22,0x33,0x44,0x55};
    memcpy(dm.m_op_class[0].m_op_class_info.id.ruid, mac0, 6);
    dm.m_op_class[0].m_op_class_info.id.type = em_op_class_type_current;
    dm.m_op_class[0].m_op_class_info.id.op_class = 6;
    dm.m_op_class[0].m_op_class_info.op_class = 6;
    dm.m_op_class[0].m_op_class_info.channels[0] = 36;
    // OpClass 1
    unsigned char mac1[6] = {0x66,0x77,0x88,0x99,0xAA,0xBB};
    memcpy(dm.m_op_class[1].m_op_class_info.id.ruid, mac1, 6);
    dm.m_op_class[1].m_op_class_info.id.type = em_op_class_type_capability;
    dm.m_op_class[1].m_op_class_info.id.op_class = 12;
    dm.m_op_class[1].m_op_class_info.op_class = 12;
    dm.m_op_class[1].m_op_class_info.channels[0] = 52;
    std::cout << "Invoking print_op_class_list" << std::endl;
    dm_easy_mesh_t::print_op_class_list(&dm);
    // Assertions on memory values
    EXPECT_EQ(dm.m_num_opclass, 2);
    EXPECT_EQ(dm.m_op_class[0].m_op_class_info.id.type, em_op_class_type_current);
    EXPECT_EQ(dm.m_op_class[0].m_op_class_info.op_class, 6);
    EXPECT_EQ(dm.m_op_class[0].m_op_class_info.channels[0], 36);
    EXPECT_EQ(dm.m_op_class[1].m_op_class_info.id.type, em_op_class_type_capability);
    EXPECT_EQ(dm.m_op_class[1].m_op_class_info.op_class, 12);
    EXPECT_EQ(dm.m_op_class[1].m_op_class_info.channels[0], 52);
    dm.deinit();
    std::cout << "Exiting print_op_class_list_Positive test" << std::endl;
}

/**
 * @brief Validate print_op_class_list handles empty operator class list
 *
 * This test verifies that when no operator classes are provided (i.e., m_num_opclass is 0), the print_op_class_list API correctly processes an empty list without altering the state of the dm_easy_mesh_t object. This is important to ensure that the API gracefully handles empty inputs.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 555@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object and set the number of operator classes to 0 | dm = instance of dm_easy_mesh_t, m_num_opclass set to 0 | dm_easy_mesh_t object is initialized with m_num_opclass equal to 0 | Should be successful |
 * | 02 | Invoke print_op_class_list API and verify that m_num_opclass remains unchanged | Call API: dm_easy_mesh_t::print_op_class_list(&dm), input dm with m_num_opclass = 0, output m_num_opclass remains 0 | API call completes without error and m_num_opclass remains 0, as confirmed by EXPECT_EQ | Should Pass |
 */
TEST(dm_easy_mesh_t, print_op_class_list_EmptyList)
{
    std::cout << "Entering print_op_class_list_EmptyList test" << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    dm.m_num_opclass = 0;
    std::cout << "Invoking print_op_class_list with empty list" << std::endl;
    dm_easy_mesh_t::print_op_class_list(&dm);
    EXPECT_EQ(dm.m_num_opclass, 0);
    dm.deinit();
    std::cout << "Exiting print_op_class_list_EmptyList test" << std::endl;
}

/**
 * @brief Verify that put_sta_info correctly inserts STA info into the Association Map
 *
 * This test verifies that the dm_easy_mesh_t API correctly handles the insertion of station information into the association map.
 * The test populates an em_sta_info_t structure with MAC address, BSSID, Radio MAC, and sets the associated flag to true, then it calls
 * the put_sta_info API to insert the STA info. Afterwards, the test retrieves the first station info item from the association map
 * and asserts that it is not null and that the associated flag is true.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 556@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:** 
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object and call init() method | dm_easy_mesh_t instance; No additional parameters | Instance is initialized successfully | Should be successful |
 * | 02 | Populate em_sta_info_t structure with MAC, BSSID, Radio MAC and set associated flag to true | mac = 00,11,22,33,44,55; bssid = 66,77,88,99,AA,BB; radio = CC,DD,EE,FF,00,11; associated = true | Structure is correctly populated with the given values | Should be successful |
 * | 03 | Invoke put_sta_info API with the prepared sta_info and target mode em_target_sta_map_assoc | sta_info pointer with populated values; target = em_target_sta_map_assoc | STA info is inserted into the association map | Should Pass |
 * | 04 | Retrieve the first STA info from the association map using get_first_sta_info | target = em_target_sta_map_assoc | Retrieved STA info is not nullptr | Should Pass |
 * | 05 | Verify that the retrieved STA info has the associated flag set to true | retrieved->associated value | retrieved->associated equals true | Should Pass |
 */
TEST(dm_easy_mesh_t, put_sta_info_AssocMap_Positive)
{
    std::cout << "Entering put_sta_info_AssocMap_Positive test" << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_sta_info_t sta_info;
    unsigned char mac[6] = {0x00,0x11,0x22,0x33,0x44,0x55};
    unsigned char bssid[6] = {0x66,0x77,0x88,0x99,0xAA,0xBB};
    unsigned char radio[6] = {0xCC,0xDD,0xEE,0xFF,0x00,0x11};
    memcpy(sta_info.id, mac, 6);
    memcpy(sta_info.bssid, bssid, 6);
    memcpy(sta_info.radiomac, radio, 6);
    sta_info.associated = true;
    std::cout << "Invoking put_sta_info on Assoc Map" << std::endl;
    dm.put_sta_info(&sta_info, em_target_sta_map_assoc);
    // Retrieve inserted STA info
    em_sta_info_t* retrieved = dm.get_first_sta_info(em_target_sta_map_assoc);
    EXPECT_NE(retrieved, nullptr);
    EXPECT_TRUE(retrieved->associated);
    std::cout << "Retrieved STA associated=" << retrieved->associated << std::endl;
    dm.deinit();   
    std::cout << "Exiting put_sta_info_AssocMap_Positive test" << std::endl;
}

/**
 * @brief Verify that the put_sta_info API correctly inserts station info into the consolidated map in a positive scenario
 *
 * This test verifies that the dm_easy_mesh_t::put_sta_info method successfully adds a station information structure into the consolidated map. After insertion, the test retrieves the station info using get_first_sta_info to ensure that the added information matches the expected values, particularly that the associated flag is false.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 557@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize the dm_easy_mesh_t object and invoke init() | dm_easy_mesh_t object initialized with no specific input parameters | Object is successfully initialized | Should be successful |
 * | 02 | Set up the sta_info structure with MAC, BSSID, radio MAC addresses and associated flag | sta_info.id = {0x12,0x34,0x56,0x78,0x9A,0xBC}, sta_info.bssid = {0xDE,0xAD,0xBE,0xEF,0x01,0x23}, sta_info.radiomac = {0x45,0x67,0x89,0xAB,0xCD,0xEF}, sta_info.associated = false | sta_info is correctly populated with the given values | Should be successful |
 * | 03 | Call the put_sta_info API on the consolidated map | API: put_sta_info, input: pointer to sta_info, target: em_target_sta_map_consolidated | Station information is inserted successfully into the consolidated map | Should Pass |
 * | 04 | Retrieve the station info using get_first_sta_info and validate the result | API: get_first_sta_info, input: em_target_sta_map_consolidated, output: pointer to sta_info | Returned pointer is not null and sta_info.associated is false | Should Pass |
 * | 05 | Verify assertions using EXPECT_NE and EXPECT_FALSE | API output from get_first_sta_info compared with expected non-null pointer and associated flag false | EXPECT_NE confirms non-null pointer, EXPECT_FALSE confirms associated flag is false | Should be successful |
 */
TEST(dm_easy_mesh_t, put_sta_info_ConsolidatedMap_Positive)
{
    std::cout << "Entering put_sta_info_ConsolidatedMap_Positive test" << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_sta_info_t sta_info;
    unsigned char mac[6] = {0x12,0x34,0x56,0x78,0x9A,0xBC};
    unsigned char bssid[6] = {0xDE,0xAD,0xBE,0xEF,0x01,0x23};
    unsigned char radio[6] = {0x45,0x67,0x89,0xAB,0xCD,0xEF};
    memcpy(sta_info.id, mac, 6);
    memcpy(sta_info.bssid, bssid, 6);
    memcpy(sta_info.radiomac, radio, 6);
    sta_info.associated = false;
    std::cout << "Invoking put_sta_info on Consolidated Map" << std::endl;
    dm.put_sta_info(&sta_info, em_target_sta_map_consolidated);
    em_sta_info_t* retrieved = dm.get_first_sta_info(em_target_sta_map_consolidated);
    EXPECT_NE(retrieved, nullptr);
    EXPECT_FALSE(retrieved->associated);
    std::cout << "Retrieved STA associated=" << retrieved->associated << std::endl;
    dm.deinit();
    std::cout << "Exiting put_sta_info_ConsolidatedMap_Positive test" << std::endl;
}

/**
 * @brief Validate that the put_sta_info API rejects duplicate STA insertions.
 *
 * This test verifies that when the same STA information is added twice using the put_sta_info API,
 * the duplicate entry is not inserted, and only one valid STA entry remains in the system. It ensures
 * that the internal data structure does not accept duplicate records.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 558@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                       | Test Data                                                                                                                                       | Expected Result                                                                                                 | Notes               |
 * | :--------------: | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------- |
 * | 01               | Initialize the dm object and configure the sta_info structure with valid values     | input: sta_info.id = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF}, sta_info.bssid = {0x11,0x22,0x33,0x44,0x55,0x66}, sta_info.radiomac = {0x77,0x88,0x99,0x00,0x11,0x22}, sta_info.associated = true; output: N/A | dm object is properly initialized and sta_info is correctly populated                                           | Should be successful |
 * | 02               | Call put_sta_info for the first time to insert the STA info                        | input: &sta_info, target = em_target_sta_map_assoc                                                                                              | STA info is successfully inserted into the internal data structure                                               | Should Pass         |
 * | 03               | Call put_sta_info a second time with the same duplicate STA info                   | input: &sta_info, target = em_target_sta_map_assoc                                                                                              | Duplicate STA info is rejected; only one unique entry is maintained                                                | Should Fail         |
 * | 04               | Retrieve the STA info and verify that the associated field remains true              | output: retrieved pointer from get_first_sta_info, expected: retrieved->associated = true                                                      | get_first_sta_info returns a valid pointer and the associated field is true confirming that only one valid instance exists | Should be successful |
 */
TEST(dm_easy_mesh_t, put_sta_info_DuplicateSTA_Negative)
{
    std::cout << "Entering put_sta_info_DuplicateSTA_Negative test" << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_sta_info_t sta_info;
    unsigned char mac[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
    unsigned char bssid[6] = {0x11,0x22,0x33,0x44,0x55,0x66};
    unsigned char radio[6] = {0x77,0x88,0x99,0x00,0x11,0x22};
    memcpy(sta_info.id, mac, 6);
    memcpy(sta_info.bssid, bssid, 6);
    memcpy(sta_info.radiomac, radio, 6);
    sta_info.associated = true;
    std::cout << "Invoking put_sta_info first time" << std::endl;
    dm.put_sta_info(&sta_info, em_target_sta_map_assoc);
    std::cout << "Invoking put_sta_info second time (duplicate)" << std::endl;
    dm.put_sta_info(&sta_info, em_target_sta_map_assoc);
    // Only one STA should exist
    em_sta_info_t* retrieved = dm.get_first_sta_info(em_target_sta_map_assoc);
    EXPECT_NE(retrieved, nullptr);
    EXPECT_TRUE(retrieved->associated);
    std::cout << "Retrieved STA associated=" << retrieved->associated << std::endl;
    dm.deinit();
    std::cout << "Exiting put_sta_info_DuplicateSTA_Negative test" << std::endl;
}

/**
 * @brief Verify that put_sta_info throws an exception when passed a NULL pointer.
 *
 * This test validates that the API put_sta_info correctly handles a NULL pointer for STA information by throwing an exception. It ensures the robustness of error handling for invalid input and prevents undefined behavior.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 559@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                                  | Test Data                                          | Expected Result                                              | Notes           |
 * | :--------------: | -------------------------------------------------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ | --------------- |
 * | 01               | Create dm_easy_mesh_t object, call init, and log test entry message.                         | No input                                           | dm_easy_mesh_t object is successfully created and initialized | Should be successful |
 * | 02               | Invoke put_sta_info with a NULL pointer for STA information and valid target; assert exception thrown. | input: sta_info = nullptr, target = em_target_sta_map_assoc | API throws an exception as expected due to invalid input; assertion passes | Should Fail     |
 * | 03               | Log test exit message to indicate the end of the test execution.                             | No input                                           | Exiting message is printed indicating test completion        | Should be successful |
 */
TEST(dm_easy_mesh_t, put_sta_info_NullSTAInfo_Negative)
{
    std::cout << "Entering put_sta_info_NullSTAInfo_Negative test" << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    std::cout << "Invoking put_sta_info with NULL pointer" << std::endl;
    EXPECT_ANY_THROW(dm.put_sta_info(nullptr, em_target_sta_map_assoc));
    std::cout << "Exiting put_sta_info_NullSTAInfo_Negative test" << std::endl;
}

/**
 * @brief Validate the removal of a BSS using a valid index in the mesh.
 *
 * This test verifies that when a valid index is provided to remove_bss_by_index, the BSS is removed correctly. 
 * It ensures that the number of BSS entries is updated appropriately and the remaining BSS entries maintain the correct indices.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 560@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                       | Test Data                                                                                              | Expected Result                                                                                                              | Notes         |
 * | :--------------: | ----------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------- | ------------- |
 * | 01               | Initialize the mesh object and populate it with 3 BSS entries       | mesh object, count = 3                                                                                 | Mesh is initialized with 3 BSS entries successfully                                                                        | Should be successful |
 * | 02               | Invoke remove_bss_by_index with index 1                             | input1 = index_to_remove, value = 1                                                                      | BSS at index 1 is removed; mesh now contains 2 BSS entries                                                                   | Should Pass   |
 * | 03               | Check the state of mesh via assertions for BSS count and indices      | input1 = mesh.m_num_bss, expected = 2; input2 = mesh.m_bss[0].m_bss_info.vap_index, expected = 0; input3 = mesh.m_bss[1].m_bss_info.vap_index, expected = 2 | The mesh object reflects the removal: m_num_bss equals 2, and BSS indices are updated to 0 and 2 respectively                 | Should be successful |
 */
TEST(dm_easy_mesh_t, RemoveBss_ValidIndex) {
    std::cout << "Entering RemoveBss_ValidIndex test\n";
    dm_easy_mesh_t mesh;
    InitBss(mesh, 3);
    unsigned int index_to_remove = 1;
    std::cout << "Invoking remove_bss_by_index(" << index_to_remove << ")\n";
    PrintBss(mesh);
    mesh.remove_bss_by_index(index_to_remove);
    std::cout << "After removal:\n";
    PrintBss(mesh);
    // Assertions
    EXPECT_EQ(mesh.m_num_bss, 2);
    EXPECT_EQ(mesh.m_bss[0].m_bss_info.vap_index, 0);
    EXPECT_EQ(mesh.m_bss[1].m_bss_info.vap_index, 2);
    mesh.deinit();
    std::cout << "Exiting RemoveBss_ValidIndex test\n";
}

/**
 * @brief Validate behavior when removing a BSS using an invalid index.
 *
 * This test verifies that the remove_bss_by_index API does not alter the mesh when an invalid index is provided. The test initializes a mesh with three BSS entries and attempts to remove a BSS at index 5, which is out of valid range, ensuring that the state of the mesh remains unchanged.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 561@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize a dm_easy_mesh_t object with 3 BSS entries | mesh object, Initialization count = 3 | Mesh initialized with 3 BSS entries having vap_index 0, 1, 2 respectively | Should be successful |
 * | 02 | Invoke remove_bss_by_index with an invalid index | invalid_index = 5 | Removal attempt does not modify the mesh | Should Pass |
 * | 03 | Verify that the number of BSS and their vap_index values remain unchanged | Expected: m_num_bss = 3, m_bss[0].vap_index = 0, m_bss[1].vap_index = 1, m_bss[2].vap_index = 2 | The mesh retains 3 BSS entries with their original vap_index values | Should be successful |
 */
TEST(dm_easy_mesh_t, RemoveBss_InvalidIndex) {
    std::cout << "Entering RemoveBss_InvalidIndex test\n";
    dm_easy_mesh_t mesh;
    InitBss(mesh, 3);
    unsigned int invalid_index = 5;
    std::cout << "Invoking remove_bss_by_index(" << invalid_index << ")\n";
    PrintBss(mesh);
    mesh.remove_bss_by_index(invalid_index);
    std::cout << "After attempting removal:\n";
    PrintBss(mesh);
    // Assertions: nothing should have changed
    EXPECT_EQ(mesh.m_num_bss, 3);
    EXPECT_EQ(mesh.m_bss[0].m_bss_info.vap_index, 0);
    EXPECT_EQ(mesh.m_bss[1].m_bss_info.vap_index, 1);
    EXPECT_EQ(mesh.m_bss[2].m_bss_info.vap_index, 2);
    mesh.deinit();
    std::cout << "Exiting RemoveBss_InvalidIndex test\n";
}

/**
 * @brief Verify removal of the last BSS entry from the mesh
 *
 * This test checks the functionality of removing the last BSS entry in the mesh object.
 * It verifies that after removal, the number of BSS entries decreases correctly and that the remaining BSS
 * entries retain the correct vap_index values.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 562@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                         | Test Data                                          | Expected Result                                                                           | Notes           |
 * | :--------------: | ------------------------------------------------------------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------------- | --------------- |
 * | 01               | Initialize the mesh with 3 BSS entries using InitBss                  | mesh instance, num_bss = 3                           | Mesh is initialized with 3 BSS entries                                                     | Should be successful |
 * | 02               | Calculate the last index as (number of BSS - 1)                       | mesh.m_num_bss = 3                                    | last_index equals 2                                                                        | Should be successful |
 * | 03               | Invoke remove_bss_by_index with the computed last index               | index = 2                                             | API call removes the BSS entry at index 2; internal state is updated                         | Should Pass     |
 * | 04               | Validate that the BSS count is reduced and verify remaining vap_index values | expected m_num_bss = 2, expected vap_index = 0,1     | Mesh now contains 2 BSS entries with vap_index 0 and 1 respectively; assertions pass            | Should Pass     |
 */
TEST(dm_easy_mesh_t, RemoveBss_LastIndex) {
    std::cout << "Entering RemoveBss_LastIndex test\n";
    dm_easy_mesh_t mesh;
    InitBss(mesh, 3);
    unsigned int last_index = mesh.m_num_bss - 1;
    std::cout << "Invoking remove_bss_by_index(" << last_index << ")\n";
    PrintBss(mesh);
    mesh.remove_bss_by_index(last_index);
    std::cout << "After removal:\n";
    PrintBss(mesh);
    // Assertions
    EXPECT_EQ(mesh.m_num_bss, 2);
    EXPECT_EQ(mesh.m_bss[0].m_bss_info.vap_index, 0);
    EXPECT_EQ(mesh.m_bss[1].m_bss_info.vap_index, 1);
    mesh.deinit();
    std::cout << "Exiting RemoveBss_LastIndex test\n";
}

/**
 * @brief Testing removal of a BSS from an empty mesh list
 *
 * This test validates that attempting to remove a BSS from an empty mesh list does not alter the state of the list.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 563@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                     | Test Data                                    | Expected Result                                                              | Notes              |
 * | :--------------: | --------------------------------------------------------------- | -------------------------------------------- | ---------------------------------------------------------------------------- | ------------------ |
 * | 01               | Initialize dm_easy_mesh_t object and set m_num_bss to 0           | No input arguments, m_num_bss = 0              | Object is initialized with an empty BSS list                                 | Should be successful |
 * | 02               | Invoke remove_bss_by_index with index 0 on the empty list          | index = 0, m_num_bss = 0                         | m_num_bss remains 0; removal attempt on an empty list is handled gracefully   | Should Pass        |
 * | 03               | Print the BSS list before and after the removal attempt            | PrintBss action; no additional input arguments   | Printed output shows an empty BSS list both before and after the removal call | Should be successful |
 */
TEST(dm_easy_mesh_t, RemoveBss_EmptyList) {
    std::cout << "Entering RemoveBss_EmptyList test\n";
    dm_easy_mesh_t mesh;
    mesh.init();
    mesh.m_num_bss = 0;
    unsigned int index = 0;
    std::cout << "Invoking remove_bss_by_index(" << index << ") on empty list\n";
    PrintBss(mesh);
    mesh.remove_bss_by_index(index);
    std::cout << "After attempting removal:\n";
    PrintBss(mesh);
    // Assertions
    EXPECT_EQ(mesh.m_num_bss, 0);
    mesh.deinit();
    std::cout << "Exiting RemoveBss_EmptyList test\n";
}

/**
 * @brief Verify that update_cac_status_id correctly updates the RUID for applicable op classes
 *
 * This test case ensures that the update_cac_status_id API successfully updates the RUID with a new MAC address for op classes whose type is greater than em_op_class_type_capability while leaving other op classes unchanged (i.e. their RUID remains zero). It validates the update by comparing the memory of the RUID with the expected MAC addresses.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 564@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                           | Test Data                                                                                                            | Expected Result                                                                                                                  | Notes          |
 * | :--------------: | ------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- | -------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and set op class count to 4                        | mesh instance, m_num_opclass = 4                                                                                     | dm_easy_mesh_t instance is correctly initialized with 4 op classes                                                               | Should be successful |
 * | 02               | Define new MAC address for update                                                     | new_mac = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF}                                                                       | new_mac variable is assigned with the correct MAC value                                                                          | Should be successful |
 * | 03               | Invoke update_cac_status_id API on the mesh instance with the new MAC address           | API input: mesh instance, new_mac = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF}                                                   | API call successfully updates the RUID for op classes with type > em_op_class_type_capability, leaving others unchanged             | Should Pass    |
 * | 04               | Validate the RUID update for each op class based on their type criteria                 | For each op class: if type > em_op_class_type_capability then ruid should match new_mac, otherwise ruid should be zeroed | For op classes meeting the criteria, memcmp returns 0 when comparing RUID with new_mac; for others, memcmp returns 0 when comparing RUID with a zero MAC | Should Pass    |
 */
TEST(dm_easy_mesh_t, Updatecac_positive_UpdateRuid) {
    std::cout << "Entering Updatecac_Positive_UpdateRuid test\n";
    dm_easy_mesh_t mesh;
    InitOpClass(mesh, 4);
    mac_address_t new_mac = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    std::cout << "Invoking update_cac_status_id with MAC=AA:BB:CC:DD:EE:FF\n";
    PrintOpClass(mesh);
    mesh.update_cac_status_id(new_mac);
    std::cout << "After update:\n";
    PrintOpClass(mesh);
    for (unsigned int i = 0; i < mesh.m_num_opclass; i++) {
        if (mesh.m_op_class[i].m_op_class_info.id.type > em_op_class_type_capability) {
            EXPECT_EQ(memcmp(mesh.m_op_class[i].m_op_class_info.id.ruid, new_mac, sizeof(mac_address_t)), 0);
        } else {
            mac_address_t zero_mac = {};
            EXPECT_EQ(memcmp(mesh.m_op_class[i].m_op_class_info.id.ruid, zero_mac, sizeof(mac_address_t)), 0);
        }
    }
    mesh.deinit();
    std::cout << "Exiting Updatecac_Positive_UpdateRuid test\n";
}

/**
 * @brief Validate update_cac_status_id does not update op classes when none are configured
 *
 * This test verifies that when the mesh has no op classes (m_num_opclass is 0), invoking 
 * update_cac_status_id with a valid MAC address does not alter the op class count.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 565@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :--------------: | ----------- | --------- | ------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object by calling init() | mesh.init() | Mesh object is properly initialized | Should be successful |
 * | 02 | Set m_num_opclass to 0 | m_num_opclass = 0 | Mesh operation class count set to 0 | Should be successful |
 * | 03 | Initialize MAC address | mac = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06} | MAC address is assigned | Should be successful |
 * | 04 | Print op class state before update | PrintOpClass(mesh) | Initial op class state printed | Should be successful |
 * | 05 | Invoke update_cac_status_id with the given MAC | update_cac_status_id(mac), input: mac=01:02:03:04:05:06, m_num_opclass=0 | op class count remains 0 after invocation | Should Fail |
 * | 06 | Print op class state after update | PrintOpClass(mesh) | Updated op class state printed | Should be successful |
 * | 07 | Verify m_num_opclass remains unchanged using EXPECT_EQ | EXPECT_EQ(mesh.m_num_opclass, 0) | Assertion passes confirming op class count is 0 | Should be successful |
 */
TEST(dm_easy_mesh_t, Updatecac_Negative_EmptyOpClass) {
    std::cout << "Entering Updatecac_Negative_EmptyOpClass test\n";
    dm_easy_mesh_t mesh;
    mesh.init();
    mesh.m_num_opclass = 0;
    mac_address_t mac = {0x01,0x02,0x03,0x04,0x05,0x06};
    std::cout << "Invoking update_cac_status_id with MAC=01:02:03:04:05:06\n";
    PrintOpClass(mesh);
    mesh.update_cac_status_id(mac);
    std::cout << "After update:\n";
    PrintOpClass(mesh);
    EXPECT_EQ(mesh.m_num_opclass, 0);
    mesh.deinit();
    std::cout << "Exiting Updatecac_Negative_EmptyOpClass test\n";
}

/**
 * @brief Verify update_cac_status_id does not update op_class type when resetting cac status.
 *
 * This test initializes a dm_easy_mesh_t instance with three operational class entries and sets each op_class's id type to em_op_class_type_capability.
 * It then calls update_cac_status_id with a specific MAC address and verifies that the operation resets the ruid field to zero without modifying the op_class type.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 566@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t instance with 3 op_class entries and set each id type to em_op_class_type_capability | mesh.m_num_opclass=3, for each op_class: m_op_class_info.id.type=em_op_class_type_capability | Mesh is correctly initialized with op_class id types set as capability | Should be successful |
 * | 02 | Invoke update_cac_status_id using a predefined MAC address | input: mac = {0x10,0x20,0x30,0x40,0x50,0x60} | Function update_cac_status_id is called and the op_class ruid values are updated | Should Pass |
 * | 03 | Verify that each op_class ruid is updated to zero | for each op_class: compare m_op_class_info.id.ruid with zero_mac (all zeros) using memcmp | memcmp returns 0 confirming that ruid is reset to zero for each op_class | Should Pass |
 */
TEST(dm_easy_mesh_t, Updatecac_Edge_NoTypeUpdate) {
    std::cout << "Entering Updatecac_Edge_NoTypeUpdate test\n";
    dm_easy_mesh_t mesh;
    InitOpClass(mesh, 3);
    for (unsigned int i = 0; i < mesh.m_num_opclass; i++) {
        mesh.m_op_class[i].m_op_class_info.id.type = em_op_class_type_capability;
    }
    mac_address_t mac = {0x10,0x20,0x30,0x40,0x50,0x60};
    std::cout << "Invoking update_cac_status_id with MAC=10:20:30:40:50:60\n";
    PrintOpClass(mesh);
    mesh.update_cac_status_id(mac);
    std::cout << "After update:\n";
    PrintOpClass(mesh);
    for (unsigned int i = 0; i < mesh.m_num_opclass; i++) {
        mac_address_t zero_mac = {};
        EXPECT_EQ(memcmp(mesh.m_op_class[i].m_op_class_info.id.ruid, zero_mac, sizeof(mac_address_t)), 0);
    }
    mesh.deinit();
    std::cout << "Exiting Updatecac_Edge_NoTypeUpdate test\n";
}

/**
 * @brief Verify that clone_hash_maps correctly clones station hash maps from source to destination.
 *
 * This test verifies that after cloning, the destination object contains the same pointers for consolidated and association station maps as the source, while the destination dissociation map remains empty. This ensures that the clone_hash_maps API preserves the internal mapping relationships.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 567@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize source and destination objects by calling init() on both | src, dst objects; src.init(), dst.init() | Both src and dst are properly initialized | Should be successful |
 * | 02 | Create station info objects using CreateSta for different maps | sta1: id=0x01, val1=0x10, val2=0x20; sta2: id=0x02, val1=0x11, val2=0x21 | Station info objects sta1 and sta2 are created successfully | Should be successful |
 * | 03 | Insert station info into src hash maps for consolidated and association mappings | Call src.put_sta_info(&sta1, em_target_sta_map_consolidated) and src.put_sta_info(&sta2, em_target_sta_map_assoc) | src hash maps updated with sta1 in consolidated and sta2 in association maps | Should be successful |
 * | 04 | Retrieve station pointers from src hash maps and assert they are not null | src_sta = hash_map_get_first(src.m_sta_map), src_assoc = hash_map_get_first(src.m_sta_assoc_map) | Retrieved src_sta and src_assoc are not nullptr | Should be successful |
 * | 05 | Clone hash maps from src to dst by invoking clone_hash_maps | Call src.clone_hash_maps(dst) | dst hash maps are cloned; internal pointers maintained as in src | Should Pass |
 * | 06 | Validate cloned station pointers and check that the dissociation map is empty in dst | dst_sta = hash_map_get_first(dst.m_sta_map), dst_assoc = hash_map_get_first(dst.m_sta_assoc_map), hash_map_get_first(dst.m_sta_dassoc_map) | dst_sta equals src_sta, dst_assoc equals src_assoc, and dissociation map returns nullptr | Should Pass |
 */
TEST(dm_easy_mesh_t, CloneHashMapsTest_positive_CloneMaps)
{
    std::cout << "Entering CloneHashMapsTest_positive_CloneMaps test\n";
    dm_easy_mesh_t src, dst;
    src.init();
    dst.init();
    em_sta_info_t sta1 = CreateSta(0x01, 0x10, 0x20);
    em_sta_info_t sta2 = CreateSta(0x02, 0x11, 0x21);
    src.put_sta_info(&sta1, em_target_sta_map_consolidated);
    src.put_sta_info(&sta2, em_target_sta_map_assoc);
    dm_sta_t* src_sta = static_cast<dm_sta_t*>(hash_map_get_first(src.m_sta_map));
    dm_sta_t* src_assoc = static_cast<dm_sta_t*>(hash_map_get_first(src.m_sta_assoc_map));
    ASSERT_NE(src_sta, nullptr);
    ASSERT_NE(src_assoc, nullptr);
    src.clone_hash_maps(dst);
    dm_sta_t* dst_sta = static_cast<dm_sta_t*>(hash_map_get_first(dst.m_sta_map));
    dm_sta_t* dst_assoc = static_cast<dm_sta_t*>(hash_map_get_first(dst.m_sta_assoc_map));
    EXPECT_EQ(dst_sta, src_sta);
    EXPECT_EQ(dst_assoc, src_assoc);
    EXPECT_EQ(hash_map_get_first(dst.m_sta_dassoc_map), nullptr);
    src.deinit();
    dst.deinit();
    std::cout << "Exiting CloneHashMapsTest_positive_CloneMaps test\n";
}

/**
 * @brief Test negative scenario for clone_hash_maps by cloning from an empty source.
 *
 * This test validates that when clone_hash_maps is invoked with an empty source dm_easy_mesh_t object, 
 * the destination dm_easy_mesh_t object remains unchanged (i.e., its hash maps remain empty). 
 * It ensures that the API correctly handles the scenario where there is no data to clone.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 568@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                          | Test Data                                                                                                                                                       | Expected Result                                                                                  | Notes            |
 * | :--------------: | -------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ | ---------------- |
 * | 01               | Initialize source and destination objects by calling init()          | src = dm_easy_mesh_t (empty), dst = dm_easy_mesh_t (empty)                                                                                                      | Both src and dst hash maps are initialized to empty state                                        | Should be successful |
 * | 02               | Print source hash maps before cloning                                | src.m_sta_map = empty, src.m_sta_assoc_map = empty, src.m_sta_dassoc_map = empty                                                                                 | The printed output confirms that all source maps are empty                                       | Should be successful |
 * | 03               | Invoke clone_hash_maps to clone from an empty source to destination    | input: src.m_sta_map = empty, src.m_sta_assoc_map = empty, src.m_sta_dassoc_map = empty; dst.m_sta_map = empty, dst.m_sta_assoc_map = empty, dst.m_sta_dassoc_map = empty | The API call does not change dst; destination hash maps remain empty                                | Should Fail      |
 * | 04               | Print destination hash maps after cloning                              | dst.m_sta_map, dst.m_sta_assoc_map, dst.m_sta_dassoc_map (expected to be empty)                                                                                    | The printed output confirms that all destination maps are still empty                            | Should be successful |
 * | 05               | Assert that destination maps are still empty                           | Call to hash_map_get_first for dst.m_sta_map, dst.m_sta_assoc_map, dst.m_sta_dassoc_map with expected value = nullptr                                           | Each EXPECT_EQ returns true as hash_map_get_first(dst.map) equals nullptr                         | Should be successful |
 * | 06               | Exit test and print exit message                                       | N/A                                                                                                                                                             | Test completes after printing exit message                                                     | Should be successful |
 */
TEST(dm_easy_mesh_t, CloneHashMapsTest_negative_EmptySource) {
    std::cout << "Entering CloneHashMapsTest_negative_EmptySource test\n";
    dm_easy_mesh_t src, dst;
    src.init();
    dst.init();
    std::cout << "Invoking clone_hash_maps from empty src to dst\n";
    std::cout << "Source maps before clone:\n";
    PrintStaMap("STA Map", src.m_sta_map);
    PrintStaMap("Assoc Map", src.m_sta_assoc_map);
    PrintStaMap("Dissoc Map", src.m_sta_dassoc_map);
    dst.clone_hash_maps(src);
    std::cout << "Destination maps after clone:\n";
    PrintStaMap("STA Map", dst.m_sta_map);
    PrintStaMap("Assoc Map", dst.m_sta_assoc_map);
    PrintStaMap("Dissoc Map", dst.m_sta_dassoc_map);
    // Assertions: Destination maps should remain empty
    EXPECT_EQ(hash_map_get_first(dst.m_sta_map), nullptr);
    EXPECT_EQ(hash_map_get_first(dst.m_sta_assoc_map), nullptr);
    EXPECT_EQ(hash_map_get_first(dst.m_sta_dassoc_map), nullptr);
    src.deinit();
    dst.deinit();
    std::cout << "Exiting CloneHashMapsTest_negative_EmptySource test\n";
}

/**
 * @brief Verify clone_hash_maps correctly preserves non-empty destination entries.
 *
 * This test verifies that when calling clone_hash_maps on a destination object that already contains a station info entry,
 * the destination remains non-empty and either retains its original entry or is updated with the source's entry. This ensures
 * that the clone operation does not inadvertently clear existing destination entries.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 569@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- | -------------- | ----- |
 * | 01 | Initialize src and dst objects and call init() | src = dm_easy_mesh_t instance (init called), dst = dm_easy_mesh_t instance (init called) | Both objects are initialized properly | Should be successful |
 * | 02 | Create and insert a station info record into src | sta_src = CreateSta(0x01, 0x10, 0x20) inserted into src with em_target_sta_map_consolidated | Station info is successfully added to src | Should Pass |
 * | 03 | Create and insert a station info record into dst | sta_dst = CreateSta(0xFF, 0xEE, 0xDD) inserted into dst with em_target_sta_map_consolidated | Station info is successfully added to dst before cloning | Should Pass |
 * | 04 | Verify destination hash map is non-empty before clone operation | Call hash_map_get_first(dst.m_sta_map) | Returns a non-null pointer from dst hash map | Should Pass |
 * | 05 | Invoke clone_hash_maps on dst with src | Call dst.clone_hash_maps(src) | Clone operation completes without error | Should be successful |
 * | 06 | Retrieve destination entry after cloning | Call hash_map_get_first(dst.m_sta_map) | Returns a non-null pointer indicating at least one entry present | Should Pass |
 * | 07 | Assert destination entry consistency after cloning | Compare dst_after with dst_before and with first entry from src.m_sta_map | dst_after equals either dst_before or first entry from src hash map | Should Pass |
 */
TEST(dm_easy_mesh_t, CloneHashMapsTest_edge_DestinationNonEmpty)
{
    std::cout << "Entering CloneHashMapsTest_edge_DestinationNonEmpty test\n";
    dm_easy_mesh_t src, dst;
    src.init();
    dst.init();
    em_sta_info_t sta_src = CreateSta(0x01, 0x10, 0x20);
    em_sta_info_t sta_dst = CreateSta(0xFF, 0xEE, 0xDD);
    src.put_sta_info(&sta_src, em_target_sta_map_consolidated);
    dst.put_sta_info(&sta_dst, em_target_sta_map_consolidated);
    dm_sta_t* dst_before = static_cast<dm_sta_t*>(hash_map_get_first(dst.m_sta_map));
    ASSERT_NE(dst_before, nullptr);
    dst.clone_hash_maps(src);
    dm_sta_t* dst_after = static_cast<dm_sta_t*>(hash_map_get_first(dst.m_sta_map));
    ASSERT_NE(dst_after, nullptr);
    // Destination entry must still exist
    EXPECT_TRUE(
        dst_after == dst_before ||
        dst_after == static_cast<dm_sta_t*>(hash_map_get_first(src.m_sta_map))
    );
    src.deinit();
    dst.deinit();
    std::cout << "Exiting CloneHashMapsTest_edge_DestinationNonEmpty test\n";
}

/**
 * @brief Test the equality operator for dm_easy_mesh_t objects to verify that identical objects are considered equal.
 *
 * This test verifies that the overloaded operator== correctly identifies equality when both dm_easy_mesh_t objects are initialized and have identical BSS configurations. It specifically examines that the m_num_bss and vap_index values match between the objects, ensuring that the equality operator works as expected.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 570@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                            | Test Data                                                                                      | Expected Result                                | Notes            |
 * | :--------------: | ---------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ---------------------------------------------- | ---------------- |
 * | 01               | Instantiate two dm_easy_mesh_t objects and perform initialization      | obj1: default, obj2: default                                                                     | Objects are successfully created and initialized | Should be successful |
 * | 02               | Set m_num_bss and vap_index for both objects to ensure equality          | obj1: m_num_bss = 1, obj1.m_bss[0].m_bss_info.vap_index = 7, obj2: m_num_bss = 1, obj2.m_bss[0].m_bss_info.vap_index = 7 | Object properties are correctly assigned      | Should Pass      |
 * | 03               | Invoke the equality operator (operator==) to compare both objects         | Call: operator==(obj1, obj2)                                                                     | Returns true, matching the expected equality   | Should Pass      |
 */
TEST(dm_easy_mesh_t, Positive_EqualityOperator) {
    std::cout << "Entering Positive_EqualityOperator test\n";
    dm_easy_mesh_t obj1{};
    dm_easy_mesh_t obj2{};
    obj1.init();
    obj2.init();
    obj1.m_num_bss = 1;
    obj1.m_bss[0].m_bss_info.vap_index = 7;
    obj2.m_num_bss = 1;
    obj2.m_bss[0].m_bss_info.vap_index = 7;
    std::cout << "Obj1 vap_index=" << obj1.m_bss[0].m_bss_info.vap_index << "\n";
    std::cout << "Obj2 vap_index=" << obj2.m_bss[0].m_bss_info.vap_index << "\n";
    std::cout << "Invoking operator==\n";
    EXPECT_TRUE(obj1 == obj2);
    obj1.deinit();
    obj2.deinit();
    std::cout << "Exiting Positive_EqualityOperator test\n";
}

/**
 * @brief Validate that the equality operator returns false when the media types of two dm_easy_mesh_t objects differ
 *
 * This test verifies the behavior of the operator== in a negative scenario where two dm_easy_mesh_t objects are initialized with 
 * different media types. The test ensures that the operator correctly identifies the mismatch and returns false. This is important 
 * for ensuring that objects with differing network media are not considered equal.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 571@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                  | Test Data                                                                                                   | Expected Result                                               | Notes           |
 * | :--------------: | -------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------- | --------------- |
 * | 01               | Initialize two dm_easy_mesh_t objects and assign mismatching media values                      | obj1: media = em_media_type_ieee8023ab, obj2: media = em_media_type_ieee80211b_24                              | Objects are correctly initialized with distinct media values  | Should be successful |
 * | 02               | Invoke the equality operator (operator==) to compare the two objects with mismatching media    | Invocation of operator== on obj1 and obj2; expected output capture: false                                   | The operator returns false and EXPECT_FALSE assertion passes   | Should Fail     |
 */
TEST(dm_easy_mesh_t, Negative_EqualityOperator_MediaMismatch) {
    std::cout << "Entering Negative_EqualityOperator_MediaMismatch test\n";
    dm_easy_mesh_t obj1{}, obj2{};
    obj1.init();
    obj2.init();
    obj1.m_network.m_net_info.media = em_media_type_ieee8023ab;
    obj2.m_network.m_net_info.media = em_media_type_ieee80211b_24;
    std::cout << "Invoking operator==\n";
    EXPECT_FALSE(obj1 == obj2);
    obj1.deinit();
    obj2.deinit();
    std::cout << "Exiting Negative_EqualityOperator_MediaMismatch test\n";
}

/**
 * @brief Verifies that the equality operator returns false when comparing two dm_easy_mesh_t objects with different network IDs.
 *
 * This test initializes two dm_easy_mesh_t objects, sets different network IDs for each instance, and asserts that the equality operator returns false. The purpose is to ensure that the equality comparison appropriately detects mismatches in network IDs.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 572@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                        | Test Data                                                                     | Expected Result                              | Notes               |
 * | :--------------: | ------------------------------------------------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------- | ------------------- |
 * | 01               | Initialize two dm_easy_mesh_t objects and call their init() method   | obj1 = default, obj2 = default                                                 | Both objects are successfully initialized    | Should be successful |
 * | 02               | Set different network IDs for each object                           | obj1.m_network.m_net_info.id = "Network_A", obj2.m_network.m_net_info.id = "Network_B" | Network IDs are assigned as specified        | Should be successful |
 * | 03               | Invoke the equality operator (operator==) to compare both objects    | operator==(obj1, obj2), expected output: false                                 | Equality operator returns false              | Should Pass         |
 */
TEST(dm_easy_mesh_t, Negative_EqualityOperator_NetworkIdMismatch) {
    std::cout << "Entering Negative_EqualityOperator_NetworkIdMismatch test\n";
    dm_easy_mesh_t obj1{}, obj2{};
    obj1.init();
    obj2.init();
    strcpy(obj1.m_network.m_net_info.id, "Network_A");
    strcpy(obj2.m_network.m_net_info.id, "Network_B");
    std::cout << "Invoking operator==\n";
    EXPECT_FALSE(obj1 == obj2);
    obj1.deinit();
    obj2.deinit();
    std::cout << "Exiting Negative_EqualityOperator_NetworkIdMismatch test\n";
}

/**
 * @brief Verifies that update_ap_mld_info successfully creates a new MLD entry with valid input data.
 *
 * This test verifies that invoking update_ap_mld_info with a properly initialized input structure creates a new MLD entry.
 * The test checks if the stored data in the dm_easy_mesh_t instance matches the input data provided.
 * @n
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 573@n
 * **Priority:** High@n
 * @n
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * @n
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t, set up input structure with valid values including MAC addresses, SSID, string values, and affiliated AP details; invoke update_ap_mld_info API; and verify stored output. | dm_easy_mesh_t instance via dm.init(), input.mac_addr_valid = true, input.ssid = "TestSSID", input.str = 1, input.nstr = 2, input.emlsr = true, input.emlmr = false, input.num_affiliated_ap = 1, input.mac_addr = [1,2,3,4,5,6], affiliated_ap[0].mac_addr_valid = true, affiliated_ap[0].link_id_valid = true, affiliated_ap[0].link_id = 10, affiliated_ap[0].mac_addr = [10,11,12,13,14,15] | dm.m_num_ap_mld equals 1 and all EXPECT assertions (EXPECT_TRUE, EXPECT_EQ, EXPECT_STREQ) pass confirming the stored data matches input data. | Should Pass |
 */
TEST(dm_easy_mesh_t, UpdateApMldInfo_positive_CreateNewMld)
{
    std::cout << "Entering UpdateApMldInfo_positive_CreateNewMld test" << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_ap_mld_info_t input{};
    input.mac_addr_valid = true;
    strncpy(input.ssid, "TestSSID", sizeof(input.ssid));
    input.str = 1;
    input.nstr = 2;
    input.emlsr = true;
    input.emlmr = false;
    for (int i = 0; i < 6; i++) {
        input.mac_addr[i] = static_cast<uint8_t>(i + 1);
    }
    input.num_affiliated_ap = 1;
    input.affiliated_ap[0].mac_addr_valid = true;
    input.affiliated_ap[0].link_id_valid = true;
    input.affiliated_ap[0].link_id = 10;
    for (int i = 0; i < 6; i++) {
        input.affiliated_ap[0].mac_addr[i] = static_cast<uint8_t>(10 + i);
    }
    std::cout << "Invoking update_ap_mld_info(&input)" << std::endl;
    dm.update_ap_mld_info(&input);
    EXPECT_EQ(dm.m_num_ap_mld, 1u);
    em_ap_mld_info_t &stored = dm.m_ap_mld[0].m_ap_mld_info;
    std::cout << "Stored mac_addr_valid: " << stored.mac_addr_valid << std::endl;
    std::cout << "Stored ssid: " << stored.ssid << std::endl;
    std::cout << "Stored str: " << stored.str << std::endl;
    std::cout << "Stored nstr: " << stored.nstr << std::endl;
    std::cout << "Stored emlsr: " << stored.emlsr << std::endl;
    std::cout << "Stored emlmr: " << stored.emlmr << std::endl;
    std::cout << "Stored num_affiliated_ap: " << stored.num_affiliated_ap << std::endl;
    EXPECT_TRUE(stored.mac_addr_valid);
    EXPECT_STREQ(stored.ssid, "TestSSID");
    EXPECT_EQ(stored.num_affiliated_ap, 1);
    EXPECT_TRUE(stored.affiliated_ap[0].mac_addr_valid);
    EXPECT_TRUE(stored.affiliated_ap[0].link_id_valid);
    EXPECT_EQ(stored.affiliated_ap[0].link_id, 10);
    dm.deinit();
    std::cout << "Exiting UpdateApMldInfo_positive_CreateNewMld test" << std::endl;
}

/**
 * @brief Verifies that updating existing AP MLD information correctly replaces the initial data with updated values.
 *
 * This test creates a dm_easy_mesh_t object, initializes it with an initial AP MLD info structure, and then updates it with new information.
 * The test ensures that the updated values (SSID, number of affiliated APs, and link ID) are stored and can be validated using assertion checks.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 574@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                                      | Test Data                                                                                                                                                        | Expected Result                                                                                                   | Notes           |
 * | :--------------: | ------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- | --------------- |
 * | 01               | Initialize dm_easy_mesh_t object and insert initial AP MLD info with SSID "SSID1"                | dm = dm_easy_mesh_t instance, first.mac_addr_valid = true, first.ssid = "SSID1", first.mac_addr = [1,2,3,4,5,6]                                                  | dm contains one AP MLD info record with initial values                                                             | Should be successful |
 * | 02               | Update the existing AP MLD info with new SSID "SSID_UPDATED" and affiliated AP details           | update.mac_addr_valid = true, update.ssid = "SSID_UPDATED", update.mac_addr = [1,2,3,4,5,6], update.num_affiliated_ap = 1, affiliated_ap[0].link_id = 42, affiliated_ap[0].link_id_valid = true | The update_ap_mld_info API updates the stored record with new values                                                 | Should Pass     |
 * | 03               | Verify that the stored AP MLD info reflects the updated SSID, affiliated AP count, and link id     | expected stored ssid = "SSID_UPDATED", expected stored num_affiliated_ap = 1, expected stored affiliated_ap[0].link_id = 42                                             | Assertions (EXPECT_STREQ and EXPECT_EQ) pass confirming that the stored record matches the updated values            | Should be successful |
 */
TEST(dm_easy_mesh_t, UpdateApMldInfo_positive_UpdateExistingMld)
{
    std::cout << "Entering UpdateApMldInfo_positive_UpdateExistingMld test" << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_ap_mld_info_t first{};
    first.mac_addr_valid = true;
    strncpy(first.ssid, "SSID1", sizeof(first.ssid));
    for (int i = 0; i < 6; i++) {
        first.mac_addr[i] = static_cast<uint8_t>(i + 1);
    }
    dm.update_ap_mld_info(&first);
    em_ap_mld_info_t update;
    memset(&update, 0, sizeof(update));
    update.mac_addr_valid = true;
    strncpy(update.ssid, "SSID_UPDATED", sizeof(update.ssid));
    for (int i = 0; i < 6; i++) {
        update.mac_addr[i] = static_cast<uint8_t>(i + 1);
    }
    update.num_affiliated_ap = 1;
    update.affiliated_ap[0].link_id = 42;
    update.affiliated_ap[0].link_id_valid = true;
    std::cout << "Invoking update_ap_mld_info(&update)" << std::endl;
    dm.update_ap_mld_info(&update);
    EXPECT_EQ(dm.m_num_ap_mld, 1u);
    em_ap_mld_info_t &stored = dm.m_ap_mld[0].m_ap_mld_info;
    std::cout << "Updated ssid: " << stored.ssid << std::endl;
    std::cout << "Affiliated AP count: " << stored.num_affiliated_ap << std::endl;
    std::cout << "Affiliated AP link_id: "
              << stored.affiliated_ap[0].link_id << std::endl;
    EXPECT_STREQ(stored.ssid, "SSID_UPDATED");
    EXPECT_EQ(stored.num_affiliated_ap, 1);
    EXPECT_EQ(stored.affiliated_ap[0].link_id, 42);
    dm.deinit();
    std::cout << "Exiting UpdateApMldInfo_positive_UpdateExistingMld test" << std::endl;
}

/**
 * @brief Test that update_ap_mld_info API does not add a new MLD entry when the maximum limit is reached.
 *
 * This test sets the AP MLD count to the maximum allowed value (EM_MAX_AP_MLD) and then attempts to add a new MLD entry.
 * It verifies that invoking update_ap_mld_info does not increment the count beyond the allowed maximum.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 575@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                 | Test Data                                      | Expected Result                                              | Notes         |
 * | :--------------: | --------------------------------------------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ | ------------- |
 * | 01               | Initialize dm_easy_mesh_t instance and set current MLD count to max limit   | dm.m_num_ap_mld = EM_MAX_AP_MLD                  | m_num_ap_mld is set to the maximum allowed value             | Should be successful |
 * | 02               | Prepare input MLD info with sample MAC address                              | input.mac_addr = 1,2,3,4,5,6                      | Input structure is populated                                 | Should be successful |
 * | 03               | Invoke update_ap_mld_info API with full MLD table                           | input = valid em_ap_mld_info_t                   | m_num_ap_mld remains unchanged (EM_MAX_AP_MLD)               | Should Pass   |
 * | 04               | Check the m_num_ap_mld value after API call via assertion                    | Expected: m_num_ap_mld = EM_MAX_AP_MLD             | EXPECT_EQ(dm.m_num_ap_mld, EM_MAX_AP_MLD) passes              | Should Pass   |
 */
TEST(dm_easy_mesh_t, UpdateApMldInfo_negative_MaxMldLimitReached)
{
    std::cout << "Entering UpdateApMldInfo_negative_MaxMldLimitReached test" << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    dm.m_num_ap_mld = EM_MAX_AP_MLD;
    em_ap_mld_info_t input{};
    for (int i = 0; i < 6; i++) {
        input.mac_addr[i] = static_cast<uint8_t>(i + 1);
    }
    std::cout << "Invoking update_ap_mld_info(&input) with full MLD table"
              << std::endl;
    dm.update_ap_mld_info(&input);
    std::cout << "m_num_ap_mld after call: " << dm.m_num_ap_mld << std::endl;
    EXPECT_EQ(dm.m_num_ap_mld, EM_MAX_AP_MLD);
    dm.deinit();
    std::cout << "Exiting UpdateApMldInfo_negative_MaxMldLimitReached test" << std::endl;
}

/**
 * @brief Verify that the static wrapper update_ap_mld_info correctly updates the dm_easy_mesh_t object with valid AP MLD information.
 *
 * This test verifies that a dm_easy_mesh_t instance is properly initialized, the input structure
 * (em_ap_mld_info_t) is correctly populated with valid SSID and MAC address data, and that the static
 * function update_ap_mld_info(&dm, &input) updates the instances internal state accordingly. The test
 * asserts that the number of stored AP MLD entries becomes 1 and that the stored SSID matches the expected value.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 576@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                               | Test Data                                                                                           | Expected Result                                                                                                              | Notes           |
 * | :--------------: | ----------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- | --------------- |
 * |       01       | Initialize dm_easy_mesh_t instance and call init method                                   | dm_easy_mesh_t dm                                                                                   | dm is properly initialized                                                                                                   | Should be successful |
 * |       02       | Populate em_ap_mld_info_t structure with valid SSID and MAC address values                 | input.mac_addr_valid = true, input.ssid = "StaticCallSSID", input.mac_addr = [20,21,22,23,24,25]      | Input structure is populated with valid data                                                                               | Should be successful |
 * |       03       | Invoke the static API update_ap_mld_info with the dm object and input structure            | dm pointer, input pointer                                                                            | dm.m_num_ap_mld is updated to 1                                                                                                | Should Pass     |
 * |       04       | Validate the stored SSID in the dm structure using EXPECT_STREQ assertion                  | dm.m_ap_mld[0].m_ap_mld_info.ssid = "StaticCallSSID"                                                | The stored SSID exactly matches "StaticCallSSID"                                                                             | Should Pass     |
 */
TEST(dm_easy_mesh_t, UpdateApMldInfo_positive_StaticWrapperInvocation)
{
    std::cout << "Entering UpdateApMldInfo_positive_StaticWrapperInvocation test" << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_ap_mld_info_t input{};
    input.mac_addr_valid = true;
    strncpy(input.ssid, "StaticCallSSID", sizeof(input.ssid));
    for (int i = 0; i < 6; i++) {
        input.mac_addr[i] = static_cast<uint8_t>(20 + i);
    }
    std::cout << "Invoking static update_ap_mld_info(&dm, &input)" << std::endl;
    dm_easy_mesh_t::update_ap_mld_info(&dm, &input);
    EXPECT_EQ(dm.m_num_ap_mld, 1u);
    std::cout << "Stored ssid: "
              << dm.m_ap_mld[0].m_ap_mld_info.ssid << std::endl;
    EXPECT_STREQ(dm.m_ap_mld[0].m_ap_mld_info.ssid, "StaticCallSSID");
    dm.deinit();
    std::cout << "Exiting UpdateApMldInfo_positive_StaticWrapperInvocation test" << std::endl;
}

/**
 * @brief Test negative scenario for update_ap_mld_info API with null dm pointer
 *
 * This test verifies that the update_ap_mld_info API correctly handles the case when a null dm pointer is provided by throwing an exception. The API is invoked with valid input values in the input structure, but with the dm pointer set to nullptr.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 577@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                   | Test Data                                                                                     | Expected Result                                                        | Notes       |
 * | :----:           | ------------------------------------------------------------- | --------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- | ----------- |
 * | 01               | Call update_ap_mld_info API with null dm pointer and valid input| dm = nullptr, input.mac_addr_valid = true, input.ssid = "NullDM", input.mac_addr = [70,71,72,73,74,75] | API is expected to throw an exception, confirmed by EXPECT_ANY_THROW  | Should Fail |
 */
TEST(dm_easy_mesh_t, UpdateApMldInfo_negative_Static_NullDmPointer)
{
    std::cout << "Entering UpdateApMldInfo_negative_Static_NullDmPointer test" << std::endl;
    em_ap_mld_info_t input{};
    input.mac_addr_valid = true;
    strncpy(input.ssid, "NullDM", sizeof(input.ssid));
    for (int i = 0; i < 6; i++) {
        input.mac_addr[i] = static_cast<uint8_t>(70 + i);
    }
    std::cout << "Invoking static update_ap_mld_info with dm == nullptr"
              << std::endl;
    EXPECT_ANY_THROW({
        dm_easy_mesh_t::update_ap_mld_info(nullptr, &input);
    });
    std::cout << "Exiting UpdateApMldInfo_negative_Static_NullDmPointer test" << std::endl;
}

/**
 * @brief Verify that update_ap_mld_info throws an exception when a null pointer is provided for ap_mld_info.
 *
 * This test checks that the static function update_ap_mld_info properly handles an invalid input scenario by throwing an exception when the ap_mld_info pointer is nullptr. It performs initialization of the dm_easy_mesh_t object and then invokes the API with a null pointer to validate that the error handling is correct.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 578@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Print entering test message | N/A | "Entering UpdateApMldInfo_negative_Static_NullApMldInfoPointer test" printed on stdout | Should be successful |
 * | 02 | Initialize dm_easy_mesh_t instance and invoke init() | dm instance created with default constructor | dm instance initializes successfully | Should be successful |
 * | 03 | Invoke update_ap_mld_info with ap_mld_info as nullptr | input: dm pointer = &dm, ap_mld_info = nullptr | Exception is thrown confirming negative scenario | Should Fail |
 * | 04 | Print exiting test message | N/A | "Exiting UpdateApMldInfo_negative_Static_NullApMldInfoPointer test" printed on stdout | Should be successful |
 */
TEST(dm_easy_mesh_t, UpdateApMldInfo_negative_Static_NullApMldInfoPointer)
{
    std::cout << "Entering UpdateApMldInfo_negative_Static_NullApMldInfoPointer test" << std::endl;
    dm_easy_mesh_t dm;
	dm.init();
    std::cout << "Invoking static update_ap_mld_info with ap_mld_info == nullptr" << std::endl;
    EXPECT_ANY_THROW({
        dm_easy_mesh_t::update_ap_mld_info(&dm, nullptr);
    });
    std::cout << "Exiting UpdateApMldInfo_negative_Static_NullApMldInfoPointer test" << std::endl;
}

/**
 * @brief Validate that update_scan_results correctly creates a new scan result.
 *
 * This test verifies that calling update_scan_results on an instance of dm_easy_mesh_t with a default 
 * em_scan_result_t input successfully initializes the internal scan result map, and the fields in the 
 * scan result id structure are correctly set. The API is expected to set the net_id to "OneWifiMesh" and 
 * the scanner_type to em_scanner_type_radio.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 579@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                              | Test Data                                                                                     | Expected Result                                                                                 | Notes           |
 * | :--------------: | ---------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- | --------------- |
 * | 01               | Instantiate dm_easy_mesh_t and initialize it using init()                                | dm instance created, function call: dm.init()                                                 | dm instance is successfully created and initialized                                             | Should be successful |
 * | 02               | Setup default em_scan_result_t input structure                                           | input = {}                                                                                    | input structure is correctly initialized                                                        | Should be successful |
 * | 03               | Invoke update_scan_results() with the address of the input structure                       | input pointer = &input                                                                        | update_scan_results should update the m_scan_result_map to a non-null value                       | Should Pass         |
 * | 04               | Verify that m_scan_result_map is not nullptr                                               | dm.m_scan_result_map                                                                          | EXPECT_NE(dm.m_scan_result_map, nullptr) should pass                                            | Should Pass         |
 * | 05               | Validate that id.net_id equals "OneWifiMesh" and id.scanner_type equals em_scanner_type_radio | id.net_id = "OneWifiMesh", id.scanner_type = em_scanner_type_radio; Output: id structure fields  | EXPECT_STREQ(id.net_id, "OneWifiMesh") and EXPECT_EQ(id.scanner_type, em_scanner_type_radio) should pass | Should Pass         |
 */
TEST(dm_easy_mesh_t, UpdateScanResults_positive_CreateNewScanResult)
{
    std::cout << "Entering UpdateScanResults_positive_CreateNewScanResult test" << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_scan_result_t input{};
    std::cout << "Invoking update_scan_results(&scan_result)" << std::endl;
    dm.update_scan_results(&input);
    EXPECT_NE(dm.m_scan_result_map, nullptr);
    em_scan_result_id_t &id = input.id;
    std::cout << "Retrieved net_id: " << id.net_id << std::endl;
    std::cout << "Retrieved scanner_type: " << id.scanner_type << std::endl;
    EXPECT_STREQ(id.net_id, "OneWifiMesh");
    EXPECT_EQ(id.scanner_type, em_scanner_type_radio);
    dm.deinit();
    std::cout << "Exiting UpdateScanResults_positive_CreateNewScanResult test" << std::endl;
}

/**
 * @brief Validate update_scan_results API for updating an existing scan result.
 *
 * This test verifies that the update_scan_results function correctly processes an initial default scan result and then updates it with new values. The test ensures that after updating with a second scan result which has a modified scan_status, the scan_status remains 5 and the net_id is correctly set to "OneWifiMesh".
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 580@n
 * **Priority:** High@n
 * 
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 * 
 * **Test Procedure:** 
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Initialize dm_easy_mesh_t object and invoke init() method | dm_easy_mesh_t instance created, no parameters for init() | dm instance is initialized successfully | Should be successful |
 * | 02 | Invoke update_scan_results with first default initialized scan result | first: all members default-initialized | Scan result is processed without error | Should Pass |
 * | 03 | Prepare second scan result by setting scan_status to 5 and invoke update_scan_results | second: memset to 0, scan_status = 5 | scan_status remains 5 and net_id is updated to "OneWifiMesh" | Should Pass |
 * | 04 | Verify the updated value of scan_status and net_id using assertions | second.scan_status = 5, id.net_id = "OneWifiMesh" | EXPECT_EQ confirms scan_status == 5 and EXPECT_STREQ confirms net_id equals "OneWifiMesh" | Should Pass |
 */
TEST(dm_easy_mesh_t, UpdateScanResults_positive_UpdateExistingScanResult)
{
    std::cout << "Entering UpdateScanResults_positive_UpdateExistingScanResult test" << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_scan_result_t first{};
    std::cout << "Invoking update_scan_results(&first)" << std::endl;
    dm.update_scan_results(&first);
    em_scan_result_t second;
    memset(&second, 0, sizeof(second));
    second.scan_status = 5;
    std::cout << "Invoking update_scan_results(&second)" << std::endl;
    dm.update_scan_results(&second);
    em_scan_result_id_t &id = second.id;
    std::cout << "Updated scan_status: " << second.scan_status << std::endl;
    std::cout << "Retrieved net_id: " << id.net_id << std::endl;
    EXPECT_EQ(second.scan_status, 5);
    EXPECT_STREQ(id.net_id, "OneWifiMesh");
    dm.deinit();
    std::cout << "Exiting UpdateScanResults_positive_UpdateExistingScanResult test" << std::endl;
}

/**
 * @brief Validate that update_scan_results correctly handles a null pointer.
 *
 * This test verifies that the update_scan_results function throws an exception when invoked with a null pointer for scan results, ensuring that invalid inputs are properly guarded against.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 581@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                         | Test Data                                             | Expected Result                                                      | Notes             |
 * | :----:           | ------------------------------------------------------------------- | ----------------------------------------------------- | -------------------------------------------------------------------- | ----------------- |
 * | 01               | Instantiate dm_easy_mesh_t and invoke init() method                  | dm_easy_mesh_t instance, no input parameter for init()| dm_easy_mesh_t instance successfully initialized                     | Should be successful |
 * | 02               | Invoke update_scan_results with nullptr and verify it throws exception| input: scan_results = nullptr                           | Exception is thrown when update_scan_results is called with a null pointer | Should Pass       |
 */
TEST(dm_easy_mesh_t, UpdateScanResults_negative_NullScanResult)
{
    std::cout << "Entering UpdateScanResults_negative_NullScanResult test" << std::endl;
    dm_easy_mesh_t dm;
	dm.init();
    std::cout << "Invoking update_scan_results(nullptr)" << std::endl;
    EXPECT_ANY_THROW({
        dm.update_scan_results(nullptr);
    });
    std::cout << "Exiting UpdateScanResults_negative_NullScanResult test" << std::endl;
}

/**
 * @brief Validate static update_scan_results to correctly update the scan results structure
 *
 * This test verifies that the static method update_scan_results correctly updates the provided scan_result structure with valid net_id and scanner_type values when an initialized dm_easy_mesh_t object is used. This ensures that the scanning results are properly populated.
 *
 * **Test Group ID:** Basic: 01
 * **Test Case ID:** 582@n
 * **Priority:** High
 *
 * **Pre-Conditions:** None
 * **Dependencies:** None
 * **User Interaction:** None
 *
 * **Test Procedure:**
 * | Variation / Step | Description | Test Data | Expected Result | Notes |
 * | :----: | --------- | ---------- |-------------- | ----- |
 * | 01 | Create dm_easy_mesh_t instance and initialize it using the init method. | dm instance created | dm instance is properly initialized | Should be successful |
 * | 02 | Create em_scan_result_t instance and call static update_scan_results using dm pointer and scan_result pointer. | input1 = &dm, input2 = &input | input.id.net_id is updated to "OneWifiMesh" and input.id.scanner_type is updated to em_scanner_type_radio | Should Pass |
 * | 03 | Assert that the scan results match expected values using EXPECT_STREQ and EXPECT_EQ. | Expected: net_id = "OneWifiMesh", scanner_type = em_scanner_type_radio | EXPECT_STREQ and EXPECT_EQ pass confirming the correct updates | Should Pass |
 */
TEST(dm_easy_mesh_t, UpdateScanResults_positive_StaticMethod)
{
    std::cout << "Entering UpdateScanResults_positive_StaticMethod test" << std::endl;
    dm_easy_mesh_t dm;
    dm.init();
    em_scan_result_t input{};
    std::cout << "Invoking static update_scan_results(dm, &scan_result)" << std::endl;
    dm_easy_mesh_t::update_scan_results(&dm, &input);
    EXPECT_STREQ(input.id.net_id, "OneWifiMesh");
    EXPECT_EQ(input.id.scanner_type, em_scanner_type_radio);
    std::cout << "Retrieved net_id: " << input.id.net_id << std::endl;
    std::cout << "Retrieved scanner_type: " << input.id.scanner_type << std::endl;
    dm.deinit();
    std::cout << "Exiting UpdateScanResults_positive_StaticMethod test" << std::endl;
}

/**
 * @brief Validate that update_scan_results throws an exception when provided a nullptr for the dm object.
 *
 * This test verifies that the static method update_scan_results correctly handles a null pointer for the dm instance by throwing an exception. The scan result pointer is valid but the dm instance is not, ensuring robust error handling.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 583@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**
 * | Variation / Step | Description                                                                 | Test Data                                                      | Expected Result                                                  | Notes       |
 * | :--------------: | --------------------------------------------------------------------------- | -------------------------------------------------------------- | ---------------------------------------------------------------- | ----------- |
 * | 01               | Invoke update_scan_results with a null pointer for the dm instance and a valid pointer for scan results (memory zeroed out) | dm pointer = nullptr, scan_result pointer = address of input (all fields zeroed) | An exception is expected to be thrown (validated by EXPECT_ANY_THROW) | Should Fail |
 */
TEST(dm_easy_mesh_t, UpdateScanResults_negative_Static_NullDm)
{
    std::cout << "Entering UpdateScanResults_negative_Static_NullDm test" << std::endl;
    em_scan_result_t input;
    memset(&input, 0, sizeof(input));
    std::cout << "Invoking static update_scan_results(nullptr, &scan_result)" << std::endl;
    EXPECT_ANY_THROW({
        dm_easy_mesh_t::update_scan_results(nullptr, &input);
    });
    std::cout << "Exiting UpdateScanResults_negative_Static_NullDm test" << std::endl;
}

/**
 * @brief Validate that update_scan_results fails with a null scan result pointer.
 *
 * This test validates that when a null pointer is provided as the scan result to the static API update_scan_results, the function correctly throws an exception. This scenario ensures that the API robustly handles invalid input to prevent potential undefined behavior.
 *
 * **Test Group ID:** Basic: 01@n
 * **Test Case ID:** 584@n
 * **Priority:** High@n
 *
 * **Pre-Conditions:** None@n
 * **Dependencies:** None@n
 * **User Interaction:** None@n
 *
 * **Test Procedure:**@n
 * | Variation / Step | Description                                                                  | Test Data                                              | Expected Result                              | Notes             |
 * | :--------------: | ---------------------------------------------------------------------------- | ------------------------------------------------------ | -------------------------------------------- | ----------------- |
 * | 01               | Initialize a dm_easy_mesh_t object and reset its memory to zero              | dm pointer = valid address, memory set to 0            | dm object initialized successfully           | Should be successful |
 * | 02               | Invoke update_scan_results with a null pointer for the scan result             | input: dm pointer (initialized), scan_result = nullptr | API throws an exception as expected          | Should Fail         |
 * | 03               | Conclude the test execution after exception verification                     | No additional inputs                                   | Test concludes successfully                  | Should be successful |
 */
TEST(dm_easy_mesh_t, UpdateScanResults_negative_Static_NullScanResult)
{
    std::cout << "Entering UpdateScanResults_negative_Static_NullScanResult test" << std::endl;
    dm_easy_mesh_t dm;
    memset(&dm, 0, sizeof(dm_easy_mesh_t));
    std::cout << "Invoking static update_scan_results(&dm, nullptr)" << std::endl;
    EXPECT_ANY_THROW({
        dm_easy_mesh_t::update_scan_results(&dm, nullptr);
    });
    std::cout << "Exiting UpdateScanResults_negative_Static_NullScanResult test" << std::endl;
}